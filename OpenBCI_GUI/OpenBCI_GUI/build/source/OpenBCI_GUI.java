import processing.core.*; 
import processing.data.*; 
import processing.event.*; 
import processing.opengl.*; 

import ddf.minim.*; 
import ddf.minim.ugens.*; 
import java.lang.Math; 
import processing.core.PApplet; 
import java.util.*; 
import java.util.Map.Entry; 
import java.util.Map; 
import processing.serial.*; 
import java.awt.event.*; 
import processing.net.*; 
import grafica.*; 
import gifAnimation.*; 
import java.lang.reflect.*; 
import java.io.InputStreamReader; 
import java.io.OutputStream; 
import java.io.RandomAccessFile; 
import java.io.FileNotFoundException; 
import java.awt.MouseInfo; 
import java.lang.Process; 
import java.text.DateFormat; 
import java.text.SimpleDateFormat; 
import java.time.LocalTime; 
import java.time.format.DateTimeFormatter; 
import java.util.Random; 
import java.awt.Robot; 
import java.awt.AWTException; 
import netP5.*; 
import oscP5.*; 
import hypermedia.net.*; 
import java.nio.ByteBuffer; 
import edu.ucsd.sccn.LSL; 
import com.sun.jna.Library; 
import com.sun.jna.Native; 
import com.sun.jna.Platform; 
import com.sun.jna.Pointer; 
import java.io.PrintStream; 
import java.io.FileOutputStream; 
import java.awt.datatransfer.*; 
import java.awt.Toolkit; 
import java.awt.Desktop; 
import controlP5.*; 
import ddf.minim.analysis.*; 
import java.io.StringWriter; 
import java.awt.Desktop; 
import java.net.*; 
import java.nio.file.*; 
import java.awt.AWTException; 
import java.awt.Robot; 
import java.awt.event.KeyEvent; 

import edu.ucsd.sccn.*; 

import java.util.HashMap; 
import java.util.ArrayList; 
import java.io.File; 
import java.io.BufferedReader; 
import java.io.PrintWriter; 
import java.io.InputStream; 
import java.io.OutputStream; 
import java.io.IOException; 

public class OpenBCI_GUI extends PApplet {


///////////////////////////////////////////////////////////////////////////////
//
//   GUI for controlling the ADS1299-based OpenBCI
//
//   Created: Chip Audette, Oct 2013 - May 2014
//   Modified: Conor Russomanno & Joel Murphy, August 2014 - Dec 2014
//   Modified (v2.0): Conor Russomanno & Joel Murphy (AJ Keller helped too), June 2016
//   Modified (v3.0) AJ Keller (Conor Russomanno & Joel Murphy & Wangshu), September 2017
//   Modified (v4.0) AJ Keller (Richard Waltman), September 2018
//
//   Requires gwoptics graphing library for processing.  Built on V0.5.0
//   http://www.gwoptics.org/processing/gwoptics_p5lib/
//
//   Requires ControlP5 library, but an older one.  This will only work
//   with the ControlP5 library that is included with this GitHub repository
//
//   No warranty. Use at your own risk. Use for whatever you'd like.



//////////

// NEXT TIME - WRITE CODE FOR ARDUINO TO RECIEVE COMMANDS, AND UPLOAD IT TO THE BOARD
// THEN - ADD SERIAL PORT TO THIS CODE AND RUN IT, SEE IF IT WORKS!!!
//////

//
////////////////////////////////////////////////////////////////////////////////
  // To make sound.  Following minim example "frequencyModulation"
 // To make sound.  Following minim example "frequencyModulation"
 //for exp, log, sqrt...they seem better than Processing's built-in

 //for Array.copyOfRange()


 //for serial communication to Arduino/OpenBCI
 //to allow for event listener on screen resize
 // For TCP networking
 //used for graphs
  //for animated gifs
 // For callbacks
 // For input





 //Used in DataLogging.pde



// import java.net.InetAddress; // Used for ping, however not working right now.

 //used for simulating mouse clicks

 // for OSC
 // for OSC
 //for UDP
 //for UDP
 //for LSL
//These are used by LSL





//------------------------------------------------------------------------
//                       Global Variables & Instances
//------------------------------------------------------------------------
//Used to check GUI version in TopNav.pde and displayed on the splash screen on startup
String localGUIVersionString = "v4.1.7";
String localGUIVersionDate = "November 2019";
String guiLatestReleaseLocation = "https://github.com/OpenBCI/OpenBCI_GUI/releases/latest";
Boolean guiVersionCheckHasOccured = false;
DateFormat dateFormat = new SimpleDateFormat("HH:mm:ss.SSS");

//used to switch between application states
final int SYSTEMMODE_INTROANIMATION = -10;
final int SYSTEMMODE_PREINIT = 0;
final int SYSTEMMODE_MIDINIT = 5;
final int SYSTEMMODE_POSTINIT = 10;
int systemMode = SYSTEMMODE_INTROANIMATION; /* Modes: -10 = intro sequence; 0 = system stopped/control panel setings; 10 = gui; 20 = help guide */

boolean midInit = false;
boolean abandonInit = false;
boolean systemHasHalted = false;

final int NCHAN_CYTON = 8;
final int NCHAN_CYTON_DAISY = 16;
final int NCHAN_GANGLION = 4;

PImage cog;
Gif loadingGIF;
Gif loadingGIF_blue;

// ---- Define variables related to OpenBCI_GUI UDPMarker functionality
UDP udpRX;

//choose where to get the EEG data
final int DATASOURCE_CYTON = 0; // new default, data from serial with Accel data CHIP 2014-11-03
final int DATASOURCE_GANGLION = 1;  //looking for signal from OpenBCI board via Serial/COM port, no Aux data
final int DATASOURCE_PLAYBACKFILE = 2;  //playback from a pre-recorded text file
final int DATASOURCE_SYNTHETIC = 3;  //Synthetically generated data
public int eegDataSource = -1; //default to none of the options

final int INTERFACE_NONE = -1; // Used to indicate no choice made yet on interface
final int INTERFACE_SERIAL = 0; // Used only by cyton
final int INTERFACE_HUB_BLE = 1; // used only by ganglion
final int INTERFACE_HUB_WIFI = 2; // used by both cyton and ganglion
final int INTERFACE_HUB_BLED112 = 3; // used only by ganglion with bled dongle

boolean showStartupError = false;
String startupErrorMessage = "";
//here are variables that are used if loading input data from a CSV text file...double slash ("\\") is necessary to make a single slash
String playbackData_fname = "N/A"; //only used if loading input data from a file
// String playbackData_fname;  //leave blank to cause an "Open File" dialog box to appear at startup.  USEFUL!
int currentTableRowIndex = 0;
Table_CSV playbackData_table;
int nextPlayback_millis = -100; //any negative number

// Initialize boards for constants
Cyton cyton = new Cyton(); //dummy creation to get access to constants, create real one later
Ganglion ganglion = new Ganglion(); //dummy creation to get access to constants, create real one later
// Intialize interface protocols
InterfaceSerial iSerial = new InterfaceSerial();
Hub hub = new Hub(); //dummy creation to get access to constants, create real one later

String openBCI_portName = "N/A";  //starts as N/A but is selected from control panel to match your OpenBCI USB Dongle's serial/COM
int openBCI_baud = 115200; //baud rate from the Arduino

String ganglion_portName = "N/A";

String wifi_portName = "N/A";
String wifi_ipAddress = "192.168.4.1";

final static String PROTOCOL_BLE = "ble";
final static String PROTOCOL_BLED112 = "bled112";
final static String PROTOCOL_SERIAL = "serial";
final static String PROTOCOL_WIFI = "wifi";

////// ---- Define variables related to OpenBCI board operations
//Define number of channels from cyton...first EEG channels, then aux channels
int nchan = NCHAN_CYTON; //Normally, 8 or 16.  Choose a smaller number to show fewer on the GUI
int n_aux_ifEnabled = 3;  // this is the accelerometer data CHIP 2014-11-03
//define variables related to warnings to the user about whether the EEG data is nearly railed (and, therefore, of dubious quality)
DataStatus is_railed[];
final int threshold_railed = PApplet.parseInt(pow(2, 23)-1000);  //fully railed should be +/- 2^23, so set this threshold close to that value
final int threshold_railed_warn = PApplet.parseInt(pow(2, 23)*0.9f); //set a somewhat smaller value as the warning threshold
//OpenBCI SD Card setting (if eegDataSource == 0)
int sdSetting = 0; //0 = do not write; 1 = 5 min; 2 = 15 min; 3 = 30 min; etc...
String sdSettingString = "Do not write to SD";
//cyton data packet
int nDataBackBuff;
DataPacket_ADS1299 dataPacketBuff[]; //allocate later in InitSystem
int curDataPacketInd = -1;
int curBDFDataPacketInd = -1;
int lastReadDataPacketInd = -1;
////// ---- End variables related to the OpenBCI boards

// define some timing variables for this program's operation
long timeOfLastFrame = 0;
long timeOfInit;
boolean attemptingToConnect = false;

// Calculate nPointsPerUpdate based on sampling rate and buffer update rate
// @UPDATE_MILLIS: update the buffer every 40 milliseconds
// @nPointsPerUpdate: update the GUI after this many data points have been received.
// The sampling rate should be ideally a multiple of 25, so as to make actual buffer update rate exactly 40ms
final int UPDATE_MILLIS = 40;
int nPointsPerUpdate;   // no longer final, calculate every time in initSystem
// final int nPointsPerUpdate = 50; //update the GUI after this many data points have been received
// final int nPointsPerUpdate = 24; //update the GUI after this many data points have been received
// final int nPointsPerUpdate = 10; //update the GUI after this many data points have been received

//define some data fields for handling data here in processing
float dataBuffX[];  //define the size later
float dataBuffY_uV[][]; //2D array to handle multiple data channels, each row is a new channel so that dataBuffY[3][] is channel 4
float dataBuffY_filtY_uV[][];
float yLittleBuff[];
float yLittleBuff_uV[][]; //small buffer used to send data to the filters
float accelerometerBuff[][]; // accelerometer buff 500 points
float auxBuff[][];
float data_elec_imp_ohm[];

float displayTime_sec = 20f;    //define how much time is shown on the time-domain montage plot (and how much is used in the FFT plot?)
float dataBuff_len_sec = displayTime_sec + 3f; //needs to be wider than actual display so that filter startup is hidden

//variables for writing EEG data out to a file
OutputFile_rawtxt fileoutput_odf;
OutputFile_BDF fileoutput_bdf;
String output_fname;
String sessionName = "N/A";
final int OUTPUT_SOURCE_NONE = 0;
final int OUTPUT_SOURCE_ODF = 1; // The OpenBCI CSV Data Format
final int OUTPUT_SOURCE_BDF = 2; // The BDF data format http://www.biosemi.com/faq/file_format.htm
public int outputDataSource = OUTPUT_SOURCE_ODF;
// public int outputDataSource = OUTPUT_SOURCE_BDF;

// Serial output
String serial_output_portName = "/dev/tty.usbmodem1421";  //must edit this based on the name of the serial/COM port
Serial serial_output;
int serial_output_baud = 9600; //baud rate from the Arduino

//Control Panel for (re)configuring system settings
PlotFontInfo fontInfo;

//program variables
boolean isRunning = false;
boolean redrawScreenNow = true;
int openBCI_byteCount = 0;
StringBuilder board_message;

//set window size
int win_x = 1024;  //window width
int win_y = 768; //window height

PImage logo_blue;
PImage logo_white;
PImage consoleImgBlue;
PImage consoleImgWhite;

PFont f1;
PFont f2;
PFont f3;
PFont f4;

PFont h1; //large Montserrat
PFont h2; //large/medium Montserrat
PFont h3; //medium Montserrat
PFont h4; //small/medium Montserrat
PFont h5; //small Montserrat

PFont p0; //large bold Open Sans
PFont p1; //large Open Sans
PFont p2; //large/medium Open Sans
PFont p3; //medium Open Sans
PFont p15;
PFont p4; //medium/small Open Sans
PFont p13;
PFont p5; //small Open Sans
PFont p6; //small Open Sans

ButtonHelpText buttonHelpText;

//Used for playback file
boolean has_processed = false;
boolean isOldData = false;
boolean playbackFileIsEmpty = false;
int indices = 0;
//# columns used by a playback file determines number of channels
final int totalColumns4ChanThresh = 10;
final int totalColumns16ChanThresh = 16;

boolean setupComplete = false;
boolean isHubInitialized = false;
boolean isHubObjectInitialized = false;
int bgColor = color(1, 18, 41);
int openbciBlue = color(31, 69, 110);
int COLOR_SCHEME_DEFAULT = 1;
int COLOR_SCHEME_ALTERNATIVE_A = 2;
// int COLOR_SCHEME_ALTERNATIVE_B = 3;
int colorScheme = COLOR_SCHEME_ALTERNATIVE_A;

Process nodeHubby;
String nodeHubName = "OpenBCIHub";
Timer hubTimer = new Timer(true);
boolean hubTimerHasStarted = false;
int hubTimerCounter; //Count how many times GUI tries to connect to Hub
int hubTimerLimit = 8; //Allow up to 8 tries for GUI to connect to Hub
int hubTimerInterval = 2500; //try every 2.5 seconds, 8*2.5=20seconds

PApplet ourApplet;

static CustomOutputStream outputStream;

//Variables from TopNav.pde. Used to set text when stopping/starting data stream.
public final static String stopButton_pressToStop_txt = "Stop Data Stream";
public final static String stopButton_pressToStart_txt = "Start Data Stream";

///////////Variables from HardwareSettingsController. This fixes a number of issues.
int numSettingsPerChannel = 6; //each channel has 6 different settings
char[][] channelSettingValues = new char [nchan][numSettingsPerChannel]; // [channel#][Button#-value] ... this will incfluence text of button
char[][] impedanceCheckValues = new char [nchan][2];

SoftwareSettings settings = new SoftwareSettings();

//------------------------------------------------------------------------
//                       Global Functions
//------------------------------------------------------------------------

//========================SETUP============================//

int frameRateCounter = 1; //0 = 24, 1 = 30, 2 = 45, 3 = 60

public void settings() {
    // If 1366x768, set GUI to 976x549 to fix #378 regarding some laptop resolutions
    // Later changed to 976x742 so users can access full control panel
    if (displayWidth == 1366 && displayHeight == 768) {
        size(976, 742, P2D);
    } else {
        //default 1024x768 resolution with 2D graphics
        size(win_x, win_y, P2D);
    }
}

public void setup() {
    //V1 FONTS
    f1 = createFont("fonts/Raleway-SemiBold.otf", 16);
    f2 = createFont("fonts/Raleway-Regular.otf", 15);
    f3 = createFont("fonts/Raleway-SemiBold.otf", 15);
    f4 = createFont("fonts/Raleway-SemiBold.otf", 64);  // clear bigger fonts for widgets

    h1 = createFont("fonts/Montserrat-Regular.otf", 20);
    h2 = createFont("fonts/Montserrat-Regular.otf", 18);
    h3 = createFont("fonts/Montserrat-Regular.otf", 16);
    h4 = createFont("fonts/Montserrat-Regular.otf", 14);
    h5 = createFont("fonts/Montserrat-Regular.otf", 12);

    p0 = createFont("fonts/OpenSans-Semibold.ttf", 24);
    p1 = createFont("fonts/OpenSans-Regular.ttf", 20);
    p2 = createFont("fonts/OpenSans-Regular.ttf", 18);
    p3 = createFont("fonts/OpenSans-Regular.ttf", 16);
    p15 = createFont("fonts/OpenSans-Regular.ttf", 15);
    p4 = createFont("fonts/OpenSans-Regular.ttf", 14);
    p13 = createFont("fonts/OpenSans-Regular.ttf", 13);
    p5 = createFont("fonts/OpenSans-Regular.ttf", 12);
    p6 = createFont("fonts/OpenSans-Regular.ttf", 10);

    cog = loadImage("cog_1024x1024.png");

    // check if the current directory is writable
    File dummy = new File(sketchPath());
    if (!dummy.canWrite()) {
        showStartupError = true;
        startupErrorMessage = "OpenBCI GUI was launched from a read-only location.\n\n" +
            "Please move the application to a different location and re-launch.\n" +
            "If you just downloaded the GUI, move it out of the disk image or Downloads folder.\n\n" +
            "If this error persists, contact the OpenBCI team for support.";
        return; // early exit
    }

    // redirect all output to a custom stream that will intercept all prints
    // write them to file and display them in the GUI's console window
    outputStream = new CustomOutputStream(System.out);
    System.setOut(outputStream);
    System.setErr(outputStream);

    println("Console Log Started at Local Time: " + getDateString());
    println("Screen Resolution: " + displayWidth + " X " + displayHeight);
    println("Welcome to the Processing-based OpenBCI GUI!"); //Welcome line.
    println("For more information, please visit: https://openbci.github.io/Documentation/docs/06Software/01-OpenBCISoftware/GUIDocs");



    //open window
    ourApplet = this;

    if(frameRateCounter==0) {
        frameRate(24); //refresh rate ... this will slow automatically, if your processor can't handle the specified rate
    }
    if(frameRateCounter==1) {
        frameRate(30); //refresh rate ... this will slow automatically, if your processor can't handle the specified rate
    }
    if(frameRateCounter==2) {
        frameRate(45); //refresh rate ... this will slow automatically, if your processor can't handle the specified rate
    }
    if(frameRateCounter==3) {
        frameRate(60); //refresh rate ... this will slow automatically, if your processor can't handle the specified rate
    }

    // Bug #426: If setup takes too long, JOGL will time out waiting for the GUI to draw something.
    // moving the setup to a separate thread solves this. We just have to make sure not to
    // start drawing until delayed setup is done.
    thread("delayedSetup");
}

public void delayedSetup() {
    if (!isWindows()) hubStop(); //kill any existing hubs before starting a new one..
    hubInit(); // putting down here gives windows time to close any open apps

    smooth(); //turn this off if it's too slow

    surface.setResizable(true);  //updated from frame.setResizable in Processing 2
    settings.widthOfLastScreen = width; //for screen resizing (Thank's Tao)
    settings.heightOfLastScreen = height;

    setupContainers();

    //listen for window resize ... used to adjust elements in application
    frame.addComponentListener(new ComponentAdapter() {
        public void componentResized(ComponentEvent e) {
            if (e.getSource()==frame) {
                println("OpenBCI_GUI: setup: RESIZED");
                settings.screenHasBeenResized = true;
                settings.timeOfLastScreenResize = millis();
                // initializeGUI();
            }
        }
    }
    );

    fontInfo = new PlotFontInfo();
    helpWidget = new HelpWidget(0, win_y - 30, win_x, 30);

    //setup topNav
    topNav = new TopNav();

    logo_blue = loadImage("logo_blue.png");
    logo_white = loadImage("logo_white.png");
    consoleImgBlue = loadImage("console-45x45-dots_blue.png");
    consoleImgWhite = loadImage("console-45x45-dots_white.png");
    loadingGIF = new Gif(this, "ajax_loader_gray_512.gif");
    loadingGIF.loop();
    loadingGIF_blue = new Gif(this, "OpenBCI-LoadingGIF-blue-256.gif");
    loadingGIF_blue.loop();

    buttonHelpText = new ButtonHelpText();

    myPresentation = new Presentation();

    // UDPMarker functionality
    // Setup the UDP receiver // This needs to be done only when marker mode is enabled
    int portRX = 51000;  // this is the UDP port the application will be listening on
    String ip = "127.0.0.1";  // Currently only localhost is supported as UDP Marker source

    // Create new object for receiving
    udpRX=new UDP(this,portRX,ip);
    udpRX.setReceiveHandler("udpReceiveHandler");
    udpRX.log(true);
    udpRX.listen(true);
    // Print some useful diagnostics
    println("OpenBCI_GUI::Setup: Is RX mulitcast: "+udpRX.isMulticast());
    println("OpenBCI_GUI::Setup: Has RX joined multicast: "+udpRX.isJoined());

    // Create GUI data folder and copy sample data if meditation file doesn't exist
    copyGUISampleData();

    synchronized(this) {
        // Instantiate ControlPanel in the synchronized block.
        // It's important to avoid instantiating a ControlP5 during a draw() call
        // Otherwise we get a crash on launch 10% of the time
        controlPanel = new ControlPanel(this);

        setupComplete = true; // signal that the setup thread has finished
        println("OpenBCI_GUI::Setup: Setup is complete!");
    }
}

public void copyGUISampleData(){
    String directoryName = settings.guiDataPath + File.separator + "Sample_Data" + File.separator;
    String fileToCheckString = directoryName + "OpenBCI-sampleData-2-meditation.txt";
    File directory = new File(directoryName);
    File fileToCheck = new File(fileToCheckString);
    if (!fileToCheck.exists()){
        println("OpenBCI_GUI::Setup: Copying sample data to Documents/OpenBCI_GUI/Sample_Data");
        // Make the entire directory path including parents
        directory.mkdirs();
        try {
            List<File> results = new ArrayList<File>();
            File[] filesFound = new File(dataPath("EEG_Sample_Data")).listFiles();
            //If this pathname does not denote a directory, then listFiles() returns null.
            for (File file : filesFound) {
                if (file.isFile()) {
                    results.add(file);
                }
            }
            for(File file : results) {
                Files.copy(file.toPath(),
                    (new File(directoryName + file.getName())).toPath(),
                    StandardCopyOption.REPLACE_EXISTING);
            }
        } catch (IOException e) {
            outputError("Setup: Error trying to copy Sample Data to Documents directory.");
        }
    } else {
        println("OpenBCI_GUI::Setup: Sample Data exists in Documents folder.");
    }

    //Create \Documents\OpenBCI_GUI\Recordings\ if it doesn't exist
    String recordingDirString = settings.guiDataPath + File.separator + "Recordings";
    File recDirectory = new File(recordingDirString);
    if (recDirectory.mkdir()) {
        println("OpenBCI_GUI::Setup: Created \\Documents\\OpenBCI_GUI\\Recordings\\");
    }
}

//====================== END-OF-SETUP ==========================//

//====================UDP Packet Handler==========================//
// This function handles the received UDP packet
// See the documentation for the Java UDP class here:
// https://ubaa.net/shared/processing/udp/udp_class_udp.htm

String udpReceiveString = null;

public void udpReceiveHandler(byte[] data, String ip, int portRX) {

    String udpString = new String(data);
    println(udpString+" from: "+ip+" and port: "+portRX);
    if (udpString.length() >=5  && udpString.indexOf("MARK") >= 0) {

        int intValue = Integer.parseInt(udpString.substring(4));

        if (intValue > 0 && intValue < 96) { // Since we only send single char ascii value markers (from space to char(126)
            String sendString = "`"+PApplet.parseChar(intValue+31);
            println("Marker value: "+udpString+" with numeric value of char("+intValue+") as : "+sendString);
            hub.sendCommand(sendString);

        } else {
            println("udpReceiveHandler::Warning:invalid UDP STIM of value: "+intValue+" Received String: "+udpString);
        }
    } else {
            println("udpReceiveHandler::Warning:invalid UDP marker packet: "+udpString);

    }
}

//======================== DRAW LOOP =============================//

public synchronized void draw() {
    if (showStartupError) {
        drawStartupError();
    } else if (setupComplete && systemMode != SYSTEMMODE_INTROANIMATION) {
        drawLoop_counter++; //signPost("10");
        systemUpdate(); //signPost("20");
        systemDraw();   //signPost("30");
    } else if (systemMode == SYSTEMMODE_INTROANIMATION) {
        if (settings.introAnimationInit == 0) {
            settings.introAnimationInit = millis();
        } else {
            introAnimation();
        }
    }
}

//====================== END-OF-DRAW ==========================//

/**
  * This allows us to kill the running node process on quit.
  */
private void prepareExitHandler () {
    Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
        public void run () {
            System.out.println("SHUTDOWN HOOK");
            //If user starts system and quits the app,
            //save user settings for current mode!
            try {
                if (systemMode == SYSTEMMODE_POSTINIT) {
                    settings.save(settings.getPath("User", eegDataSource, nchan));
                }
            } catch (NullPointerException e) {
                e.printStackTrace();
            }
            //Close network streams
            if (w_networking != null && w_networking.getNetworkActive()) {
                w_networking.stopNetwork();
                println("openBCI_GUI: shutDown: Network streams stopped");
            }
            //Shutdown the hub
            try {
                if (hubStop()) {
                    System.out.println("SHUTDOWN HUB");
                } else {
                    System.out.println("FAILED TO SHUTDOWN HUB");
                }

            } catch (Exception ex) {
                ex.printStackTrace(); // not much else to do at this point
            }
        }
    }
    ));
}

/**
  * Starts the hub and sets prepares the exit handler.
  */
public void hubInit() {
    isHubInitialized = true;
    hubStart();
    prepareExitHandler();
}

/**
  * Starts the node hub working, tested on mac and windows.
  */
public void hubStart() {
    println("Launching application from local data dir");
    try {
        // https://forum.processing.org/two/discussion/13053/use-launch-for-applications-kept-in-data-folder
        if (isWindows()) {
            println("OpenBCI_GUI: hubStart: OS Detected: Windows");
            nodeHubby = launch(dataPath("/OpenBCIHub/OpenBCIHub.exe"));
        } else if (isLinux()) {
            println("OpenBCI_GUI: hubStart: OS Detected: Linux");
            nodeHubby = exec(dataPath("./OpenBCIHub/OpenBCIHub"));
        } else {
            println("OpenBCI_GUI: hubStart: OS Detected: Mac");
            nodeHubby = launch(dataPath("OpenBCIHub.app"));
        }
        // hubRunning = true;
    }
    catch (Exception e) {
        println("hubStart: " + e);
    }
}

/**
  * @description Single function to call at the termination program hook.
  */
public boolean hubStop() {
    if (isWindows()) {
        return killRunningprocessWin();
    } else {
        killRunningProcessMac();
        return true;
    }
}

/**
  * @description Helper function to determine if the system is linux or not.
  * @return {boolean} true if os is linux, false otherwise.
  */
private boolean isLinux() {
    return System.getProperty("os.name").toLowerCase().indexOf("linux") > -1;
}

/**
  * @description Helper function to determine if the system is windows or not.
  * @return {boolean} true if os is windows, false otherwise.
  */
private boolean isWindows() {
    return System.getProperty("os.name").toLowerCase().indexOf("windows") > -1;
}

/**
  * @description Helper function to determine if the system is macOS or not.
  * @return {boolean} true if os is windows, false otherwise.
  */
private boolean isMac() {
    return !isWindows() && !isLinux();
}

/**
  * @description Parses the running process list for processes whose name have ganglion hub, if found, kills them one by one.
  *  function dubbed "death dealer"
  */
public void killRunningProcessMac() {
    try {
        String line;
        Process p = Runtime.getRuntime().exec("ps -e");
        BufferedReader input =
            new BufferedReader(new InputStreamReader(p.getInputStream()));
        while ((line = input.readLine()) != null) {
            if (line.contains(nodeHubName)) {
                try {
                    endProcess(getProcessIdFromLineMac(line));
                    println("Killed: " + line);
                }
                catch (Exception err) {
                    println("Failed to stop process: " + line + "\n\n");
                    err.printStackTrace();
                }
            }
        }
        input.close();
    }
    catch (Exception err) {
        err.printStackTrace();
    }
}

/**
  * @description Parses the running process list for processes whose name have ganglion hub, if found, kills them one by one.
  *  function dubbed "death dealer" aka "cat killer"
  */
public boolean killRunningprocessWin() {
    try {
        Runtime.getRuntime().exec("taskkill /F /IM OpenBCIHub.exe");
        return true;
    }
    catch (Exception err) {
        err.printStackTrace();
        return false;
    }
}

/**
  * @description Parses a mac process line and grabs the pid, the first component.
  * @return {int} the process id
  */
public int getProcessIdFromLineMac(String line) {
    line = trim(line);
    String[] components = line.split(" ");
    return Integer.parseInt(components[0]);
}

public void endProcess(int pid) {
    Runtime rt = Runtime.getRuntime();
    try {
        rt.exec("kill -9 " + pid);
    }
    catch (IOException err) {
        err.printStackTrace();
    }
}

int pointCounter = 0;
int prevBytes = 0;
int prevMillis = millis();
int byteRate_perSec = 0;
int drawLoop_counter = 0;

//used to init system based on initial settings...Called from the "START SESSION" button in the GUI's ControlPanel

public void setupWidgetManager() {
    wm = new WidgetManager(this);
}

//Initialize the system
public void initSystem() throws Exception {
    println("");
    println("");
    println("=================================================");
    println("||             INITIALIZING SYSTEM             ||");
    println("=================================================");
    println("");

    timeOfInit = millis(); //store this for timeout in case init takes too long
    verbosePrint("OpenBCI_GUI: initSystem: -- Init 0 -- " + timeOfInit);
    //Checking status here causes "error: resource busy" during init
    /*
    if (eegDataSource == DATASOURCE_CYTON) {
        verbosePrint("OpenBCI_GUI: initSystem: Checking Cyton Connection...");
        system_status(rcBox);
        if (rcStringReceived.startsWith("Cyton dongle could not connect") || rcStringReceived.startsWith("Failure")) {
            throw new Exception("OpenBCI_GUI: initSystem: Dongle failed to connect to Cyton...");
        }
    }
    */
    verbosePrint("OpenBCI_GUI: initSystem: Preparing data variables...");
    //initialize playback file if necessary
    if (eegDataSource == DATASOURCE_PLAYBACKFILE) {
        initPlaybackFileToTable(); //found in W_Playback.pde
    }
    verbosePrint("OpenBCI_GUI: initSystem: Initializing core data objects");
    initCoreDataObjects();

    verbosePrint("OpenBCI_GUI: initSystem: -- Init 1 -- " + millis());
    verbosePrint("OpenBCI_GUI: initSystem: Initializing FFT data objects");
    initFFTObjectsAndBuffer();

    //prepare some signal processing stuff
    //for (int Ichan=0; Ichan < nchan; Ichan++) { detData_freqDomain[Ichan] = new DetectionData_FreqDomain(); }

    verbosePrint("OpenBCI_GUI: initSystem: -- Init 2 -- " + millis());
    verbosePrint("OpenBCI_GUI: initSystem: Closing ControlPanel...");

    controlPanel.close();
    topNav.controlPanelCollapser.setIsActive(false);
    verbosePrint("OpenBCI_GUI: initSystem: Initializing comms with hub....");
    hub.changeState(HubState.COMINIT);
    // hub.searchDeviceStop();

    //prepare the source of the input data
    switch (eegDataSource) {
        case DATASOURCE_CYTON:
            int nEEDataValuesPerPacket = nchan;
            boolean useAux = true;
            if (cyton.getInterface() == INTERFACE_SERIAL) {
                cyton = new Cyton(this, openBCI_portName, openBCI_baud, nEEDataValuesPerPacket, useAux, n_aux_ifEnabled, cyton.getInterface()); //this also starts the data transfer after XX seconds
            } else {
                if (hub.getWiFiStyle() == WIFI_DYNAMIC) {
                    cyton = new Cyton(this, wifi_portName, openBCI_baud, nEEDataValuesPerPacket, useAux, n_aux_ifEnabled, cyton.getInterface()); //this also starts the data transfer after XX seconds
                } else {
                    cyton = new Cyton(this, wifi_ipAddress, openBCI_baud, nEEDataValuesPerPacket, useAux, n_aux_ifEnabled, cyton.getInterface()); //this also starts the data transfer after XX seconds
                }
            }
            break;
        case DATASOURCE_SYNTHETIC:
            //do nothing
            break;
        case DATASOURCE_PLAYBACKFILE:
            break;
        case DATASOURCE_GANGLION:
            if (ganglion.getInterface() == INTERFACE_HUB_BLE || ganglion.getInterface() == INTERFACE_HUB_BLED112) {
                hub.connectBLE(ganglion_portName);
            } else {
                if (hub.getWiFiStyle() == WIFI_DYNAMIC) {
                    hub.connectWifi(wifi_portName);
                } else {
                    hub.connectWifi(wifi_ipAddress);
                }
            }
            break;
        default:
            break;
        }

    verbosePrint("OpenBCI_GUI: initSystem: -- Init 3 -- " + millis());

    if (abandonInit) {
        haltSystem();
        println("Failed to connect to data source... 1");
        outputError("Failed to connect to data source fail point 1");
    } else {
        //initilize the GUI
        topNav.initSecondaryNav();

        setupWidgetManager();

        if (!abandonInit) {
            nextPlayback_millis = millis(); //used for synthesizeData and readFromFile.  This restarts the clock that keeps the playback at the right pace.
            w_timeSeries.hsc.loadDefaultChannelSettings();

            if (eegDataSource != DATASOURCE_GANGLION && eegDataSource != DATASOURCE_CYTON) {
                systemMode = SYSTEMMODE_POSTINIT; //tell system it's ok to leave control panel and start interfacing GUI
            }
            if (!abandonInit) {
                controlPanel.close();
            } else {
                haltSystem();
                println("Failed to connect to data source... 2");
                // output("Failed to connect to data source...");
            }
        } else {
            haltSystem();
            println("Failed to connect to data source... 3");
            // output("Failed to connect to data source...");
        }
    }

    verbosePrint("OpenBCI_GUI: initSystem: -- Init 4 -- " + millis());
    
    if (eegDataSource == DATASOURCE_CYTON) {
        if (hub.getFirmwareVersion() == null && hub.getProtocol().equals(PROTOCOL_WIFI)) {
            println("Cyton+WiFi: Unable to find board firmware version");
        } else if (hub.getFirmwareVersion().equals("v1.0.0")) {
            //this means the firmware is very out of date, and commands may not work, so abandon init
            abandonInit = true;
        } else {
            //println("FOUND FIRMWARE FROM HUB == " + hub.getFirmwareVersion());
        }
    }

    if (!abandonInit) {
        //Init software settings: create default settings files, load user settings, etc.
        settings.init();
        settings.initCheckPointFive();
    } else {
        haltSystem();
        if (eegDataSource == DATASOURCE_CYTON) {
            //Normally, this message appears if you have a dongle plugged in, and the Cyton is not On, or on the wrong channel.
            if (cyton.daisyNotAttached) {
                outputError("Daisy is not attached to the Cyton board. Check connection or select 8 Channels.");
            } else {
                outputError("Check that the device is powered on and in range. Also, try AUTOSCAN. Otherwise, Cyton firmware is out of date.");
            }
        } else {
            outputError("Failed to connect. Check that the device is powered on and in range.");
        }
        controlPanel.open();
        systemMode = SYSTEMMODE_PREINIT; // leave this here
    }

    //reset init variables
    cyton.daisyNotAttached = false;
    midInit = false;
    abandonInit = false;
    systemHasHalted = false;
} //end initSystem

/**
  * @description Useful function to get the correct sample rate based on data source
  * @returns `float` - The frequency / sample rate of the data source
  */
public float getSampleRateSafe() {
    if (eegDataSource == DATASOURCE_GANGLION) {
        return ganglion.getSampleRate();
    } else if (eegDataSource == DATASOURCE_CYTON) {
        return cyton.getSampleRate();
    } else if (eegDataSource == DATASOURCE_PLAYBACKFILE) {
        return playbackData_table.getSampleRate();
    } else {
        return 250;
    }
}

/**
* @description Get the correct points of FFT based on sampling rate
* @returns `int` - Points of FFT. 125Hz, 200Hz, 250Hz -> 256points. 1000Hz -> 1024points. 1600Hz -> 2048 points.
*/
public int getNfftSafe() {
    int sampleRate = (int)getSampleRateSafe();
    switch (sampleRate) {
        case 1000:
            return 1024;
        case 1600:
            return 2048;
        case 125:
        case 200:
        case 250:
        default:
            return 256;
    }
}

public void initCoreDataObjects() {
    // Nfft = getNfftSafe();
    nDataBackBuff = 3*(int)getSampleRateSafe();
    dataPacketBuff = new DataPacket_ADS1299[nDataBackBuff]; // call the constructor here
    nPointsPerUpdate = PApplet.parseInt(round(PApplet.parseFloat(UPDATE_MILLIS) * getSampleRateSafe()/ 1000.f));
    dataBuffX = new float[(int)(dataBuff_len_sec * getSampleRateSafe())];
    dataBuffY_uV = new float[nchan][dataBuffX.length];
    dataBuffY_filtY_uV = new float[nchan][dataBuffX.length];
    yLittleBuff = new float[nPointsPerUpdate];
    yLittleBuff_uV = new float[nchan][nPointsPerUpdate]; //small buffer used to send data to the filters
    auxBuff = new float[3][nPointsPerUpdate];
    accelerometerBuff = new float[3][500]; // 500 points = 25Hz * 20secs(Max Window)
    for (int i=0; i<n_aux_ifEnabled; i++) {
        for (int j=0; j<accelerometerBuff[0].length; j++) {
            accelerometerBuff[i][j] = 0;
        }
    }
    //data_std_uV = new float[nchan];
    data_elec_imp_ohm = new float[nchan];
    is_railed = new DataStatus[nchan];
    for (int i=0; i<nchan; i++) is_railed[i] = new DataStatus(threshold_railed, threshold_railed_warn);
    for (int i=0; i<nDataBackBuff; i++) {
        dataPacketBuff[i] = new DataPacket_ADS1299(nchan, n_aux_ifEnabled);
    }
    dataProcessing = new DataProcessing(nchan, getSampleRateSafe());

    //initialize the arduino along with user data processing
    //Arduino arduino = new Arduino(OpenBCI.serial);
    dataProcessing_user = new DataProcessing_User();

    //initialize the data
    prepareData(dataBuffX, dataBuffY_uV, getSampleRateSafe());
}

public void initFFTObjectsAndBuffer() {
    //initialize the FFT objects
    for (int Ichan=0; Ichan < nchan; Ichan++) {
        // verbosePrint("Init FFT Buff – " + Ichan);
        fftBuff[Ichan] = new FFT(getNfftSafe(), getSampleRateSafe());
    }  //make the FFT objects

    //Attempt initialization. If error, print to console and exit function.
    //Fixes GUI crash when trying to load outdated recordings
    try {
        initializeFFTObjects(fftBuff, dataBuffY_uV, getNfftSafe(), getSampleRateSafe());
    } catch (ArrayIndexOutOfBoundsException e) {
        //e.printStackTrace();
        outputError("Playback file load error. Try using a more recent recording.");
        return;
    }
}

public void startRunning() {
    verbosePrint("startRunning...");
    output("Data stream started.");
    if (eegDataSource == DATASOURCE_GANGLION) {
        if (ganglion != null) {
            ganglion.startDataTransfer();
        }
    } else if (eegDataSource == DATASOURCE_CYTON) {
        if (cyton != null) {
            cyton.startDataTransfer();
        }
    }
    isRunning = true;
}

public void stopRunning() {
    // openBCI.changeState(0); //make sure it's no longer interpretting as binary
    verbosePrint("OpenBCI_GUI: stopRunning: stop running...");
    if (isRunning) {
        output("Data stream stopped.");
    }
    if (eegDataSource == DATASOURCE_GANGLION) {
        if (ganglion != null) {
            ganglion.stopDataTransfer();
        }
    } else {
        if (cyton != null) {
            cyton.stopDataTransfer();
        }
    }

    isRunning = false;
    // openBCI.changeState(0); //make sure it's no longer interpretting as binary
    // systemMode = 0;
    // closeLogFile();
}

//execute this function whenver the stop button is pressed
public void stopButtonWasPressed() {
    //toggle the data transfer state of the ADS1299...stop it or start it...
    if (isRunning) {
        verbosePrint("openBCI_GUI: stopButton was pressed...stopping data transfer...");
        wm.setUpdating(false);
        stopRunning();
        topNav.stopButton.setString(stopButton_pressToStart_txt);
        topNav.stopButton.setColorNotPressed(color(184, 220, 105));
        if (eegDataSource == DATASOURCE_GANGLION && ganglion.isCheckingImpedance()) {
            ganglion.impedanceStop();
        }
        //Close the log file when using OpenBCI Data Format (.txt)
        if (outputDataSource == OUTPUT_SOURCE_ODF) closeLogFile();
        //BDF+ allows for breaks in the file, so leave the temp file open!
    } else { //not running
        verbosePrint("openBCI_GUI: startButton was pressed...starting data transfer...");
        wm.setUpdating(true);
        // Clear plots when start button is pressed in playback mode
        if (eegDataSource == DATASOURCE_PLAYBACKFILE) {
            clearAllTimeSeriesGPlots();
            clearAllAccelGPlots();
        }
        startRunning();
        topNav.stopButton.setString(stopButton_pressToStop_txt);
        topNav.stopButton.setColorNotPressed(color(224, 56, 45));
        nextPlayback_millis = millis();  //used for synthesizeData and readFromFile.  This restarts the clock that keeps the playback at the right pace.
        if (eegDataSource == DATASOURCE_GANGLION && ganglion.isCheckingImpedance()) {
            ganglion.impedanceStop();
        }
        if (outputDataSource > OUTPUT_SOURCE_NONE && eegDataSource < DATASOURCE_PLAYBACKFILE) {
            //open data file if it has not already been opened
            if (!settings.isLogFileOpen()) {
                if (eegDataSource == DATASOURCE_CYTON) openNewLogFile(getDateString());
                if (eegDataSource == DATASOURCE_GANGLION) openNewLogFile(getDateString());
            }
            settings.setLogFileStartTime(System.nanoTime());
        }
    }
}


//halt the data collection
public void haltSystem() {
    if (!systemHasHalted) { //prevents system from halting more than once
        println("openBCI_GUI: haltSystem: Halting system for reconfiguration of settings...");
        if (initSystemButton.but_txt == "STOP SESSION") {
            initSystemButton.but_txt = "START SESSION";
        }

        if (w_networking != null && w_networking.getNetworkActive()) {
            w_networking.stopNetwork();
            println("openBCI_GUI: haltSystem: Network streams stopped");
        }

        stopRunning();  //stop data transfer

        //Save a snapshot of User's GUI settings if the system is stopped, or halted. This will be loaded on next Start System.
        //This method establishes default and user settings for all data modes
        if (systemMode == SYSTEMMODE_POSTINIT) {
            settings.save(settings.getPath("User", eegDataSource, nchan));
        }

        if(cyton.isPortOpen()) { //On halt and the port is open, reset board mode to Default.
            if (w_pulsesensor.analogReadOn || w_analogRead.analogReadOn) {
                cyton.setBoardMode(BoardMode.DEFAULT);
                output("Starting to read accelerometer");
                w_pulsesensor.analogModeButton.setString("Turn Analog Read On");
                w_pulsesensor.analogReadOn = false;
                w_analogRead.analogModeButton.setString("Turn Analog Read On");
                w_analogRead.analogReadOn = false;
            } else if (w_digitalRead.digitalReadOn) {
                cyton.setBoardMode(BoardMode.DEFAULT);
                output("Starting to read accelerometer");
                w_digitalRead.digitalModeButton.setString("Turn Digital Read On");
                w_digitalRead.digitalReadOn = false;
            } else if (w_markermode.markerModeOn) {
                cyton.setBoardMode(BoardMode.DEFAULT);
                output("Starting to read accelerometer");
                w_markermode.markerModeButton.setString("Turn Marker On");
                w_markermode.markerModeOn = false;
            }
        }

        //reset variables for data processing
        curDataPacketInd = -1;
        lastReadDataPacketInd = -1;
        pointCounter = 0;
        currentTableRowIndex = 0;
        prevBytes = 0;
        prevMillis = millis();
        byteRate_perSec = 0;
        drawLoop_counter = 0;
        // eegDataSource = -1;
        //set all data source list items inactive

        //Fix issue for processing successive playback files
        indices = 0;
        hasRepeated = false;
        has_processed = false;
        settings.settingsLoaded = false; //on halt, reset this value

        //reset connect loadStrings
        openBCI_portName = "N/A";  // Fixes inability to reconnect after halding  JAM 1/2017
        ganglion_portName = "N/A";
        wifi_portName = "N/A";

        controlPanel.resetListItems();

        if (eegDataSource == DATASOURCE_CYTON) {
            closeLogFile();  //close log file
            cyton.closeSDandPort();
        } else if (eegDataSource == DATASOURCE_GANGLION) {
            if(ganglion.isCheckingImpedance()) {
                ganglion.impedanceStop();
                w_ganglionImpedance.startStopCheck.but_txt = "Start Impedance Check";
            }
            closeLogFile();  //close log file
            ganglion.impedanceArray = new int[NCHAN_GANGLION + 1];
            ganglion.closePort();
        } else if (eegDataSource == DATASOURCE_PLAYBACKFILE) {
            controlPanel.recentPlaybackBox.getRecentPlaybackFiles();
        }
        systemMode = SYSTEMMODE_PREINIT;
        hub.changeState(HubState.NOCOM);

        recentPlaybackFilesHaveUpdated = false;

        // bleList.items.clear();
        // wifiList.items.clear();

        // if (ganglion.isBLE() || ganglion.isWifi() || cyton.isWifi()) {
        //   hub.searchDeviceStart();
        // }

        systemHasHalted = true;
    }
} //end of halt system

public void systemUpdate() { // for updating data values and variables

    //Instantiate Hub Object, wait until next step to try to startTCPClient
    if (isHubInitialized && isHubObjectInitialized == false) {
        hub = new Hub(this);
        println("Instantiating hub object...");
        isHubObjectInitialized = true;
    }
    //Then, immediately start trying to connect to Hub for X seconds
    if (!hub.isHubRunning()) {
        if (!hubTimerHasStarted) {
            hubTimer.schedule(new CheckHubInit(), 0, hubTimerInterval);
            hubTimerHasStarted = true;
        } else {
            if (hubTimerCounter == hubTimerLimit) {
                hubTimer.cancel();
                outputError("Unable to find or connect to Hub. LIVE functionality will be disabled.");
                hubTimerCounter = 0;
            }
        }
    }

    //prepare for updating the GUI
    win_x = width;
    win_y = height;

    helpWidget.update();
    topNav.update();
    if (systemMode == SYSTEMMODE_PREINIT) {
        //updates while in system control panel before START SYSTEM
        controlPanel.update();

        if (settings.widthOfLastScreen != width || settings.heightOfLastScreen != height) {
            imposeMinimumGUIDimensions();
            topNav.screenHasBeenResized(width, height);
            settings.widthOfLastScreen = width;
            settings.heightOfLastScreen = height;
            //println("W = " + width + " || H = " + height);
        }
    }
    if (systemMode == SYSTEMMODE_POSTINIT) {
        if (isRunning) {
            //get the data, if it is available
            pointCounter = getDataIfAvailable(pointCounter);

            //has enough data arrived to process it and update the GUI?
            if (pointCounter >= nPointsPerUpdate) {
                 //reset for next time
                pointCounter = 0;
                //process the data
                processNewData();
                //set this flag to true, checked at the beginning of systemDraw()
                redrawScreenNow=true;
            } else {
                //not enough data has arrived yet... only update the channel controller
            }

            //New feature to address #461, defined in DataLogging.pde
            //Applied to OpenBCI Data Format for LIVE mode recordings (Cyton and Ganglion)
            //Don't check duration if user has selected "No Limit"
            if (outputDataSource == OUTPUT_SOURCE_ODF
                && eegDataSource < DATASOURCE_PLAYBACKFILE
                && settings.limitOBCILogFileDuration()) {
                    fileoutput_odf.limitRecordingFileDuration();
            }

        } else if (eegDataSource == DATASOURCE_PLAYBACKFILE && !has_processed && !isOldData) {
            lastReadDataPacketInd = 0;
            pointCounter = 0;
            try {
                process_input_file();
                println("^^^GUI update process file has occurred");
            }
            catch(Exception e) {
                isOldData = true;
                println("^^^Error processing timestamps");
                output("Error processing timestamps, are you using old data?");
            }
        }

        // gui.cc.update(); //update Channel Controller even when not updating certain parts of the GUI... (this is a bit messy...)

        //alternative component listener function (line 177 - 187 frame.addComponentListener) for processing 3,
        if (settings.widthOfLastScreen != width || settings.heightOfLastScreen != height) {
            println("OpenBCI_GUI: setup: RESIZED");
            settings.screenHasBeenResized = true;
            settings.timeOfLastScreenResize = millis();
            settings.widthOfLastScreen = width;
            settings.heightOfLastScreen = height;
        }

        //re-initialize GUI if screen has been resized and it's been more than 1/2 seccond (to prevent reinitialization of GUI from happening too often)
        if (settings.screenHasBeenResized) {
            ourApplet = this; //reset PApplet...
            imposeMinimumGUIDimensions();
            topNav.screenHasBeenResized(width, height);
            wm.screenResized();
        }
        if (settings.screenHasBeenResized == true && (millis() - settings.timeOfLastScreenResize) > settings.reinitializeGUIdelay) {
            settings.screenHasBeenResized = false;
            println("systemUpdate: reinitializing GUI");
            settings.timeOfGUIreinitialize = millis();
        }

        if (wm.isWMInitialized) {
            wm.update();
        }
    }
}

public void systemDraw() { //for drawing to the screen
    //redraw the screen...not every time, get paced by when data is being plotted
    background(bgColor);  //clear the screen
    noStroke();
    //background(255);  //clear the screen

    if (systemMode >= SYSTEMMODE_POSTINIT) {
        int drawLoopCounter_thresh = 100;
        if ((redrawScreenNow) || (drawLoop_counter >= drawLoopCounter_thresh)) {
            //if (drawLoop_counter >= drawLoopCounter_thresh) println("OpenBCI_GUI: redrawing based on loop counter...");
            drawLoop_counter=0; //reset for next time
            redrawScreenNow = false;  //reset for next time

            //update the title of the figure;
            switch (eegDataSource) {
            case DATASOURCE_CYTON:
                switch (outputDataSource) {
                case OUTPUT_SOURCE_ODF:
                    if (fileoutput_odf != null) {
                        surface.setTitle(PApplet.parseInt(frameRate) + " fps, " + PApplet.parseInt(PApplet.parseFloat(fileoutput_odf.getRowsWritten())/getSampleRateSafe()) + " secs Saved, Writing to " + output_fname);
                    }
                    break;
                case OUTPUT_SOURCE_BDF:
                    if (fileoutput_bdf != null) {
                        surface.setTitle(PApplet.parseInt(frameRate) + " fps, " + PApplet.parseInt(fileoutput_bdf.getRecordsWritten()) + " secs Saved, Writing to " + output_fname);
                    }
                    break;
                case OUTPUT_SOURCE_NONE:
                default:
                    surface.setTitle(PApplet.parseInt(frameRate) + " fps");
                    break;
                }
                break;
            case DATASOURCE_SYNTHETIC:
                surface.setTitle(PApplet.parseInt(frameRate) + " fps, Using Synthetic EEG Data");
                break;
            case DATASOURCE_PLAYBACKFILE:
                surface.setTitle(PApplet.parseInt(frameRate) + " fps, Playing " + getElapsedTimeInSeconds(currentTableRowIndex) + " of " + PApplet.parseInt(PApplet.parseFloat(playbackData_table.getRowCount())/getSampleRateSafe()) + " secs, Reading from: " + playbackData_fname);
                break;
            case DATASOURCE_GANGLION:
                surface.setTitle(PApplet.parseInt(frameRate) + " fps, Ganglion!");
                break;
            }
        }

        //wait 1 second for GUI to reinitialize
        if ((millis() - settings.timeOfGUIreinitialize) > settings.reinitializeGUIdelay) {
            // println("attempting to draw GUI...");
            try {
                // println("GUI DRAW!!! " + millis());
                //draw GUI widgets (visible/invisible) using widget manager
                wm.draw();
            } catch (Exception e) {
                println(e.getMessage());
                settings.reinitializeGUIdelay = settings.reinitializeGUIdelay * 2;
                println("OpenBCI_GUI: systemDraw: New GUI reinitialize delay = " + settings.reinitializeGUIdelay);
            }
        } else {
            //reinitializing GUI after resize
            println("OpenBCI_GUI: systemDraw: reinitializing GUI after resize... not drawing GUI");
        }

        //dataProcessing_user.draw();
        drawContainers();
    } else { //systemMode != 10
        //still print title information about fps
        surface.setTitle(PApplet.parseInt(frameRate) + " fps - OpenBCI GUI");
    }

    if (systemMode >= SYSTEMMODE_PREINIT) {
        topNav.draw();

        //control panel
        if (controlPanel.isOpen) {
            controlPanel.draw();
        }

        helpWidget.draw();
    }

    if ((hub.get_state() == HubState.COMINIT || hub.get_state() == HubState.SYNCWITHHARDWARE) && systemMode == SYSTEMMODE_PREINIT) {
        if (!attemptingToConnect) {
            output("Attempting to establish a connection with your OpenBCI Board...");
            attemptingToConnect = true;
        } else {
            //@TODO: Fix this so that it shows during successful system inits ex. Cyton+Daisy w/ UserSettings
            pushStyle();
            imageMode(CENTER);
            image(loadingGIF, width/2, height/2, 128, 128);//render loading gif...
            popStyle();
        }

        if (millis() - timeOfInit > settings.initTimeoutThreshold) {
            haltSystem();
            initSystemButton.but_txt = "START SESSION";
            output("Init timeout. Verify your Serial/COM Port. Power DOWN/UP your OpenBCI Board & Dongle, then retry Initialization.");
            controlPanel.open();
            attemptingToConnect = false;
        }
    }

    //draw presentation last, bc it is intended to be rendered on top of the GUI ...
    if (drawPresentation) {
        myPresentation.draw();
        //emg_widget.drawTriggerFeedback();
        //dataProcessing_user.drawTriggerFeedback();
    }

    // use commented code below to verify frameRate and check latency
    // println("Time since start: " + millis() + " || Time since last frame: " + str(millis()-timeOfLastFrame));
    // timeOfLastFrame = millis();

    buttonHelpText.draw();
    mouseOutOfBounds(); // to fix
}

public void introAnimation() {
    pushStyle();
    imageMode(CENTER);
    background(255);
    int t1 = 0;
    float transparency = 0;

    if (millis() >= settings.introAnimationInit) {
        transparency = map(millis() - settings.introAnimationInit, t1, settings.introAnimationDuration, 0, 255);
        verbosePrint(String.valueOf(transparency));
        tint(255, transparency);
        //draw OpenBCI Logo Front & Center
        image(cog, width/2, height/2, width/6, width/6);
        textFont(p3, 16);
        textLeading(24);
        fill(31, 69, 110, transparency);
        textAlign(CENTER, CENTER);
        String displayVersion = "OpenBCI GUI " + localGUIVersionString;
        text(displayVersion, width/2, height/2 + width/9);
        text(localGUIVersionDate, width/2, height/2 + ((width/8) * 1.125f));
    }

    //Exit intro animation when the duration has expired AND the Control Panel is ready
    if ((millis() >= settings.introAnimationInit + settings.introAnimationDuration)
        && controlPanel != null) {
        systemMode = SYSTEMMODE_PREINIT;
        controlPanel.isOpen = true;
    }
    popStyle();
}

public void drawStartupError() {
    final int w = 600;
    final int h = 350;
    final int headerHeight = 75;
    final int padding = 20;

    pushStyle();
    background(bgColor);
    stroke(204);
    fill(238);
    rect((width - w)/2, (height - h)/2, w, h);
    noStroke();
    fill(217, 4, 4);
    rect((width - w)/2, (height - h)/2, w, headerHeight);
    textFont(p0, 24);
    fill(255);
    textAlign(LEFT, CENTER);
    text("Error", (width - w)/2 + padding, (height - h)/2, w, headerHeight);
    textFont(p3, 16);
    fill(102);
    textAlign(LEFT, TOP);
    text(startupErrorMessage, (width - w)/2 + padding, (height - h)/2 + padding + headerHeight, w-padding*2, h-padding*2-headerHeight);
    popStyle();
}

public void openConsole()
{
    ConsoleWindow.display();
}

//CODE FOR FIXING WEIRD EXIT CRASH ISSUE -- 7/27/16 ===========================
boolean mouseInFrame = false;
boolean windowOriginSet = false;
int appletOriginX = 0;
int appletOriginY = 0;
PVector loc;

public void mouseOutOfBounds() {
    if (windowOriginSet && mouseInFrame) {

        try {
            if (MouseInfo.getPointerInfo().getLocation().x <= appletOriginX ||
                MouseInfo.getPointerInfo().getLocation().x >= appletOriginX+width ||
                MouseInfo.getPointerInfo().getLocation().y <= appletOriginY ||
                MouseInfo.getPointerInfo().getLocation().y >= appletOriginY+height) {
                mouseX = 0;
                mouseY = 0;
                // println("Mouse out of bounds!");
                mouseInFrame = false;
            }
        }
        catch (RuntimeException e) {
            verbosePrint("Error happened while cursor left application...");
        }
    } else {
        if (mouseX > 0 && mouseX < width && mouseY > 0 && mouseY < height) {
            loc = getWindowLocation(P2D);
            appletOriginX = (int)loc.x;
            appletOriginY = (int)loc.y;
            windowOriginSet = true;
            mouseInFrame = true;
        }
    }
}

public PVector getWindowLocation(String renderer) {
    PVector l = new PVector();
    if (renderer == P2D || renderer == P3D) {
        com.jogamp.nativewindow.util.Point p = new com.jogamp.nativewindow.util.Point();
        ((com.jogamp.newt.opengl.GLWindow)surface.getNative()).getLocationOnScreen(p);
        l.x = p.getX();
        l.y = p.getY();
    } else if (renderer == JAVA2D) {
        java.awt.Frame f =  (java.awt.Frame) ((processing.awt.PSurfaceAWT.SmoothCanvas) surface.getNative()).getFrame();
        l.x = f.getX();
        l.y = f.getY();
    }
    return l;
}
//END OF CODE FOR FIXING WEIRD EXIT CRASH ISSUE -- 7/27/16 ===========================
//////////////////////////////////////////////////////////
//
// This class creates and manages messaging to the Arduino
//
// Based on Chip Audette's code
//
//////////////////////////////////////////////////////////

class Arduino {
    class Command {
    private String command_str;
    private String name;
    private int counter;
    private Serial serial_h;
    public boolean printReceivedCommand = false;
    public int ID;
    
    Command(Serial _serial_h, String _str, String _name, int _ID) {
      serial_h = _serial_h;
      command_str = _str;
      name =_name;
      counter = 0;
      ID = _ID;
    }
    
    public int issue() {
      counter++;
      if (printReceivedCommand) println("Arduino: Command: " + name + " (" + counter + ")");
      if (serial_h != null) serial_h.write(command_str + "\n");
      return ID;
    }
  } //close definition of class Command

    private Command command_fire, command_forward, command_left, command_right; 
    private int prev_command = -1;

    //Constructor, pass in an already-opened serial port
    Arduino (Serial serialPort){
        int ID = 0;
        command_fire = new Command(serialPort, "|", "Fire!", ID++);
        command_left = new Command(serialPort,"{","Left",ID++);
        command_right = new Command(serialPort,"}","Right",ID++);
        command_forward = new Command(serialPort,"P","Forward",ID++);
    }

    public void fire() {
        prev_command = command_fire.issue();
    }
    public void forward(){
        if (prev_command != command_forward.ID) prev_command = command_fire.issue();
        prev_command = command_forward.issue();
    }

    public void left() {
        if (prev_command != command_left.ID) prev_command = command_fire.issue();  //issue a FIRE command on a transition
        prev_command = command_left.issue();
    }
    public void right() {
        if (prev_command != command_right.ID) prev_command = command_fire.issue();  //issue a FIRE command on a transition
        prev_command = command_right.issue();
    }
}
///////////////////////////////////////////////////////////////////////////////
//
// This class configures and manages the connection to the OpenBCI shield for
// the Arduino.  The connection is implemented via a Serial connection.
// The OpenBCI is configured using single letter text commands sent from the
// PC to the Arduino.  The EEG data streams back from the Arduino to the PC
// continuously (once started).  This class defaults to using binary transfer
// for normal operation.
//
// Created: Chip Audette, Oct 2013
// Modified: through April 2014
// Modified again: Conor Russomanno Sept-Oct 2014
// Modified for Daisy (16-chan) OpenBCI V3: Conor Russomanno Nov 2014
// Modified Daisy Behaviors: Chip Audette Dec 2014
//
// Note: this class now expects the data format produced by OpenBCI V3.
//
/////////////////////////////////////////////////////////////////////////////


//------------------------------------------------------------------------
//                       Global Variables & Instances
//------------------------------------------------------------------------

final char command_stop = 's';
// final String command_startText = "x";
final char command_startBinary = 'b';

final char[] command_deactivate_channel = {'1', '2', '3', '4', '5', '6', '7', '8', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i'};
final char[] command_activate_channel = {'!', '@', '#', '$', '%', '^', '&', '*', 'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I'};

enum BoardMode {
    DEFAULT(0),
    DEBUG(1),
    ANALOG(2),
    DIGITAL(3),
    MARKER(4);

    private final int value;
    BoardMode(final int newValue) {
        value = newValue;
    }
    public int getValue() { return value; }
}

//------------------------------------------------------------------------
//                       Classes
//------------------------------------------------------------------------

class Cyton {

    private int nEEGValuesPerPacket = 8; //defined by the data format sent by cyton boards
    private int nAuxValuesPerPacket = 3; //defined by the data format sent by cyton boards
    private DataPacket_ADS1299 rawReceivedDataPacket;
    private DataPacket_ADS1299 missedDataPacket;
    private DataPacket_ADS1299 dataPacket;

    private final int fsHzSerialCyton = 250;  //sample rate used by OpenBCI board...set by its Arduino code
    private final int fsHzSerialCytonDaisy = 125;  //sample rate used by OpenBCI board...set by its Arduino code
    private final int fsHzWifi = 1000;  //sample rate used by OpenBCI board...set by its Arduino code
    private final float ADS1299_Vref = 4.5f;  //reference voltage for ADC in ADS1299.  set by its hardware
    private float ADS1299_gain = 24.0f;  //assumed gain setting for ADS1299.  set by its Arduino code
    private float openBCI_series_resistor_ohms = 2200; // Ohms. There is a series resistor on the 32 bit board.
    private float scale_fac_uVolts_per_count = ADS1299_Vref / ((float)(pow(2, 23)-1)) / ADS1299_gain  * 1000000.f; //ADS1299 datasheet Table 7, confirmed through experiment
    private final float scale_fac_accel_G_per_count = 0.002f / ((float)pow(2, 4));  //assume set to +/4G, so 2 mG per digit (datasheet). Account for 4 bits unused
    //private final float scale_fac_accel_G_per_count = 1.0;  //to test stimulations  //final float scale_fac_accel_G_per_count = 1.0;
    private final float leadOffDrive_amps = 6.0e-9f;  //6 nA, set by its Arduino code

    private BoardMode curBoardMode = BoardMode.DEFAULT;

    private int curInterface = INTERFACE_SERIAL;
    private int sampleRate = fsHzWifi;

    // needed by interfaceserial
    public int hardwareSyncStep = 0; //start this at 0...
    public String potentialFailureMessage = "";
    public String defaultChannelSettings = "";
    public String daisyOrNot = "";

    // used to detect and flag error during initialization
    public boolean daisyNotAttached = false;

    //some get methods
    public float getSampleRate() {
        if (isSerial()) {
            if (nchan == NCHAN_CYTON_DAISY) {
                return fsHzSerialCytonDaisy;
            } else {
                return fsHzSerialCyton;
            }
        } else {
            return hub.getSampleRate();
        }
    }

    public BoardMode getBoardMode() {
        return curBoardMode;
    }
    public int getInterface() {
        return curInterface;
    }
    public float get_series_resistor() {
        return openBCI_series_resistor_ohms;
    }
    public float get_scale_fac_uVolts_per_count() {
        return scale_fac_uVolts_per_count;
    }
    public float get_scale_fac_accel_G_per_count() {
        return scale_fac_accel_G_per_count;
    }
    public float get_leadOffDrive_amps() {
        return leadOffDrive_amps;
    }

    public void setBoardMode(BoardMode boardMode) {
        hub.sendCommand("/" + boardMode.getValue());
        curBoardMode = boardMode;
        println("Cyton: setBoardMode to :" + curBoardMode);
    }

    public void setSampleRate(int _sampleRate) {
        sampleRate = _sampleRate;
        // output("Setting sample rate for Cyton to " + sampleRate + "Hz");
        println("Setting sample rate for Cyton to " + sampleRate + "Hz");
        hub.setSampleRate(sampleRate);
    }

    public boolean setInterface(int _interface) {
        curInterface = _interface;
        // println("current interface: " + curInterface);
        println("setInterface: curInterface: " + getInterface());
        if (isWifi()) {
            setSampleRate((int)fsHzWifi);
            hub.setProtocol(PROTOCOL_WIFI);
        } else if (isSerial()) {
            setSampleRate((int)fsHzSerialCyton);
            hub.setProtocol(PROTOCOL_SERIAL);
        }
        return true;
    }

    //constructors
    Cyton() {};  //only use this if you simply want access to some of the constants
    Cyton(PApplet applet, String comPort, int baud, int nEEGValuesPerOpenBCI, boolean useAux, int nAuxValuesPerOpenBCI, int _interface) {
        curInterface = _interface;

        initDataPackets(nEEGValuesPerOpenBCI, nAuxValuesPerOpenBCI);

        if (isSerial()) {
            hub.connectSerial(comPort);
        } else if (isWifi()) {
            hub.connectWifi(comPort);
        }
    }

    public void initDataPackets(int _nEEGValuesPerPacket, int _nAuxValuesPerPacket) {
        nEEGValuesPerPacket = _nEEGValuesPerPacket;
        nAuxValuesPerPacket = _nAuxValuesPerPacket;
        //allocate space for data packet
        rawReceivedDataPacket = new DataPacket_ADS1299(nEEGValuesPerPacket, nAuxValuesPerPacket);  //this should always be 8 channels
        missedDataPacket = new DataPacket_ADS1299(nEEGValuesPerPacket, nAuxValuesPerPacket);  //this should always be 8 channels
        dataPacket = new DataPacket_ADS1299(nEEGValuesPerPacket, nAuxValuesPerPacket);            //this could be 8 or 16 channels
        //set all values to 0 so not null

        for (int i = 0; i < nEEGValuesPerPacket; i++) {
            rawReceivedDataPacket.values[i] = 0;
            //prevDataPacket.values[i] = 0;
        }

        for (int i=0; i < nEEGValuesPerPacket; i++) {
            dataPacket.values[i] = 0;
            missedDataPacket.values[i] = 0;
        }
        for (int i = 0; i < nAuxValuesPerPacket; i++) {
            rawReceivedDataPacket.auxValues[i] = 0;
            dataPacket.auxValues[i] = 0;
            missedDataPacket.auxValues[i] = 0;
            //prevDataPacket.auxValues[i] = 0;
        }
    }

    public int closeSDandPort() {
        closeSDFile();
        return closePort();
    }

    public int closePort() {
        if (isSerial()) {
            return hub.disconnectSerial();
        } else {
            return hub.disconnectWifi();
        }
    }

    public int closeSDFile() {
        println("Closing any open SD file. Writing 'j' to OpenBCI.");
        if (isPortOpen()) write('j'); // tell the SD file to close if one is open...
        delay(100); //make sure 'j' gets sent to the board
        return 0;
    }

    public void syncWithHardware(int sdSetting) {
        switch (hardwareSyncStep) {
        case 1: //send # of channels (8 or 16) ... (regular or daisy setup)
            println("Cyton: syncWithHardware: [1] Sending channel count (" + nchan + ") to OpenBCI...");
            if (nchan == 8) {
            write('c');
            }
            if (nchan == 16) {
            write('C', false);
            }
            break;
        case 2: //reset hardware to default registers
            println("Cyton: syncWithHardware: [2] Reseting OpenBCI registers to default... writing \'d\'...");
            write('d'); // TODO: Why does this not get a $$$ readyToSend = false?
            break;
        case 3: //ask for series of channel setting ASCII values to sync with channel setting interface in GUI
            println("Cyton: syncWithHardware: [3] Retrieving OpenBCI's channel settings to sync with GUI... writing \'D\'... waiting for $$$...");
            write('D', false); //wait for $$$ to iterate... applies to commands expecting a response
            break;
        case 4: //check existing registers
            println("Cyton: syncWithHardware: [4] Retrieving OpenBCI's full register map for verification... writing \'?\'... waiting for $$$...");
            write('?', false); //wait for $$$ to iterate... applies to commands expecting a response
            break;
        case 5:
            // write("j"); // send OpenBCI's 'j' commaned to make sure any already open SD file is closed before opening another one...
            switch (sdSetting) {
            case 1: //"5 min max"
                write('A', false); //wait for $$$ to iterate... applies to commands expecting a response
                break;
            case 2: //"15 min max"
                write('S', false); //wait for $$$ to iterate... applies to commands expecting a response
                break;
            case 3: //"30 min max"
                write('F', false); //wait for $$$ to iterate... applies to commands expecting a response
                break;
            case 4: //"1 hr max"
                write('G', false); //wait for $$$ to iterate... applies to commands expecting a response
                break;
            case 5: //"2 hr max"
                write('H', false); //wait for $$$ to iterate... applies to commands expecting a response
                break;
            case 6: //"4 hr max"
                write('J', false); //wait for $$$ to iterate... applies to commands expecting a response
                break;
            case 7: //"12 hr max"
                write('K', false); //wait for $$$ to iterate... applies to commands expecting a response
                break;
            case 8: //"24 hr max"
                write('L', false); //wait for $$$ to iterate... applies to commands expecting a response
                break;
            default:
                break; // Do Nothing
            }
            println("Cyton: syncWithHardware: [5] Writing selected SD setting (" + sdSettingString + ") to OpenBCI...");
            //final hacky way of abandoning initiation if someone selected daisy but doesn't have one connected.
            if(abandonInit){
            haltSystem();
            output("No daisy board present. Make sure you selected the correct number of channels.");
            controlPanel.open();
            abandonInit = false;
            }
            break;
        case 6:
            println("Cyton: syncWithHardware: The GUI is done initializing. Click outside of the control panel to interact with the GUI.");
            hub.changeState(HubState.STOPPED);
            systemMode = 10;
            controlPanel.close();
            topNav.controlPanelCollapser.setIsActive(false);
            //renitialize GUI if nchan has been updated... needs to be built
            break;
        }
    }

    public boolean write(char val) {
        if (hub.isHubRunning()) {
            hub.sendCommand(val);
            return true;
        }
        return false;
    }

    public boolean write(char val, boolean _readyToSend) {
        return write(val);
    }

    private boolean isSerial () {
        // println("My interface is " + curInterface);
        return curInterface == INTERFACE_SERIAL;
    }

    private boolean isWifi () {
        return curInterface == INTERFACE_HUB_WIFI;
    }

    public void startDataTransfer() {
        if (isPortOpen()) {
            // Now give the command to start binary data transmission
            if (isSerial()) {
                hub.changeState(HubState.NORMAL);  // make sure it's now interpretting as binary
                println("Cyton: startDataTransfer(): writing \'" + command_startBinary + "\' to the serial port...");
                write(command_startBinary);
            } else if (isWifi()) {
                println("Cyton: startDataTransfer(): writing \'" + command_startBinary + "\' to the wifi shield...");
                write(command_startBinary);
            }

        } else {
            println("Cyton: Port not open");
        }
    }

    public void stopDataTransfer() {
        if (isPortOpen()) {
            hub.changeState(HubState.STOPPED);  // make sure it's now interpretting as binary
            println("Cyton: startDataTransfer(): writing \'" + command_stop + "\' to the serial port...");
            write(command_stop);// + "\n");
        }
    }

    public void printRegisters() {
        if (isPortOpen()) {
            println("Cyton: printRegisters(): Writing ? to OpenBCI...");
            write('?');
        }
    }

    private boolean isPortOpen() {
        if (isWifi() || isSerial()) {
            return hub.isPortOpen();
        } else {
            return false;
        }
    }

    //activate or deactivate an EEG channel...channel counting is zero through nchan-1
    public void changeChannelState(int Ichan, boolean activate) {
        if (isPortOpen()) {
            // if ((Ichan >= 0) && (Ichan < command_activate_channel.length)) {
            if ((Ichan >= 0)) {
                if (activate) {
                    // write(command_activate_channel[Ichan]);
                    // gui.cc.powerUpChannel(Ichan);
                    w_timeSeries.hsc.powerUpChannel(Ichan);
                } else {
                    // write(command_deactivate_channel[Ichan]);
                    // gui.cc.powerDownChannel(Ichan);
                    w_timeSeries.hsc.powerDownChannel(Ichan);
                }
            }
        }
    }

    //deactivate an EEG channel...channel counting is zero through nchan-1
    public void deactivateChannel(int Ichan) {
        if (isPortOpen()) {
            if ((Ichan >= 0) && (Ichan < command_deactivate_channel.length)) {
                write(command_deactivate_channel[Ichan]);
            }
        }
    }

    //activate an EEG channel...channel counting is zero through nchan-1
    public void activateChannel(int Ichan) {
        if (isPortOpen()) {
            if ((Ichan >= 0) && (Ichan < command_activate_channel.length)) {
                write(command_activate_channel[Ichan]);
            }
        }
    }

    public void configureAllChannelsToDefault() {
        write('d');
    };

    /**
      * Used to convert a gain from the hub back into local codes.
      */
    public char getCommandForGain(int gain) {
        switch (gain) {
            case 1:
                return '0';
            case 2:
                return '1';
            case 4:
                return '2';
            case 6:
                return '3';
            case 8:
                return '4';
            case 12:
                return '5';
            case 24:
            default:
                return '6';
        }
    }

    /**
      * Used to convert raw code to hub code
      * @param inputType {String} - The input from a hub sync channel with register settings
      */
    public char getCommandForInputType(String inputType) {
        if (inputType.equals("normal")) return '0';
        if (inputType.equals("shorted")) return '1';
        if (inputType.equals("biasMethod")) return '2';
        if (inputType.equals("mvdd")) return '3';
        if (inputType.equals("temp")) return '4';
        if (inputType.equals("testsig")) return '5';
        if (inputType.equals("biasDrp")) return '6';
        if (inputType.equals("biasDrn")) return '7';
        return '0';
    }

    /**
      * Used to convert a local channel code into a hub gain which is human
      *  readable and in scientific values.
      */
    public int getGainForCommand(char cmd) {
        switch (cmd) {
            case '0':
                return 1;
            case '1':
                return 2;
            case '2':
                return 4;
            case '3':
                return 6;
            case '4':
                return 8;
            case '5':
                return 12;
            case '6':
            default:
                return 24;
        }
    }

    /**
      * Used right before a channel setting command is sent to the hub to convert
      *  local values into the expected form for the hub.
      */
    public String getInputTypeForCommand(char cmd) {
        final String inputTypeShorted = "shorted";
        final String inputTypeBiasMethod = "biasMethod";
        final String inputTypeMvdd = "mvdd";
        final String inputTypeTemp = "temp";
        final String inputTypeTestsig = "testsig";
        final String inputTypeBiasDrp = "biasDrp";
        final String inputTypeBiasDrn = "biasDrn";
        final String inputTypeNormal = "normal";
        switch (cmd) {
            case '1':
                return inputTypeShorted;
            case '2':
                return inputTypeBiasMethod;
            case '3':
                return inputTypeMvdd;
            case '4':
                return inputTypeTemp;
            case '5':
                return inputTypeTestsig;
            case '6':
                return inputTypeBiasDrp;
            case '7':
                return inputTypeBiasDrn;
            case '0':
            default:
                return inputTypeNormal;
        }
    }

    /**
      * Used to convert a local index number to a hub human readable sd setting
      *  command.
      */
    public String getSDSettingForSetting(int setting) {
        switch (setting) {
            case 1:
                return "5min";
            case 2:
                return "15min";
            case 3:
                return "30min";
            case 4:
                return "1hour";
            case 5:
                return "2hour";
            case 6:
                return "4hour";
            case 7:
                return "12hour";
            case 8:
                return "24hour";
            default:
                return "";
        }
    }

    // FULL DISCLAIMER: this method is messy....... very messy... we had to brute force a firmware miscue
    public void writeChannelSettings(int _numChannel, char[][] channelSettingValues) {   //numChannel counts from zero
        JSONObject json = new JSONObject();
        json.setString(TCP_JSON_KEY_TYPE, TCP_TYPE_CHANNEL_SETTINGS);
        json.setString(TCP_JSON_KEY_ACTION, TCP_ACTION_SET);
        json.setInt(TCP_JSON_KEY_CHANNEL_NUMBER, _numChannel);
        json.setBoolean(TCP_JSON_KEY_CHANNEL_SET_POWER_DOWN, channelSettingValues[_numChannel][0] == '1');
        json.setInt(TCP_JSON_KEY_CHANNEL_SET_GAIN, getGainForCommand(channelSettingValues[_numChannel][1]));
        json.setString(TCP_JSON_KEY_CHANNEL_SET_INPUT_TYPE, getInputTypeForCommand(channelSettingValues[_numChannel][2]));
        json.setBoolean(TCP_JSON_KEY_CHANNEL_SET_BIAS, channelSettingValues[_numChannel][3] == '1');
        json.setBoolean(TCP_JSON_KEY_CHANNEL_SET_SRB2, channelSettingValues[_numChannel][4] == '1');
        json.setBoolean(TCP_JSON_KEY_CHANNEL_SET_SRB1, channelSettingValues[_numChannel][5] == '1');
        hub.writeJSON(json);
        verbosePrint("done writing channel." + json); //debugging
    }

    public void writeImpedanceSettings(int _numChannel, char[][] impedanceCheckValues) {  //numChannel counts from zero
        JSONObject json = new JSONObject();
        json.setString(TCP_JSON_KEY_TYPE, TCP_TYPE_IMPEDANCE);
        json.setString(TCP_JSON_KEY_ACTION, TCP_ACTION_SET);
        json.setInt(TCP_JSON_KEY_CHANNEL_NUMBER, _numChannel);
        json.setBoolean(TCP_JSON_KEY_IMPEDANCE_SET_P_INPUT, impedanceCheckValues[_numChannel-1][0] == '1');
        json.setBoolean(TCP_JSON_KEY_IMPEDANCE_SET_N_INPUT, impedanceCheckValues[_numChannel-1][1] == '1');
        hub.writeJSON(json);
    }

    public int copyDataPacketTo(DataPacket_ADS1299 target) {
        return dataPacket.copyTo(target);
    }
};
///////////////////////////////////////////////////////////////////////////////
//
// This class configures and manages the connection to the OpenBCI Ganglion.
// The connection is implemented via a TCP connection to a TCP port.
// The Gagnlion is configured using single letter text commands sent from the
// PC to the TCP server.  The EEG data streams back from the Ganglion, to the
// TCP server and back to the PC continuously (once started).
//
// Created: AJ Keller, August 2016
//
/////////////////////////////////////////////////////////////////////////////


//------------------------------------------------------------------------
//                       Global Functions
//------------------------------------------------------------------------

class Ganglion {
    final static char GANGLION_BOOTLOADER_MODE = '>';

    final static int NUM_ACCEL_DIMS = 3;

    private int nEEGValuesPerPacket = NCHAN_GANGLION; // Defined by the data format sent by cyton boards
    private int nAuxValuesPerPacket = NUM_ACCEL_DIMS; // Defined by the arduino code

    private final float fsHzBLE = 200.0f;  //sample rate used by OpenBCI Ganglion board... set by its Arduino code
    private final float fsHzWifi = 1600.0f;  //sample rate used by OpenBCI Ganglion board on wifi, set by hub

    private final float MCP3912_Vref = 1.2f;  // reference voltage for ADC in MCP3912 set in hardware
    private final float MCP3912_gain = 1.0f;  //assumed gain setting for MCP3912.  NEEDS TO BE ADJUSTABLE JM
    private float scale_fac_uVolts_per_count = (MCP3912_Vref * 1000000.f) / (8388607.0f * MCP3912_gain * 1.5f * 51.0f); //MCP3912 datasheet page 34. Gain of InAmp = 80
    private float scale_fac_accel_G_per_count_ble = 0.016f;
    private float scale_fac_accel_G_per_count_wifi = 0.001f;

    private int curInterface = INTERFACE_NONE;

    private DataPacket_ADS1299 dataPacket;

    private boolean checkingImpedance = false;
    private boolean accelModeActive = false;

    public int[] impedanceArray = new int[NCHAN_GANGLION + 1];

    private int sampleRate = (int)fsHzWifi;

    // Getters
    public float getSampleRate() {
        if (isBLE()) {
            return fsHzBLE;
        } else {
            return hub.getSampleRate();
        }
    }

    public float get_scale_fac_uVolts_per_count() {
        return scale_fac_uVolts_per_count;
    }

    public float get_scale_fac_accel_G_per_count() {
        if (isWifi()) {
            return scale_fac_accel_G_per_count_wifi;
        } else {
            return scale_fac_accel_G_per_count_ble;
        }
    }
    public boolean isCheckingImpedance() { return checkingImpedance; }
    public boolean isAccelModeActive() {
        return isWifi() ? true : accelModeActive; //Accel is always on for Ganglion+Wifi
    }
    public void overrideCheckingImpedance(boolean val) { checkingImpedance = val; }
    public int getInterface() {
        return curInterface;
    }
    public boolean isBLE () {
        return curInterface == INTERFACE_HUB_BLE || curInterface == INTERFACE_HUB_BLED112;
    }

    public boolean isWifi () {
        return curInterface == INTERFACE_HUB_WIFI;
    }

    public boolean isPortOpen() {
        return hub.isPortOpen();
    }

    private PApplet mainApplet;

    //constructors
    Ganglion() {};  //only use this if you simply want access to some of the constants
    Ganglion(PApplet applet) {
        mainApplet = applet;

        initDataPackets(nEEGValuesPerPacket, nAuxValuesPerPacket);
    }

    public void initDataPackets(int _nEEGValuesPerPacket, int _nAuxValuesPerPacket) {
        nEEGValuesPerPacket = _nEEGValuesPerPacket;
        nAuxValuesPerPacket = _nAuxValuesPerPacket;
        // For storing data into
        dataPacket = new DataPacket_ADS1299(nEEGValuesPerPacket, nAuxValuesPerPacket);  //this should always be 8 channels
        for(int i = 0; i < nEEGValuesPerPacket; i++) {
            dataPacket.values[i] = 0;
        }
        for(int i = 0; i < nAuxValuesPerPacket; i++){
            dataPacket.auxValues[i] = 0;
        }
    }

    public void processImpedance(JSONObject json) {
        int code = json.getInt(TCP_JSON_KEY_CODE);
        if (code == RESP_SUCCESS_DATA_IMPEDANCE) {
            int channel = json.getInt(TCP_JSON_KEY_CHANNEL_NUMBER);
            if (channel < 5) {
                int value = json.getInt(TCP_JSON_KEY_IMPEDANCE_VALUE);
                impedanceArray[channel] = value;
            }
        }
    }

    public void setSampleRate(int _sampleRate) {
        sampleRate = _sampleRate;
        hub.setSampleRate(sampleRate);
        println("Setting sample rate for Ganglion to " + sampleRate + "Hz");
    }

    public void setInterface(int _interface) {
        curInterface = _interface;
        if (isBLE()) {
            setSampleRate((int)fsHzBLE);
            if (_interface == INTERFACE_HUB_BLE) {
                hub.setProtocol(PROTOCOL_BLE);
            } else {
                hub.setProtocol(PROTOCOL_BLED112);
            }
            // hub.searchDeviceStart();
        } else if (isWifi()) {
            setSampleRate((int)fsHzWifi);
            hub.setProtocol(PROTOCOL_WIFI);
            hub.searchDeviceStart();
        }
    }

    // SCANNING/SEARCHING FOR DEVICES
    public int closePort() {
        if (isBLE()) {
            hub.disconnectBLE();
        } else if (isWifi()) {
            hub.disconnectWifi();
        }
        return 0;
    }

    /**
      * @description Sends a start streaming command to the Ganglion Node module.
      */
    public void startDataTransfer(){
        hub.changeState(HubState.NORMAL);  // make sure it's now interpretting as binary
        println("Ganglion: startDataTransfer(): sending \'" + command_startBinary);
        if (checkingImpedance) {
            impedanceStop();
            delay(100);
            hub.sendCommand('b');
        } else {
            hub.sendCommand('b');
        }
    }

    /**
      * @description Sends a stop streaming command to the Ganglion Node module.
      */
    public void stopDataTransfer() {
        hub.changeState(HubState.STOPPED);  // make sure it's now interpretting as binary
        println("Ganglion: stopDataTransfer(): sending \'" + command_stop);
        hub.sendCommand('s');
    }

    // Channel setting
    //activate or deactivate an EEG channel...channel counting is zero through nchan-1
    public void changeChannelState(int Ichan, boolean activate) {
        if (isPortOpen()) {
            if ((Ichan >= 0)) {
                if (activate) {
                    println("Ganglion: changeChannelState(): activate: sending " + command_activate_channel[Ichan]);
                    hub.sendCommand(command_activate_channel[Ichan]);
                    w_timeSeries.hsc.powerUpChannel(Ichan);
                } else {
                    println("Ganglion: changeChannelState(): deactivate: sending " + command_deactivate_channel[Ichan]);
                    hub.sendCommand(command_deactivate_channel[Ichan]);
                    w_timeSeries.hsc.powerDownChannel(Ichan);
                }
            }
        }
    }

    /**
      * Used to start accel data mode. Accel arrays will arrive asynchronously!
      */
    public void accelStart() {
        JSONObject json = new JSONObject();
        json.setString(TCP_JSON_KEY_ACTION, TCP_ACTION_START);
        json.setString(TCP_JSON_KEY_TYPE, TCP_TYPE_ACCEL);
        hub.writeJSON(json);
        println("Ganglion: accel: START");
        accelModeActive = true;
    }

    /**
      * Used to stop accel data mode. Some accel arrays may arrive after stop command
      *  was sent by this function.
      */
    public void accelStop() {
        println("Ganglion: accel: STOP");
        JSONObject json = new JSONObject();
        json.setString(TCP_JSON_KEY_ACTION, TCP_ACTION_STOP);
        json.setString(TCP_JSON_KEY_TYPE, TCP_TYPE_ACCEL);
        hub.writeJSON(json);
        accelModeActive = false;
    }

    /**
      * Used to start impedance testing. Impedances will arrive asynchronously!
      */
    public void impedanceStart() {
        println("Ganglion: impedance: START");
        JSONObject json = new JSONObject();
        json.setString(TCP_JSON_KEY_ACTION, TCP_ACTION_START);
        json.setString(TCP_JSON_KEY_TYPE, TCP_TYPE_IMPEDANCE);
        hub.writeJSON(json);
        checkingImpedance = true;
    }

    /**
      * Used to stop impedance testing. Some impedances may arrive after stop command
      *  was sent by this function.
      */
    public void impedanceStop() {
        println("Ganglion: impedance: STOP");
        JSONObject json = new JSONObject();
        json.setString(TCP_JSON_KEY_ACTION, TCP_ACTION_STOP);
        json.setString(TCP_JSON_KEY_TYPE, TCP_TYPE_IMPEDANCE);
        hub.writeJSON(json);
        checkingImpedance = false;
    }

    /**
      * Puts the ganglion in bootloader mode.
      */
    public void enterBootloaderMode() {
        println("Ganglion: Entering Bootloader Mode");
        hub.sendCommand(GANGLION_BOOTLOADER_MODE);
        delay(500);
        closePort();
        haltSystem();
        initSystemButton.setString("START SESSION");
        controlPanel.open();
        output("Ganglion now in bootloader mode! Enjoy!");
    }
};
////////////////////////////////////////////////////////////
//                 ConsoleLog.pde                         //
//  This is an example of how to print console messages:  //
//      -- to console                                     //
//      -- to a file                                      //
//      -- to the screen with scrolling                   //
//                                                        //
////////////////////////////////////////////////////////////








static class ConsoleWindow extends PApplet {
    private static ConsoleWindow instance = null;

    PApplet logApplet;

    private ControlP5 cp5;
    private Textarea consoleTextArea;
    private ClipHelper clipboardCopy;

    private final int headerHeight = 42;
    private final int defaultWidth = 620;
    private final int defaultHeight = 500;
    private final int buttonWidth = 142;
    private final int buttonHeight = 34;

    //for screen resizing
    private boolean screenHasBeenResized = false;
    private float timeOfLastScreenResize = 0;
    private int widthOfLastScreen = defaultWidth;
    private int heightOfLastScreen = defaultHeight;

    public static void display() {
        // enforce only one Console Window
        if (instance == null) {
            instance = new ConsoleWindow();
            PApplet.runSketch(new String[] {instance.getClass().getSimpleName()}, instance);
        }
    }

    private ConsoleWindow() {
        super();
    }

    public void settings() {
        size(defaultWidth, defaultHeight);
    }

    public void setup() {

        logApplet = this;

        surface.setAlwaysOnTop(true);
        surface.setResizable(true);

        clipboardCopy = new ClipHelper();
        cp5 = new ControlP5(this);

        consoleTextArea = cp5.addTextarea("ConsoleWindow")
            .setPosition(0, headerHeight)
            .setSize(width, height - headerHeight)
            .setFont(createFont("arial", 14))
            .setLineHeight(18)
            .setColor(color(242))
            .setColorBackground(color(42, 100))
            .setColorForeground(color(42, 100))
            .setScrollBackground(color(70, 100))
            .setScrollForeground(color(144, 100))
        ;

        // register this console's Textarea with the output stream object
        outputStream.registerTextArea(consoleTextArea);

        int cW = PApplet.parseInt(width/4);
        int bX = PApplet.parseInt((cW - buttonWidth) / 2);
        createConsoleLogButton("openLogFileAsText", "Open Log as Text (F)", bX);
        bX += cW;
        createConsoleLogButton("copyFullTextToClipboard", "Copy Full Text (C)", bX);
        bX += cW;
        createConsoleLogButton("copyLastLineToClipboard", "Copy Last Line (L)", bX);
        bX += cW;
        createConsoleLogButton("jumpToLastLine", "Jump to Last Line (J)", bX);
    }

    public void createConsoleLogButton (String bName, String bText, int x) {
        int y = 4;  // vertical position for button
        cp5.addButton(bName)
                .setPosition(x, y)
                .setSize(buttonWidth, buttonHeight)
                .setColorLabel(color(255))
                .setColorForeground(color(31, 69, 110))
                .setColorBackground(color(144, 100));
        cp5.getController(bName)
                .getCaptionLabel()
                .setFont(createFont("Arial",14,true))
                .toUpperCase(false)
                .setSize(14)
                .setText(bText);
    }

    public void draw() {
        clear();
        scene();
        cp5.draw();
        //checks if the screen is resized, similar to main GUI window
        screenResized();
    }

    public void screenResized() {
        if (this.widthOfLastScreen != width || this.heightOfLastScreen != height) {
            //println("ConsoleLog: RESIZED");
            this.screenHasBeenResized = true;
            this.timeOfLastScreenResize = millis();
            this.widthOfLastScreen = width;
            this.heightOfLastScreen = height;
        }
        if (this.screenHasBeenResized) {
            //setGraphics() is very important, it lets the cp5 elements know where the origin is.
            //Without this, cp5 elements won't work after screen is resized.
            //This also happens in most widgets when the main GUI window is resized.
            logApplet = this;
            cp5.setGraphics(logApplet, 0, 0);

            imposeMinConsoleLogDimensions();
            // dynamically resize text area to fit widget
            consoleTextArea.setSize(width, height - headerHeight);
            // update button positions when screen width changes
            updateButtonPositions();
        }
        //re-initialize console log if screen has been resized and it's been more than 1 seccond (to prevent reinitialization happening too often)
        if (this.screenHasBeenResized == true && (millis() - this.timeOfLastScreenResize) > 1000) {
            this.screenHasBeenResized = false;
        }
    }

    public void scene() {
        background(42);
        fill(42);
        rect(0, 0, width, headerHeight);
    }

    public void keyReleased() {
        if (key == 'c') {
            copyFullTextToClipboard();
        } else if (key == 'f') {
            openLogFileAsText();
        } else if (key == 'l') {
            copyLastLineToClipboard();
        } else if (key == 'j' ) {
            jumpToLastLine();
        }
        
    }

    public void keyPressed() {
        if (key == CODED) {
            if (keyCode == UP) {
                consoleTextArea.scrolled(-5);
            } else if (keyCode == DOWN) {
                consoleTextArea.scrolled(5);
            }
        }
    }

    public void mousePressed() {

    }

    public void mouseReleased() {

    }

    public void openLogFileAsText() {
        try {
            println("ConsoleLog: Opening console log as text file!");
            File file = new File (outputStream.getFilePath());
            Desktop desktop = Desktop.getDesktop();
            if (file.exists()) {
                desktop.open(file);
            } else {
                println("ConsoleLog: ERROR - Unable to open console log as text file...");
            }
        } catch (IOException e) {}
    }

    public void copyFullTextToClipboard() {
        println("ConsoleLog: Copying console log to clipboard!");
        String stringToCopy = outputStream.getFullLog();
        String formattedCodeBlock = "```\n" + stringToCopy + "\n```";
        clipboardCopy.copyString(formattedCodeBlock);
    }

    public void copyLastLineToClipboard() {
        clipboardCopy.copyString(outputStream.getLastLine());
        println("ConsoleLog: Previous line copied to clipboard.");
    }

    public void jumpToLastLine() {
        consoleTextArea.scroll(1.0f);
    }

    public void updateButtonPositions() {
        int cW = width / 4;
        int bX = (cW - buttonWidth) / 2;
        int bY = 4;
        cp5.getController("openLogFileAsText").setPosition(bX, bY);
        bX += cW;
        cp5.getController("copyFullTextToClipboard").setPosition(bX, bY);
        bX += cW;
        cp5.getController("copyLastLineToClipboard").setPosition(bX, bY);
        bX += cW;
        cp5.getController("jumpToLastLine").setPosition(bX, bY);
    }

    public void imposeMinConsoleLogDimensions() {
        //impose minimum gui dimensions
        int minHeight = PApplet.parseInt(defaultHeight/2);
        if (width < defaultWidth || height < minHeight) {
            int _w = (width < defaultWidth) ? defaultWidth : width;
            int _h = (height < minHeight) ? minHeight : height;
            surface.setSize(_w, _h);
        }
    }

    public void exit() {
        println("ConsoleLog: Console closed!");
        instance = null;
        dispose();
    }

    // ===============================================================
    // CLIPHELPER OBJECT CLASS
    class ClipHelper {
        Clipboard clipboard;

        ClipHelper() {
            getClipboard();
        }

        public void getClipboard () {
            // this is our simple thread that grabs the clipboard
            Thread clipThread = new Thread() {
                public void run() {
                    clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
                }
            };

            // start the thread as a daemon thread and wait for it to die
            if (clipboard == null) {
                try {
                    clipThread.setDaemon(true);
                    clipThread.start();
                    clipThread.join();
                }
                catch (Exception e) {}
            }
        }

        public void copyString (String data) {
            copyTransferableObject(new StringSelection(data));
        }

        public void copyTransferableObject (Transferable contents) {
            getClipboard();
            clipboard.setContents(contents, null);
        }

        public String pasteString () {
            String data = null;
            try {
                data = (String)pasteObject(DataFlavor.stringFlavor);
            }
            catch (Exception e) {
                println("ConsoleLog: Error getting String from clipboard: " + e);
            }
            return data;
        }

        public Object pasteObject (DataFlavor flavor)
        throws UnsupportedFlavorException, IOException
        {
            Object obj = null;
            getClipboard();

            Transferable content = clipboard.getContents(null);
            if (content != null)
            obj = content.getTransferData(flavor);

            return obj;
        }
    }//end class
}//end class

// --------------------------------------------------------------

class CustomOutputStream extends PrintStream {

    private StringList data;
    private PrintWriter fileOutput;
    private Textarea textArea;
    private final String filePath = settings.consoleDataPath+"Console_"+getDateString()+".txt";

    public CustomOutputStream(OutputStream out) {
        super(out);
        data = new StringList();
        // initialize the printwriter just in case the file open fails
        fileOutput = new PrintWriter(out);

        // create log file
        try {
            fileOutput = createWriter(filePath);
        }
        catch (RuntimeException e) {
            println("Error! Failed to open " + filePath + " for write.");
            println(e);
        }
    }

    public void println(String string) {
        string += "\n";
        super.print(string);  // don't call super.println() here, you'll get double prints

        // add to array
        data.append(string);

        // print to file
        fileOutput.print(string);
        fileOutput.flush();

        // add to text area, if registered
        if (textArea != null) {
            textArea.append(string);
        }
    }

    public void print(String string) {
        super.print(string);
        string += "\n"; // TODO: shouldn't have to do this, but exceptions were printing on one line. investigate?

        // add to array
        data.append(string);

        // print to file
        fileOutput.print(string);
        fileOutput.flush();

        // add to text area, if registered
        if (textArea != null) {
            textArea.append(string);
        }
    }

    public void registerTextArea(Textarea area) {
        textArea = area;
        textArea.setText(getFullLog());
    }

    public String getFilePath() {
        return filePath;
    }

    public String getLastLine() {
        return data.get(data.size()-1);
    }

    public String getFullLog() {
        return join(data.array(), "");
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//   This code is used for GUI-wide spacing. It defines the GUI layout as a grid
//   with the following design:
//
//   The #s shown below fall at the center of their corresponding container[].
//   Ex: container[1] is the upper left corner of the large rectangle between [0] & [10]
//   Ex 2: container[6] is the entire right half of the same rectangle.
//
//   ------------------------------------------------
//   |                      [0]                     |
//   ------------------------------------------------
//   |                       |         [11]         |
//   |         [1]          [2]---[15]--[3]---[16]--|
//   |                       |         [12]         |
//   |---------[4]----------[5]---------[6]---------|
//   |                       |         [13]         |
//   |         [7]          [8]---[17]--[9]---[18]--|
//   |                       |         [14]         |
//   ------------------------------------------------
//   |                      [10]                    |
//   ------------------------------------------------
//
//   Created by: Conor Russomanno (May 2016)
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

boolean drawContainers = false;
Container[] container = new Container[19];

//Viz extends container (example below)
//Viz viz1;
//Viz viz2;

int widthOfLastScreen_C = 0;
int heightOfLastScreen_C = 0;

int topNav_h = 64; //tie this to a global variable or one attached to GUI_Manager
int bottomNav_h = 28; //same

public void setupContainers() {

    widthOfLastScreen_C = width;
    heightOfLastScreen_C = height;

    container[0] = new Container(0, 0, width, topNav_h, 0);
    container[5] = new Container(0, topNav_h, width, height - (topNav_h + bottomNav_h), 1);
    container[1] = new Container(container[5], "TOP_LEFT");
    container[2] = new Container(container[5], "TOP");
    container[3] = new Container(container[5], "TOP_RIGHT");
    container[4] = new Container(container[5], "LEFT");
    container[6] = new Container(container[5], "RIGHT");
    container[7] = new Container(container[5], "BOTTOM_LEFT");
    container[8] = new Container(container[5], "BOTTOM");
    container[9] = new Container(container[5], "BOTTOM_RIGHT");
    container[10] = new Container(0, height - bottomNav_h, width, 50, 0);
    container[11] = new Container(container[3], "TOP");
    container[12] = new Container(container[3], "BOTTOM");
    container[13] = new Container(container[9], "TOP");
    container[14] = new Container(container[9], "BOTTOM");
    container[15] = new Container(container[6], "TOP_LEFT");
    container[16] = new Container(container[6], "TOP_RIGHT");
    container[17] = new Container(container[6], "BOTTOM_LEFT");
    container[18] = new Container(container[6], "BOTTOM_RIGHT");

    //setup viz objects... example of container extension (more below)
    //setupVizs();
}

public void drawContainers() {
    for(int i = 0; i < container.length; i++){
        container[i].draw();
    }

    //Draw viz objects.. example extension of container class (more below)
    //viz1.draw();
    //viz2.draw();

    //alternative component listener function (line 177 - 187 frame.addComponentListener) for processing 3,
    if (widthOfLastScreen_C != width || heightOfLastScreen_C != height) {
        println("OpenBCI_GUI: setup: RESIZED");
        setupContainers();
        //setupVizs(); //container extension example (more below)
        settings.widthOfLastScreen = width;
        settings.heightOfLastScreen = height;
    }
}

public class Container {

    //key Container Variables
    public float x0, y0, w0, h0; //true dimensions.. without margins
    public float x, y, w, h; //dimensions with margins
    public float margin; //margin

    //constructor 1 -- comprehensive
    public Container(float _x0, float _y0, float _w0, float _h0, float _margin) {

        margin = _margin;

        x0 = _x0;
        y0 = _y0;
        w0 = _w0;
        h0 = _h0;

        x = x0 + margin;
        y = y0 + margin;
        w = w0 - margin*2;
        h = h0 - margin*2;
    }

    //constructor 2 -- recursive constructor -- for quickly building sub-containers based on a super container (aka master)
    public Container(Container master, String _type) {

        margin = master.margin;

        if(_type == "WHOLE"){
            x0 = master.x0;
            y0 = master.y0;
            w0 = master.w0;
            h0 = master.h0;
            w = master.w;
            h = master.h;
            x = master.x;
            y = master.y;
        } else if (_type == "LEFT") {
            x0 = master.x0;
            y0 = master.y0;
            w0 = master.w0/2;
            h0 = master.h0;
            w = (master.w - margin)/2;
            h = master.h;
            x = master.x;
            y = master.y;
        } else if (_type == "RIGHT") {
            x0 = master.x0 + master.w0/2;
            y0 = master.y0;
            w0 = master.w0/2;
            h0 = master.h0;
            w = (master.w - margin)/2;
            h = master.h;
            x = master.x + w + margin;
            y = master.y;
        } else if (_type == "TOP") {
            x0 = master.x0;
            y0 = master.y0;
            w0 = master.w0;
            h0 = master.h0/2;
            w = master.w;
            h = (master.h - margin)/2;
            x = master.x;
            y = master.y;
        } else if (_type == "BOTTOM") {
            x0 = master.x0;
            y0 = master.y0 + master.h0/2;
            w0 = master.w0;
            h0 = master.h0/2;
            w = master.w;
            h = (master.h - margin)/2;
            x = master.x;
            y = master.y + h + margin;
        } else if (_type == "TOP_LEFT") {
            x0 = master.x0;
            y0 = master.y0;
            w0 = master.w0/2;
            h0 = master.h0/2;
            w = (master.w - margin)/2;
            h = (master.h - margin)/2;
            x = master.x;
            y = master.y;
        } else if (_type == "TOP_RIGHT") {
            x0 = master.x0 + master.w0/2;
            y0 = master.y0;
            w0 = master.w0/2;
            h0 = master.h0/2;
            w = (master.w - margin)/2;
            h = (master.h - margin)/2;
            x = master.x + w + margin;
            y = master.y;
        } else if (_type == "BOTTOM_LEFT") {
            x0 = master.x0;
            y0 = master.y0 + master.h0/2;
            w0 = master.w0/2;
            h0 = master.h0/2;
            w = (master.w - margin)/2;
            h = (master.h - margin)/2;
            x = master.x;
            y = master.y + h + margin;
        } else if (_type == "BOTTOM_RIGHT") {
            x0 = master.x0 + master.w0/2;
            y0 = master.y0 + master.h0/2;
            w0 = master.w0/2;
            h0 = master.h0/2;
            w = (master.w - margin)/2;
            h = (master.h - margin)/2;
            x = master.x + w + margin;
            y = master.y + h + margin;
        }
    }

    public void draw() {
        if(drawContainers){
            pushStyle();

            //draw margin area
            fill(102, 255, 71, 100);
            noStroke();
            rect(x0, y0, w0, h0);

            //noFill();
            //stroke(255, 0, 0);
            //rect(x0, y0, w0, h0);

            fill(31, 69, 110, 100);
            noStroke();
            rect(x, y, w, h);

            popStyle();
        }
    }
};

// --- EXAMPLE OF EXTENDING THE CONTAINER --- //

//public class Viz extends Container {
//  public float abc;

//  public Viz(float _abc, Container master) {
//    super(master, "WHOLE");
//    abc = _abc;
//  }

//  void draw() {
//    pushStyle();
//    noStroke();
//    fill(255, 0, 0, 50);
//    rect(x, y, w, h);
//    popStyle();
//  }
//};

//void setupVizs() {
//  viz1 = new Viz (10f, container2);
//  viz2 = new Viz (10f, container4);
//}

// --- END OF EXAMPLE OF EXTENDING THE CONTAINER --- //
//////////////////////////////////////////////////////////////////////////
//
//    System Control Panel
//    - Select serial port from dropdown
//        - Select default configuration (EEG, EKG, EMG)
//        - Select Electrode Count (8 vs 16)
//        - Select data mode (synthetic, playback file, real-time)
//        - Record data? (y/n)
//            - select output location
//        - link to help guide
//        - buttons to start/stop/reset application
//
//        Written by: Conor Russomanno (Oct. 2014)
//
//////////////////////////////////////////////////////////////////////////



//------------------------------------------------------------------------
//                       Global Variables  & Instances
//------------------------------------------------------------------------

ControlPanel controlPanel;

ControlP5 cp5; //program-wide instance of ControlP5
ControlP5 cp5Popup;
CallbackListener cb = new CallbackListener() { //used by ControlP5 to clear text field on double-click
    public void controlEvent(CallbackEvent theEvent) {

        if (cp5.isMouseOver(cp5.get(Textfield.class, "fileNameCyton"))){
            println("CallbackListener: controlEvent: clearing cyton");
            cp5.get(Textfield.class, "fileNameCyton").clear();
            // cp5.get(Textfield.class, "fileNameGanglion").clear();

        } else if (cp5.isMouseOver(cp5.get(Textfield.class, "fileNameGanglion"))){
            println("CallbackListener: controlEvent: clearing ganglion");
            cp5.get(Textfield.class, "fileNameGanglion").clear();

        } else if (cp5.isMouseOver(cp5.get(Textfield.class, "staticIPAddress"))){
            println("CallbackListener: controlEvent: clearing static IP Address");
            cp5.get(Textfield.class, "staticIPAddress").clear();
        }
    }
};

MenuList sourceList;

//Global buttons and elements for the control panel (changed within the classes below)
MenuList serialList;
String[] serialPorts = new String[Serial.list().length];

MenuList bleList;
MenuList wifiList;

MenuList sdTimes;

MenuList channelList;

MenuList pollList;

int boxColor = color(200);
int boxStrokeColor = color(bgColor);
int isSelected_color = color(184, 220, 105);
int colorNotPressed = color(255);

Button noHubShowDoc;

Button refreshPort;
Button refreshBLE;
Button refreshWifi;
Button protocolSerialCyton;
Button protocolWifiCyton;
Button protocolWifiGanglion;
Button protocolBLED112Ganglion;
Button protocolBLEGanglion;

Button initSystemButton;
Button autoSessionName; // Reuse these buttons for Cyton and Ganglion
Button outputBDF;
Button outputODF;

Button sampleDataButton; // Used to easily find GUI sample data for Playback mode #645

Button chanButton8;
Button chanButton16;
Button selectPlaybackFile;
Button selectSDFile;
Button popOutRadioConfigButton;
Button popOutWifiConfigButton;

//Radio Button Definitions
Button getChannel;
Button setChannel;
Button ovrChannel;
Button autoscan;
Button systemStatus;

Button eraseCredentials;
Button getIpAddress;
Button getFirmwareVersion;
Button getMacAddress;
Button getTypeOfAttachedBoard;
Button sampleRate200; //Ganglion
Button sampleRate250;
Button sampleRate500;
Button sampleRate1000;
Button sampleRate1600; //Ganglion
Button latencyCyton5ms;
Button latencyCyton10ms;
Button latencyCyton20ms;
Button latencyGanglion5ms;
Button latencyGanglion10ms;
Button latencyGanglion20ms;
Button wifiInternetProtocolCytonTCP;
Button wifiInternetProtocolCytonUDP;
Button wifiInternetProtocolCytonUDPBurst;
Button wifiInternetProtocolGanglionTCP;
Button wifiInternetProtocolGanglionUDP;
Button wifiInternetProtocolGanglionUDPBurst;
Button wifiIPAddressDynamic;
Button wifiIPAddressStatic;

Button synthChanButton4;
Button synthChanButton8;
Button synthChanButton16;

Serial board;

ChannelPopup channelPopup;
PollPopup pollPopup;
RadioConfigBox rcBox;

WifiConfigBox wcBox;

//------------------------------------------------------------------------
//                       Global Functions
//------------------------------------------------------------------------

public void controlEvent(ControlEvent theEvent) {

    if (theEvent.isFrom("sourceList")) {
        // THIS IS TRIGGERED WHEN A USER SELECTS 'LIVE (from Cyton) or LIVE (from Ganglion), etc...'
        controlPanel.hideAllBoxes();

        Map bob = ((MenuList)theEvent.getController()).getItem(PApplet.parseInt(theEvent.getValue()));
        String str = (String)bob.get("headline");
        settings.controlEventDataSource = str; //Used for output message on system start
        int newDataSource = PApplet.parseInt(theEvent.getValue());

        eegDataSource = newDataSource; // reset global eegDataSource to the selected value from the list

        if (newDataSource != DATASOURCE_SYNTHETIC && newDataSource != DATASOURCE_PLAYBACKFILE && !hub.isHubRunning()) {
            outputError("Unable to establish link to Hub. LIVE functionality will be disabled.");
            println("ControlEvent: Hub error");
            return;
        }

        // this button only used on mac
        if(isMac()) {
            protocolBLEGanglion.setColorNotPressed(colorNotPressed);
        }
        protocolWifiGanglion.setColorNotPressed(colorNotPressed);
        protocolBLED112Ganglion.setColorNotPressed(colorNotPressed);
        protocolWifiCyton.setColorNotPressed(colorNotPressed);
        protocolSerialCyton.setColorNotPressed(colorNotPressed);

        ganglion.setInterface(INTERFACE_NONE);
        cyton.setInterface(INTERFACE_NONE);

        if(newDataSource == DATASOURCE_CYTON){
            updateToNChan(8);
            chanButton8.setColorNotPressed(isSelected_color);
            chanButton16.setColorNotPressed(colorNotPressed); //default color of button
            latencyCyton5ms.setColorNotPressed(colorNotPressed);
            latencyCyton10ms.setColorNotPressed(isSelected_color);
            latencyCyton20ms.setColorNotPressed(colorNotPressed);
            hub.setLatency(LATENCY_10_MS);
            wifiInternetProtocolCytonTCP.setColorNotPressed(colorNotPressed);
            wifiInternetProtocolCytonUDP.setColorNotPressed(colorNotPressed);
            wifiInternetProtocolCytonUDPBurst.setColorNotPressed(isSelected_color);
            hub.setWifiInternetProtocol(UDP_BURST);
            hub.setWiFiStyle(WIFI_DYNAMIC);
            wifiIPAddressDynamic.setColorNotPressed(isSelected_color);
            wifiIPAddressStatic.setColorNotPressed(colorNotPressed);
        } else if(newDataSource == DATASOURCE_GANGLION){
            updateToNChan(4);
            latencyGanglion5ms.setColorNotPressed(colorNotPressed);
            latencyGanglion10ms.setColorNotPressed(isSelected_color);
            latencyGanglion20ms.setColorNotPressed(colorNotPressed);
            hub.setLatency(LATENCY_10_MS);
            wifiInternetProtocolGanglionTCP.setColorNotPressed(isSelected_color);
            wifiInternetProtocolGanglionUDP.setColorNotPressed(colorNotPressed);
            wifiInternetProtocolGanglionUDPBurst.setColorNotPressed(colorNotPressed);
            hub.setWifiInternetProtocol(TCP);
            hub.setWiFiStyle(WIFI_DYNAMIC);
            wifiIPAddressDynamic.setColorNotPressed(isSelected_color);
            wifiIPAddressStatic.setColorNotPressed(colorNotPressed);
        } else if(newDataSource == DATASOURCE_PLAYBACKFILE){
            //GUI auto detects number of channels for playback when file is selected
        } else if(newDataSource == DATASOURCE_SYNTHETIC){
            updateToNChan(8);
            synthChanButton4.setColorNotPressed(colorNotPressed);
            synthChanButton8.setColorNotPressed(isSelected_color);
            synthChanButton16.setColorNotPressed(colorNotPressed);
        }

        //output("The new data source is " + str + " and NCHAN = [" + nchan + "]. "); //This text has been added to Init 5 checkpoint messages in first tab
    }

    if (theEvent.isFrom("serialList")) {
        Map bob = ((MenuList)theEvent.getController()).getItem(PApplet.parseInt(theEvent.getValue()));
        openBCI_portName = (String)bob.get("headline");
        output("OpenBCI Port Name = " + openBCI_portName);
    }

    if (theEvent.isFrom("bleList")) {
        Map bob = ((MenuList)theEvent.getController()).getItem(PApplet.parseInt(theEvent.getValue()));
        ganglion_portName = (String)bob.get("headline");
        output("Ganglion Device Name = " + ganglion_portName);
    }

    if (theEvent.isFrom("wifiList")) {
        Map bob = ((MenuList)theEvent.getController()).getItem(PApplet.parseInt(theEvent.getValue()));
        wifi_portName = (String)bob.get("headline");
        output("Wifi Device Name = " + wifi_portName);
    }

    if (theEvent.isFrom("sdTimes")) {
        Map bob = ((MenuList)theEvent.getController()).getItem(PApplet.parseInt(theEvent.getValue()));
        sdSettingString = (String)bob.get("headline");
        sdSetting = PApplet.parseInt(theEvent.getValue());
        if (sdSetting != 0) {
            output("OpenBCI microSD Setting = " + sdSettingString + " recording time");
        } else {
            output("OpenBCI microSD Setting = " + sdSettingString);
        }
        verbosePrint("SD setting = " + sdSetting);
    }

    if (theEvent.isFrom("channelListCP")) {
        int setChannelInt = PApplet.parseInt(theEvent.getValue()) + 1;
        //Map bob = ((MenuList)theEvent.getController()).getItem(int(theEvent.getValue()));
        cp5Popup.get(MenuList.class, "channelListCP").setVisible(false);
        channelPopup.setClicked(false);
        if (setChannel.wasPressed) {
            set_channel(rcBox, setChannelInt);
            setChannel.wasPressed = false;
        } else if(ovrChannel.wasPressed) {
            set_channel_over(rcBox, setChannelInt);
            ovrChannel.wasPressed = false;
        }
    }

    //Check for event in PlaybackHistory Dropdown List in Control Panel
    if (theEvent.isFrom("recentFiles")) {
        int s = (int)(theEvent.getController()).getValue();
        //println("got a menu event from item " + s);
        String filePath = controlPanel.recentPlaybackBox.longFilePaths.get(s);
        if (new File(filePath).isFile()) {
            playbackFileSelected(filePath, s);
        } else {
            outputError("Playback History: Selected file does not exist. Try another file or clear settings to remove this entry.");
        }
    }

    //Check control events from widgets
    if (systemMode >= SYSTEMMODE_POSTINIT) {
        //Check for event in PlaybackHistory Widget MenuList
        if (eegDataSource == DATASOURCE_PLAYBACKFILE) {
            if(theEvent.isFrom("playbackMenuList")) {
                //Check to make sure value of clicked item is in valid range. Fixes #480
                float valueOfItem = theEvent.getValue();
                if (valueOfItem < 0 || valueOfItem > (((MenuList)theEvent.getController()).items.size() - 1) ) {
                    //println("CP: No such item " + value + " found in list.");
                } else {
                    Map m = ((MenuList)theEvent.getController()).getItem(PApplet.parseInt(valueOfItem));
                    //println("got a menu event from item " + value + " : " + m);
                    userSelectedPlaybackMenuList(m.get("copy").toString(), PApplet.parseInt(valueOfItem));
                }
            }
        }
        //Check for event in band power channel select checkBoxes, if needed
        /*
        if (theEvent.isFrom(w_bandPower.bpChanSelect.checkList)) {
            println(w_bandPower.bpChanSelect.checkList.getArrayValue());
        }
        */
    }
}

//------------------------------------------------------------------------
//                            Classes
//------------------------------------------------------------------------

class ControlPanel {

    public int x, y, w, h;
    public boolean isOpen;

    PlotFontInfo fontInfo;

    //various control panel elements that are unique to specific datasources
    DataSourceBox dataSourceBox;
    SerialBox serialBox;
    ComPortBox comPortBox;
    SessionDataBox dataLogBoxCyton;
    ChannelCountBox channelCountBox;
    InitBox initBox;
    SyntheticChannelCountBox synthChannelCountBox;
    RecentPlaybackBox recentPlaybackBox;
    PlaybackFileBox playbackFileBox;
    SDConverterBox sdConverterBox;
    NoHubBox noHubBox;
    BLEBox bleBox;
    SessionDataBox dataLogBoxGanglion;
    WifiBox wifiBox;
    InterfaceBoxCyton interfaceBoxCyton;
    InterfaceBoxGanglion interfaceBoxGanglion;
    SampleRateCytonBox sampleRateCytonBox;
    SampleRateGanglionBox sampleRateGanglionBox;
    LatencyCytonBox latencyCytonBox;
    LatencyGanglionBox latencyGanglionBox;
    WifiTransferProtcolCytonBox wifiTransferProtcolCytonBox;
    WifiTransferProtcolGanglionBox wifiTransferProtcolGanglionBox;
    SDBox sdBox;

    boolean drawStopInstructions;
    int globalPadding; //design feature: passed through to all box classes as the global spacing .. in pixels .. for all elements/subelements
    boolean convertingSD = false;
    String bdfMessage = "Output has been set to BioSemi Data Format (BDF+).";

    ControlPanel(OpenBCI_GUI mainClass) {

        x = 3;
        y = 3 + topNav.controlPanelCollapser.but_dy;
        w = topNav.controlPanelCollapser.but_dx;
        h = height - PApplet.parseInt(helpWidget.h);

        isOpen = false;
        fontInfo = new PlotFontInfo();

        globalPadding = 10;  //controls the padding of all elements on the control panel

        cp5 = new ControlP5(mainClass);
        cp5Popup = new ControlP5(mainClass);
        cp5.setAutoDraw(false);
        cp5Popup.setAutoDraw(false);

        //boxes active when eegDataSource = Normal (OpenBCI)
        dataSourceBox = new DataSourceBox(x, y, w, h, globalPadding);
        interfaceBoxCyton = new InterfaceBoxCyton(x + w, dataSourceBox.y, w, h, globalPadding);
        interfaceBoxGanglion = new InterfaceBoxGanglion(x + w, dataSourceBox.y, w, h, globalPadding);

        noHubBox = new NoHubBox(x + w, dataSourceBox.y, w, h, globalPadding);
        serialBox = new SerialBox(x + w, interfaceBoxCyton.y + interfaceBoxCyton.h, w, h, globalPadding);
        wifiBox = new WifiBox(x + w, interfaceBoxCyton.y + interfaceBoxCyton.h, w, h, globalPadding);

        dataLogBoxCyton = new SessionDataBox(x + w, (serialBox.y + serialBox.h), w, h, globalPadding, DATASOURCE_CYTON);
        channelCountBox = new ChannelCountBox(x + w, (dataLogBoxCyton.y + dataLogBoxCyton.h), w, h, globalPadding);
        synthChannelCountBox = new SyntheticChannelCountBox(x + w, dataSourceBox.y, w, h, globalPadding);
        sdBox = new SDBox(x + w, (channelCountBox.y + channelCountBox.h), w, h, globalPadding);
        sampleRateCytonBox = new SampleRateCytonBox(x + w + x + w - 3, channelCountBox.y, w, h, globalPadding);
        latencyCytonBox = new LatencyCytonBox(x + w + x + w - 3, (sampleRateCytonBox.y + sampleRateCytonBox.h), w, h, globalPadding);
        wifiTransferProtcolCytonBox = new WifiTransferProtcolCytonBox(x + w + x + w - 3, (latencyCytonBox.y + latencyCytonBox.h), w, h, globalPadding);

        //boxes active when eegDataSource = Playback
        int playbackWidth = PApplet.parseInt(w * 1.35f);
        playbackFileBox = new PlaybackFileBox(x + w, dataSourceBox.y, playbackWidth, h, globalPadding);
        sdConverterBox = new SDConverterBox(x + w, (playbackFileBox.y + playbackFileBox.h), playbackWidth, h, globalPadding);
        recentPlaybackBox = new RecentPlaybackBox(x + w, (sdConverterBox.y + sdConverterBox.h), playbackWidth, h, globalPadding);

        comPortBox = new ComPortBox(x+w*2, y, w, h, globalPadding);
        rcBox = new RadioConfigBox(x+w, y + comPortBox.h, w, h, globalPadding);
        channelPopup = new ChannelPopup(x+w, y, w, h, globalPadding);
        pollPopup = new PollPopup(x+w,y,w,h,globalPadding);

        wcBox = new WifiConfigBox(x+w, y, w, h, globalPadding);

        initBox = new InitBox(x, (dataSourceBox.y + dataSourceBox.h), w, h, globalPadding);

        // Ganglion
        bleBox = new BLEBox(x + w, interfaceBoxGanglion.y + interfaceBoxGanglion.h, w, h, globalPadding);
        dataLogBoxGanglion = new SessionDataBox(x + w, (bleBox.y + bleBox.h), w, h, globalPadding, DATASOURCE_GANGLION);
        sampleRateGanglionBox = new SampleRateGanglionBox(x + w, (dataLogBoxGanglion.y + dataLogBoxGanglion.h), w, h, globalPadding);
        latencyGanglionBox = new LatencyGanglionBox(x + w, (sampleRateGanglionBox.y + sampleRateGanglionBox.h), w, h, globalPadding);
        wifiTransferProtcolGanglionBox = new WifiTransferProtcolGanglionBox(x + w, (latencyGanglionBox.y + latencyGanglionBox.h), w, h, globalPadding);
        // bleHardwareBox = new BLEHardwareBox(x + w, (dataLogBoxGanglion.y + dataLogBoxGanglion.h), w, h, globalPadding);
    }

    public void resetListItems(){
        serialList.activeItem = -1;
        bleList.activeItem = -1;
        wifiList.activeItem = -1;
    }

    public void open(){
        isOpen = true;
        topNav.controlPanelCollapser.setIsActive(true);
    }

    public void close(){
        isOpen = false;
        topNav.controlPanelCollapser.setIsActive(false);
    }

    public void update() {
        //toggle view of cp5 / serial list selection table
        if (isOpen) { // if control panel is open
            if (!cp5.isVisible()) {  //and cp5 is not visible
                cp5.show(); // shot it
                cp5Popup.show();
            }
        } else { //the opposite of above
            if (cp5.isVisible()) {
                cp5.hide();
                cp5Popup.hide();
            }
        }

        //auto-update serial list
        if(Serial.list().length != serialPorts.length && systemMode != SYSTEMMODE_POSTINIT){
            println("Refreshing port list...");
            refreshPortList();
        }

        //update all boxes if they need to be
        dataSourceBox.update();
        serialBox.update();
        bleBox.update();
        dataLogBoxCyton.update();
        channelCountBox.update();
        synthChannelCountBox.update();

        //update playback box sizes when dropdown is selected
        recentPlaybackBox.update();
        playbackFileBox.update();
        sdConverterBox.update();

        sdBox.update();
        rcBox.update();
        comPortBox.update();
        wcBox.update();
        initBox.update();

        channelPopup.update();
        serialList.updateMenu();
        bleList.updateMenu();
        wifiList.updateMenu();
        dataLogBoxGanglion.update();
        latencyCytonBox.update();
        wifiTransferProtcolCytonBox.update();

        wifiBox.update();
        interfaceBoxCyton.update();
        interfaceBoxGanglion.update();
        latencyGanglionBox.update();
        wifiTransferProtcolGanglionBox.update();

        //SD File Conversion
        while (convertingSD == true) {
            convertSDFile();
        }
    }

    public void draw() {

        pushStyle();

        noStroke();

        initBox.draw();

        if (systemMode == 10) {
            drawStopInstructions = true;
        }

        if (systemMode != 10) { // only draw control panel boxes if system running is false
            dataSourceBox.draw();
            drawStopInstructions = false;
            cp5.setVisible(true);//make sure controlP5 elements are visible
            cp5Popup.setVisible(true);

            if (eegDataSource == DATASOURCE_CYTON) {	//when data source is from OpenBCI
                if(!hub.isHubRunning()) {
                    noHubBox.draw();
                }
                else if (cyton.getInterface() == INTERFACE_NONE) {
                    interfaceBoxCyton.draw();
                } else {
                    interfaceBoxCyton.draw();
                    if (cyton.getInterface() == INTERFACE_SERIAL) {
                        serialBox.y = interfaceBoxCyton.y + interfaceBoxCyton.h;
                        serialBox.draw();
                        dataLogBoxCyton.y = serialBox.y + serialBox.h; 
                        if (rcBox.isShowing) {
                            comPortBox.draw();
                            rcBox.draw();
                            cp5.get(MenuList.class, "serialList").setVisible(true);
                            if (channelPopup.wasClicked()) {
                                channelPopup.draw();
                                cp5Popup.get(MenuList.class, "channelListCP").setVisible(true);
                                cp5Popup.get(MenuList.class, "pollList").setVisible(false);
                                cp5.get(MenuList.class, "serialList").setVisible(true); //make sure the serialList menulist is visible
                                //cp5.get(MenuList.class, "sdTimes").setVisible(true); //make sure the SD time record options menulist is visible
                            } else if (pollPopup.wasClicked()) {
                                pollPopup.draw();
                                cp5Popup.get(MenuList.class, "pollList").setVisible(true);
                                cp5Popup.get(MenuList.class, "channelListCP").setVisible(false);
                                cp5.get(Textfield.class, "fileNameCyton").setVisible(true); //make sure the data file field is visible
                                // cp5.get(Textfield.class, "fileNameGanglion").setVisible(true); //make sure the data file field is visible
                                cp5.get(MenuList.class, "serialList").setVisible(true); //make sure the serialList menulist is visible
                                //cp5.get(MenuList.class, "sdTimes").setVisible(true); //make sure the SD time record options menulist is visible
                                cp5.get(Textfield.class, "staticIPAddress").setVisible(false);
                            }
                        }
                    } else if (cyton.getInterface() == INTERFACE_HUB_WIFI) {
                        wifiBox.y = interfaceBoxCyton.y + interfaceBoxCyton.h;

                        wifiBox.draw();
                        dataLogBoxCyton.y = wifiBox.y + wifiBox.h;

                        if (hub.getWiFiStyle() == WIFI_STATIC) {
                            cp5.get(Textfield.class, "staticIPAddress").setVisible(true);
                            cp5.get(MenuList.class, "wifiList").setVisible(false);
                        } else {
                            cp5.get(Textfield.class, "staticIPAddress").setVisible(false);
                            cp5.get(MenuList.class, "wifiList").setVisible(true);
                        }
                        if(wcBox.isShowing){
                            wcBox.draw();
                        }
                        sampleRateCytonBox.draw();
                        latencyCytonBox.draw();
                        wifiTransferProtcolCytonBox.draw();
                    }
                    channelCountBox.y = dataLogBoxCyton.y + dataLogBoxCyton.h;
                    sdBox.y = channelCountBox.y + channelCountBox.h;
                    sampleRateCytonBox.y = channelCountBox.y;
                    latencyCytonBox.y = sampleRateCytonBox.y + sampleRateCytonBox.h;
                    wifiTransferProtcolCytonBox.y = latencyCytonBox.y + latencyCytonBox.h;
                    channelCountBox.draw();
                    sdBox.draw();
                    cp5.get(Textfield.class, "fileNameCyton").setVisible(true); //make sure the data file field is visible
                    cp5.get(Textfield.class, "fileNameGanglion").setVisible(false); //make sure the data file field is not visible
                    //cp5.get(MenuList.class, "sdTimes").setVisible(true); //make sure the SD time record options menulist is visible
                    dataLogBoxCyton.draw(); //Drawing here allows max file size dropdown to be drawn on top
                }
            } else if (eegDataSource == DATASOURCE_PLAYBACKFILE) { //when data source is from playback file
                recentPlaybackBox.draw();
                playbackFileBox.draw();
                sdConverterBox.draw();

                //set other CP5 controllers invisible
                // cp5.get(Textfield.class, "fileNameCyton").setVisible(false); //make sure the data file field is visible
                // cp5.get(Textfield.class, "fileNameGanglion").setVisible(false); //make sure the data file field is visible
                cp5.get(MenuList.class, "serialList").setVisible(false);
                //cp5.get(MenuList.class, "sdTimes").setVisible(false);
                cp5Popup.get(MenuList.class, "channelListCP").setVisible(false);
                cp5Popup.get(MenuList.class, "pollList").setVisible(false);

            } else if (eegDataSource == DATASOURCE_SYNTHETIC) {  //synthetic
                //set other CP5 controllers invisible
                // hideAllBoxes();
                synthChannelCountBox.draw();
            } else if (eegDataSource == DATASOURCE_GANGLION) {
                if(!hub.isHubRunning()) {
                    noHubBox.draw();
                }
                else if (ganglion.getInterface() == INTERFACE_NONE) {
                    interfaceBoxGanglion.draw();
                } else {
                    interfaceBoxGanglion.draw();
                    if (ganglion.getInterface() == INTERFACE_HUB_BLE || ganglion.getInterface() == INTERFACE_HUB_BLED112) {
                        bleBox.y = interfaceBoxGanglion.y + interfaceBoxGanglion.h;
                        dataLogBoxGanglion.y = bleBox.y + bleBox.h;
                        bleBox.draw();
                        cp5.get(MenuList.class, "bleList").setVisible(true);
                        cp5.get(Textfield.class, "staticIPAddress").setVisible(false);
                    } else if (ganglion.getInterface() == INTERFACE_HUB_WIFI) {
                        wifiBox.y = interfaceBoxGanglion.y + interfaceBoxGanglion.h;
                        dataLogBoxGanglion.y = wifiBox.y + wifiBox.h;
                        wifiBox.draw();
                        if (hub.getWiFiStyle() == WIFI_STATIC) {
                            cp5.get(Textfield.class, "staticIPAddress").setVisible(true);
                            cp5.get(MenuList.class, "wifiList").setVisible(false);
                        } else {
                            cp5.get(Textfield.class, "staticIPAddress").setVisible(false);
                            cp5.get(MenuList.class, "wifiList").setVisible(true);
                        }
                        if(wcBox.isShowing){
                            wcBox.draw();
                        }
                        latencyGanglionBox.y = dataLogBoxGanglion.y + dataLogBoxGanglion.h;
                        sampleRateGanglionBox.y = latencyGanglionBox.y + latencyGanglionBox.h;
                        wifiTransferProtcolGanglionBox.y = wifiTransferProtcolGanglionBox.y + wifiTransferProtcolGanglionBox.h;
                        latencyGanglionBox.draw();
                        sampleRateGanglionBox.draw();
                        wifiTransferProtcolGanglionBox.draw();
                    }
                    dataLogBoxGanglion.draw(); //Drawing here allows max file size dropdown to be drawn on top
                    cp5.get(Textfield.class, "fileNameCyton").setVisible(false); //make sure the data file field is visible
                    cp5.get(Textfield.class, "fileNameGanglion").setVisible(true); //make sure the data file field is visible
                }
            } else {
                //set other CP5 controllers invisible
                hideAllBoxes();
            }
        } else {
            cp5.setVisible(false); // if isRunning is true, hide all controlP5 elements
            cp5Popup.setVisible(false);
            // cp5Serial.setVisible(false);    //%%%
        }

        //draw the box that tells you to stop the system in order to edit control settings
        if (drawStopInstructions) {
            pushStyle();
            fill(boxColor);
            strokeWeight(1);
            stroke(boxStrokeColor);
            rect(x, y, w, dataSourceBox.h); //draw background of box
            String stopInstructions = "Press the \"STOP SESSION\" button to change your data source or edit system settings.";
            textAlign(CENTER, TOP);
            textFont(p4, 14);
            fill(bgColor);
            text(stopInstructions, x + globalPadding*2, y + globalPadding*3, w - globalPadding*4, dataSourceBox.h - globalPadding*4);
            popStyle();
        }

        //draw the ControlP5 stuff
        textFont(p4, 14);
        cp5Popup.draw();
        cp5.draw();

        //Drawing here allows max file size dropdown to be drawn on top of all other cp5 elements
        if (systemMode != 10 && outputDataSource == OUTPUT_SOURCE_ODF) {
            if (eegDataSource == DATASOURCE_CYTON && cyton.getInterface() != INTERFACE_NONE) {
                dataLogBoxCyton.cp5_dataLog_dropdown.draw();
            } else if (eegDataSource == DATASOURCE_GANGLION && ganglion.getInterface() != INTERFACE_NONE) {
                dataLogBoxGanglion.cp5_dataLog_dropdown.draw();
            }
        }

        popStyle();
    }

    public void hideRadioPopoutBox() {
        rcBox.isShowing = false;
        comPortBox.isShowing = false;
        cp5Popup.hide(); // make sure to hide the controlP5 object
        cp5Popup.get(MenuList.class, "channelListCP").setVisible(false);
        cp5Popup.get(MenuList.class, "pollList").setVisible(false);
        cp5.get(MenuList.class, "serialList").setVisible(false);
        // cp5Popup.hide(); // make sure to hide the controlP5 object
        popOutRadioConfigButton.setString("Manual >");
        rcBox.print_onscreen("");
        if (board != null) {
            board.stop();
        }
        board = null;
    }

    public void hideWifiPopoutBox() {
        wcBox.isShowing = false;
        popOutWifiConfigButton.setString(">");
        wcBox.updateMessage("");
        if (hub.isPortOpen()) hub.closePort();
    }

    public void refreshPortList(){
        serialPorts = new String[Serial.list().length];
        serialPorts = Serial.list();
        serialList.items.clear();
        for (int i = 0; i < serialPorts.length; i++) {
            String tempPort = serialPorts[(serialPorts.length-1) - i]; //list backwards... because usually our port is at the bottom
            serialList.addItem(makeItem(tempPort));
        }
        serialList.updateMenu();
    }

    public void hideAllBoxes() {
        //set other CP5 controllers invisible
        //
        cp5.get(Textfield.class, "fileNameCyton").setVisible(false);
        cp5.get(Textfield.class, "staticIPAddress").setVisible(false);
        cp5.get(Textfield.class, "fileNameGanglion").setVisible(false);
        cp5.get(MenuList.class, "serialList").setVisible(false);
        cp5.get(MenuList.class, "bleList").setVisible(false);
        //cp5.get(MenuList.class, "sdTimes").setVisible(false);
        cp5.get(MenuList.class, "wifiList").setVisible(false);
        cp5Popup.get(MenuList.class, "channelListCP").setVisible(false);
        cp5Popup.get(MenuList.class, "pollList").setVisible(false);
    }

    private void hideChannelListCP() {
        cp5Popup.get(MenuList.class, "channelListCP").setVisible(false);
        channelPopup.setClicked(false);
        if (setChannel.wasPressed) {
            setChannel.wasPressed = false;
        } else if(ovrChannel.wasPressed) {
            ovrChannel.wasPressed = false;
        }
    }

    //mouse pressed in control panel
    public void CPmousePressed() {
        // verbosePrint("CPmousePressed");

        if (initSystemButton.isMouseHere()) {
            initSystemButton.setIsActive(true);
            initSystemButton.wasPressed = true;
        }

        //only able to click buttons of control panel when system is not running
        if (systemMode != 10) {

            if ((eegDataSource == DATASOURCE_CYTON || eegDataSource == DATASOURCE_GANGLION) && (cyton.isWifi() || ganglion.isWifi())) {
                if(getIpAddress.isMouseHere()) {
                    getIpAddress.setIsActive(true);
                    getIpAddress.wasPressed = true;
                }

                if(getFirmwareVersion.isMouseHere()) {
                    getFirmwareVersion.setIsActive(true);
                    getFirmwareVersion.wasPressed = true;
                }

                if(getMacAddress.isMouseHere()) {
                    getMacAddress.setIsActive(true);
                    getMacAddress.wasPressed = true;
                }

                if(eraseCredentials.isMouseHere()) {
                    eraseCredentials.setIsActive(true);
                    eraseCredentials.wasPressed = true;
                }

                if(getTypeOfAttachedBoard.isMouseHere()) {
                    getTypeOfAttachedBoard.setIsActive(true);
                    getTypeOfAttachedBoard.wasPressed = true;
                }

                if (popOutWifiConfigButton.isMouseHere()){
                    popOutWifiConfigButton.setIsActive(true);
                    popOutWifiConfigButton.wasPressed = true;
                }

                if(wifiIPAddressDynamic.isMouseHere()) {
                    wifiIPAddressDynamic.setIsActive(true);
                    wifiIPAddressDynamic.wasPressed = true;
                    wifiIPAddressDynamic.setColorNotPressed(isSelected_color);
                    wifiIPAddressStatic.setColorNotPressed(colorNotPressed);
                }

                if(wifiIPAddressStatic.isMouseHere()) {
                    wifiIPAddressStatic.setIsActive(true);
                    wifiIPAddressStatic.wasPressed = true;
                    wifiIPAddressStatic.setColorNotPressed(isSelected_color);
                    wifiIPAddressDynamic.setColorNotPressed(colorNotPressed);
                }
            }

            // active button when the hub is not running
            if (!hub.isHubRunning()) {
                if (noHubShowDoc.isMouseHere()) {
                    noHubShowDoc.setIsActive(true);
                    noHubShowDoc.wasPressed = true;
                }
            }
            //active buttons during DATASOURCE_CYTON
            else if (eegDataSource == DATASOURCE_CYTON) {

                // active button when the hub is not running
                if (!hub.isHubRunning()) {
                    if (noHubShowDoc.isMouseHere()) {
                        noHubShowDoc.setIsActive(true);
                        noHubShowDoc.wasPressed = true;
                    }
                } else {
                    if (cyton.isSerial()) {
                        if (popOutRadioConfigButton.isMouseHere()){
                            popOutRadioConfigButton.setIsActive(true);
                            popOutRadioConfigButton.wasPressed = true;
                        }
                        if (refreshPort.isMouseHere()) {
                            refreshPort.setIsActive(true);
                            refreshPort.wasPressed = true;
                        }
                        if (serialBox.autoConnect.isMouseHere()) {
                            serialBox.autoConnect.setIsActive(true);
                            serialBox.autoConnect.wasPressed = true;
                        }
                    }

                    if (cyton.isWifi()) {
                        if (refreshWifi.isMouseHere()) {
                            refreshWifi.setIsActive(true);
                            refreshWifi.wasPressed = true;
                        }
                    }


                    if (autoSessionName.isMouseHere()) {
                        autoSessionName.setIsActive(true);
                        autoSessionName.wasPressed = true;
                    }

                    if (outputODF.isMouseHere()) {
                        outputODF.setIsActive(true);
                        outputODF.wasPressed = true;
                    }

                    if (outputBDF.isMouseHere()) {
                        outputBDF.setIsActive(true);
                        outputBDF.wasPressed = true;
                    }

                    if (chanButton8.isMouseHere()) {
                        chanButton8.setIsActive(true);
                        chanButton8.wasPressed = true;
                        chanButton8.setColorNotPressed(isSelected_color);
                        chanButton16.setColorNotPressed(colorNotPressed); //default color of button
                    }

                    if (chanButton16.isMouseHere()) {
                        chanButton16.setIsActive(true);
                        chanButton16.wasPressed = true;
                        chanButton8.setColorNotPressed(colorNotPressed); //default color of button
                        chanButton16.setColorNotPressed(isSelected_color);
                    }

                    if (getChannel.isMouseHere()){
                        getChannel.setIsActive(true);
                        getChannel.wasPressed = true;
                    }

                    if (setChannel.isMouseHere()){
                        setChannel.setIsActive(true);
                        setChannel.wasPressed = true;
                        ovrChannel.wasPressed = false;
                    }

                    if (ovrChannel.isMouseHere()){
                        ovrChannel.setIsActive(true);
                        ovrChannel.wasPressed = true;
                        setChannel.wasPressed = false;
                    }



                    if (protocolWifiCyton.isMouseHere()) {
                        protocolWifiCyton.setIsActive(true);
                        protocolWifiCyton.wasPressed = true;
                        protocolWifiCyton.setColorNotPressed(isSelected_color);
                        protocolSerialCyton.setColorNotPressed(colorNotPressed);
                    }

                    if (protocolSerialCyton.isMouseHere()) {
                        protocolSerialCyton.setIsActive(true);
                        protocolSerialCyton.wasPressed = true;
                        protocolWifiCyton.setColorNotPressed(colorNotPressed);
                        protocolSerialCyton.setColorNotPressed(isSelected_color);
                    }

                    if (autoscan.isMouseHere()){
                        autoscan.setIsActive(true);
                        autoscan.wasPressed = true;
                    }

                    if (systemStatus.isMouseHere()){
                        systemStatus.setIsActive(true);
                        systemStatus.wasPressed = true;
                    }

                    if (sampleRate250.isMouseHere()) {
                        sampleRate250.setIsActive(true);
                        sampleRate250.wasPressed = true;
                        sampleRate250.setColorNotPressed(isSelected_color);
                        sampleRate500.setColorNotPressed(colorNotPressed);
                        sampleRate1000.setColorNotPressed(colorNotPressed); //default color of button
                    }

                    if (sampleRate500.isMouseHere()) {
                        sampleRate500.setIsActive(true);
                        sampleRate500.wasPressed = true;
                        sampleRate500.setColorNotPressed(isSelected_color);
                        sampleRate250.setColorNotPressed(colorNotPressed);
                        sampleRate1000.setColorNotPressed(colorNotPressed); //default color of button
                    }

                    if (sampleRate1000.isMouseHere()) {
                        sampleRate1000.setIsActive(true);
                        sampleRate1000.wasPressed = true;
                        sampleRate1000.setColorNotPressed(isSelected_color);
                        sampleRate250.setColorNotPressed(colorNotPressed); //default color of button
                        sampleRate500.setColorNotPressed(colorNotPressed);
                    }

                    if (latencyCyton5ms.isMouseHere()) {
                        latencyCyton5ms.setIsActive(true);
                        latencyCyton5ms.wasPressed = true;
                        latencyCyton5ms.setColorNotPressed(isSelected_color);
                        latencyCyton10ms.setColorNotPressed(colorNotPressed); //default color of button
                        latencyCyton20ms.setColorNotPressed(colorNotPressed); //default color of button
                    }

                    if (latencyCyton10ms.isMouseHere()) {
                        latencyCyton10ms.setIsActive(true);
                        latencyCyton10ms.wasPressed = true;
                        latencyCyton10ms.setColorNotPressed(isSelected_color);
                        latencyCyton5ms.setColorNotPressed(colorNotPressed); //default color of button
                        latencyCyton20ms.setColorNotPressed(colorNotPressed); //default color of button
                    }

                    if (latencyCyton20ms.isMouseHere()) {
                        latencyCyton20ms.setIsActive(true);
                        latencyCyton20ms.wasPressed = true;
                        latencyCyton20ms.setColorNotPressed(isSelected_color);
                        latencyCyton5ms.setColorNotPressed(colorNotPressed); //default color of button
                        latencyCyton10ms.setColorNotPressed(colorNotPressed); //default color of button
                    }

                    if (wifiInternetProtocolCytonTCP.isMouseHere()) {
                        wifiInternetProtocolCytonTCP.setIsActive(true);
                        wifiInternetProtocolCytonTCP.wasPressed = true;
                        wifiInternetProtocolCytonTCP.setColorNotPressed(isSelected_color);
                        wifiInternetProtocolCytonUDP.setColorNotPressed(colorNotPressed); //default color of button
                        wifiInternetProtocolCytonUDPBurst.setColorNotPressed(colorNotPressed); //default color of button
                    }

                    if (wifiInternetProtocolCytonUDP.isMouseHere()) {
                        wifiInternetProtocolCytonUDP.setIsActive(true);
                        wifiInternetProtocolCytonUDP.wasPressed = true;
                        wifiInternetProtocolCytonUDP.setColorNotPressed(isSelected_color);
                        wifiInternetProtocolCytonTCP.setColorNotPressed(colorNotPressed); //default color of button
                        wifiInternetProtocolCytonUDPBurst.setColorNotPressed(colorNotPressed); //default color of button
                    }

                    if (wifiInternetProtocolCytonUDPBurst.isMouseHere()) {
                        wifiInternetProtocolCytonUDPBurst.setIsActive(true);
                        wifiInternetProtocolCytonUDPBurst.wasPressed = true;
                        wifiInternetProtocolCytonUDPBurst.setColorNotPressed(isSelected_color);
                        wifiInternetProtocolCytonTCP.setColorNotPressed(colorNotPressed); //default color of button
                        wifiInternetProtocolCytonUDP.setColorNotPressed(colorNotPressed); //default color of button
                    }
                }
            }

            else if (eegDataSource == DATASOURCE_GANGLION) {

                // active button when the hub is not running
                if (!hub.isHubRunning()) {
                    if (noHubShowDoc.isMouseHere()) {
                        noHubShowDoc.setIsActive(true);
                        noHubShowDoc.wasPressed = true;
                    }
                } else {
                    // This is where we check for button presses if we are searching for BLE devices
                    if (autoSessionName.isMouseHere()) {
                        autoSessionName.setIsActive(true);
                        autoSessionName.wasPressed = true;
                    }

                    if (outputODF.isMouseHere()) {
                        outputODF.setIsActive(true);
                        outputODF.wasPressed = true;
                    }

                    if (outputBDF.isMouseHere()) {
                        outputBDF.setIsActive(true);
                        outputBDF.wasPressed = true;
                    }

                    if (ganglion.isWifi()) {
                        if (refreshWifi.isMouseHere()) {
                            refreshWifi.setIsActive(true);
                            refreshWifi.wasPressed = true;
                        }
                    } else {
                        if (refreshBLE.isMouseHere()) {
                            refreshBLE.setIsActive(true);
                            refreshBLE.wasPressed = true;
                        }
                    }

                    // this button only used on mac
                    if (isMac() && protocolBLEGanglion.isMouseHere()) {
                        protocolBLEGanglion.setIsActive(true);
                        protocolBLEGanglion.wasPressed = true;
                        protocolBLED112Ganglion.setColorNotPressed(colorNotPressed);
                        protocolBLEGanglion.setColorNotPressed(isSelected_color);
                        protocolWifiGanglion.setColorNotPressed(colorNotPressed);
                    }

                    if (protocolWifiGanglion.isMouseHere()) {
                        protocolWifiGanglion.setIsActive(true);
                        protocolWifiGanglion.wasPressed = true;
                        protocolBLED112Ganglion.setColorNotPressed(colorNotPressed);
                        protocolWifiGanglion.setColorNotPressed(isSelected_color);
                        if(isMac()) {
                            protocolBLEGanglion.setColorNotPressed(colorNotPressed);
                        }
                    }

                    if (protocolBLED112Ganglion.isMouseHere()) {
                        protocolBLED112Ganglion.setIsActive(true);
                        protocolBLED112Ganglion.wasPressed = true;
                        if(isMac()) {
                            protocolBLEGanglion.setColorNotPressed(colorNotPressed);
                        }
                        protocolBLED112Ganglion.setColorNotPressed(isSelected_color);
                        protocolWifiGanglion.setColorNotPressed(colorNotPressed);
                    }

                    if (sampleRate200.isMouseHere()) {
                        sampleRate200.setIsActive(true);
                        sampleRate200.wasPressed = true;
                        sampleRate200.setColorNotPressed(isSelected_color);
                        sampleRate1600.setColorNotPressed(colorNotPressed); //default color of button
                    }

                    if (sampleRate1600.isMouseHere()) {
                        sampleRate1600.setIsActive(true);
                        sampleRate1600.wasPressed = true;
                        sampleRate1600.setColorNotPressed(isSelected_color);
                        sampleRate200.setColorNotPressed(colorNotPressed); //default color of button
                    }

                    if (latencyGanglion5ms.isMouseHere()) {
                        latencyGanglion5ms.setIsActive(true);
                        latencyGanglion5ms.wasPressed = true;
                        latencyGanglion5ms.setColorNotPressed(isSelected_color);
                        latencyGanglion10ms.setColorNotPressed(colorNotPressed); //default color of button
                        latencyGanglion20ms.setColorNotPressed(colorNotPressed); //default color of button
                    }

                    if (latencyGanglion10ms.isMouseHere()) {
                        latencyGanglion10ms.setIsActive(true);
                        latencyGanglion10ms.wasPressed = true;
                        latencyGanglion10ms.setColorNotPressed(isSelected_color);
                        latencyGanglion5ms.setColorNotPressed(colorNotPressed); //default color of button
                        latencyGanglion20ms.setColorNotPressed(colorNotPressed); //default color of button
                    }

                    if (latencyGanglion20ms.isMouseHere()) {
                        latencyGanglion20ms.setIsActive(true);
                        latencyGanglion20ms.wasPressed = true;
                        latencyGanglion20ms.setColorNotPressed(isSelected_color);
                        latencyGanglion5ms.setColorNotPressed(colorNotPressed); //default color of button
                        latencyGanglion10ms.setColorNotPressed(colorNotPressed); //default color of button
                    }

                    if (wifiInternetProtocolGanglionTCP.isMouseHere()) {
                        wifiInternetProtocolGanglionTCP.setIsActive(true);
                        wifiInternetProtocolGanglionTCP.wasPressed = true;
                        wifiInternetProtocolGanglionTCP.setColorNotPressed(isSelected_color);
                        wifiInternetProtocolGanglionUDP.setColorNotPressed(colorNotPressed); //default color of button
                        wifiInternetProtocolGanglionUDPBurst.setColorNotPressed(colorNotPressed); //default color of button
                    }

                    if (wifiInternetProtocolGanglionUDP.isMouseHere()) {
                        wifiInternetProtocolGanglionUDP.setIsActive(true);
                        wifiInternetProtocolGanglionUDP.wasPressed = true;
                        wifiInternetProtocolGanglionUDP.setColorNotPressed(isSelected_color);
                        wifiInternetProtocolGanglionTCP.setColorNotPressed(colorNotPressed); //default color of button
                        wifiInternetProtocolGanglionUDPBurst.setColorNotPressed(colorNotPressed); //default color of button
                    }

                    if (wifiInternetProtocolGanglionUDPBurst.isMouseHere()) {
                        wifiInternetProtocolGanglionUDPBurst.setIsActive(true);
                        wifiInternetProtocolGanglionUDPBurst.wasPressed = true;
                        wifiInternetProtocolGanglionUDPBurst.setColorNotPressed(isSelected_color);
                        wifiInternetProtocolGanglionTCP.setColorNotPressed(colorNotPressed); //default color of button
                        wifiInternetProtocolGanglionUDP.setColorNotPressed(colorNotPressed); //default color of button
                    }
                }
            }

            //active buttons during DATASOURCE_PLAYBACKFILE
            if (eegDataSource == DATASOURCE_PLAYBACKFILE) {
                if (selectPlaybackFile.isMouseHere()) {
                    selectPlaybackFile.setIsActive(true);
                    selectPlaybackFile.wasPressed = true;
                }
                if (selectSDFile.isMouseHere()) {
                    selectSDFile.setIsActive(true);
                    selectSDFile.wasPressed = true;
                }
                if (sampleDataButton.isMouseHere()) {
                    sampleDataButton.setIsActive(true);
                    sampleDataButton.wasPressed = true;
                }
            }

            //active buttons during DATASOURCE_SYNTHETIC
            if (eegDataSource == DATASOURCE_SYNTHETIC) {
                if (synthChanButton4.isMouseHere()) {
                    synthChanButton4.setIsActive(true);
                    synthChanButton4.wasPressed = true;
                    synthChanButton4.setColorNotPressed(isSelected_color);
                    synthChanButton8.setColorNotPressed(colorNotPressed); //default color of button
                    synthChanButton16.setColorNotPressed(colorNotPressed); //default color of button
                }

                if (synthChanButton8.isMouseHere()) {
                    synthChanButton8.setIsActive(true);
                    synthChanButton8.wasPressed = true;
                    synthChanButton8.setColorNotPressed(isSelected_color);
                    synthChanButton4.setColorNotPressed(colorNotPressed); //default color of button
                    synthChanButton16.setColorNotPressed(colorNotPressed); //default color of button
                }

                if (synthChanButton16.isMouseHere()) {
                    synthChanButton16.setIsActive(true);
                    synthChanButton16.wasPressed = true;
                    synthChanButton16.setColorNotPressed(isSelected_color);
                    synthChanButton4.setColorNotPressed(colorNotPressed); //default color of button
                    synthChanButton8.setColorNotPressed(colorNotPressed); //default color of button
                }
            }

        }
        // output("Text File Name: " + cp5.get(Textfield.class,"fileNameCyton").getText());
    }

    //mouse released in control panel
    public void CPmouseReleased() {
        //verbosePrint("CPMouseReleased: CPmouseReleased start...");
        if (popOutRadioConfigButton.isMouseHere() && popOutRadioConfigButton.wasPressed) {
            popOutRadioConfigButton.wasPressed = false;
            popOutRadioConfigButton.setIsActive(false);
            if (cyton.isSerial()) {
                if (rcBox.isShowing) {
                    hideRadioPopoutBox();
                    serialBox.autoConnect.setIgnoreHover(false);
                    serialBox.autoConnect.setColorNotPressed(255);
                } else {
                    rcBox.isShowing = true;
                    rcBox.print_onscreen(rcBox.initial_message);
                    popOutRadioConfigButton.setString("Manual <");
                    serialBox.autoConnect.setIgnoreHover(true);
                    serialBox.autoConnect.setColorNotPressed(140);
                }
            }
        }

        if (serialBox.autoConnect.isMouseHere() && serialBox.autoConnect.wasPressed) {
            serialBox.autoConnect.wasPressed = false;
            serialBox.autoConnect.setIsActive(false);
            serialBox.attemptAutoConnectCyton();
        }

        if (rcBox.isShowing) {
            if(getChannel.isMouseHere() && getChannel.wasPressed){
                // if(board != null) // Radios_Config will handle creating the serial port JAM 1/2017
                get_channel(rcBox);
                getChannel.wasPressed = false;
                getChannel.setIsActive(false);
                hideChannelListCP();
            }

            if (setChannel.isMouseHere() && setChannel.wasPressed){
                channelPopup.setClicked(true);
                channelPopup.setTitle("Change Channel");
                pollPopup.setClicked(false);
                setChannel.setIsActive(false);
            }

            if (ovrChannel.isMouseHere() && ovrChannel.wasPressed){
                channelPopup.setClicked(true);
                channelPopup.setTitle("Override Dongle");
                pollPopup.setClicked(false);
                ovrChannel.setIsActive(false);
            }

            if(autoscan.isMouseHere() && autoscan.wasPressed){
                autoscan.wasPressed = false;
                autoscan.setIsActive(false);
                scan_channels(rcBox);
                hideChannelListCP();
            }

            if(systemStatus.isMouseHere() && systemStatus.wasPressed){
                system_status(rcBox);
                systemStatus.setIsActive(false);
                systemStatus.wasPressed = false;
                hideChannelListCP();
            }
        }

        if(popOutWifiConfigButton.isMouseHere() && popOutWifiConfigButton.wasPressed){
            popOutWifiConfigButton.wasPressed = false;
            popOutWifiConfigButton.setIsActive(false);
            if (cyton.isWifi() || ganglion.isWifi()) {
                if(wcBox.isShowing){
                    hideWifiPopoutBox();
                } else {
                    if (hub.getWiFiStyle() == WIFI_STATIC) {
                        wifi_ipAddress = cp5.get(Textfield.class, "staticIPAddress").getText();
                        println("Static IP address of " + wifi_ipAddress);
                        output("Static IP address of " + wifi_ipAddress);
                        hub.examineWifi(wifi_ipAddress);
                        wcBox.isShowing = true;
                        popOutWifiConfigButton.setString("<");
                    } else {
                        if (wifi_portName == "N/A") {
                            output("Please select a WiFi Shield first. Can't see your WiFi Shield? Learn how at openbci.github.io/Documentation/");
                        } else {
                            output("Attempting to connect to WiFi Shield named " + wifi_portName);
                            hub.examineWifi(wifi_portName);
                            wcBox.isShowing = true;
                            popOutWifiConfigButton.setString("<");
                        }
                    }
                }
            }
        }

        if (wcBox.isShowing) {
            if(getIpAddress.isMouseHere() && getIpAddress.wasPressed){
                hub.getWifiInfo(TCP_WIFI_GET_IP_ADDRESS);
                getIpAddress.wasPressed = false;
                getIpAddress.setIsActive(false);
            }

            if(getFirmwareVersion.isMouseHere() && getFirmwareVersion.wasPressed){
                hub.getWifiInfo(TCP_WIFI_GET_FIRMWARE_VERSION);
                getFirmwareVersion.wasPressed = false;
                getFirmwareVersion.setIsActive(false);
            }

            if(getMacAddress.isMouseHere() && getMacAddress.wasPressed){
                hub.getWifiInfo(TCP_WIFI_GET_MAC_ADDRESS);
                getMacAddress.wasPressed = false;
                getMacAddress.setIsActive(false);
            }

            if(eraseCredentials.isMouseHere() && eraseCredentials.wasPressed){
                hub.getWifiInfo(TCP_WIFI_ERASE_CREDENTIALS);
                eraseCredentials.wasPressed=false;
                eraseCredentials.setIsActive(false);
            }

            if(getTypeOfAttachedBoard.isMouseHere() && getTypeOfAttachedBoard.wasPressed){
                // Wifi_Config will handle creating the connection
                hub.getWifiInfo(TCP_WIFI_GET_TYPE_OF_ATTACHED_BOARD);
                getTypeOfAttachedBoard.wasPressed=false;
                getTypeOfAttachedBoard.setIsActive(false);
            }
        }

        if (initSystemButton.isMouseHere() && initSystemButton.wasPressed) {
            if (rcBox.isShowing) {
                hideRadioPopoutBox();
            }
            if (wcBox.isShowing) {
                hideWifiPopoutBox();
            }
            //if system is not active ... initate system and flip button state
            initButtonPressed();
            //cursor(ARROW); //this this back to ARROW
        }

        if ((eegDataSource == DATASOURCE_CYTON || eegDataSource == DATASOURCE_GANGLION)) {
            if (noHubShowDoc.isMouseHere() && noHubShowDoc.wasPressed) {
                noHubShowDoc.wasPressed=false;
                noHubShowDoc.setIsActive(false);
                noHubShowDoc.goToURL();
            }
        }

        //open or close serial port if serial port button is pressed (left button in serial widget)
        if (refreshPort.isMouseHere() && refreshPort.wasPressed) {
            output("Serial/COM List Refreshed");
            refreshPortList();
        }

        if (refreshBLE.isMouseHere() && refreshBLE.wasPressed) {
            if (isHubObjectInitialized) {
                output("BLE Devices Refreshing");
                bleList.items.clear();
                hub.searchDeviceStart();
            } else {
                output("Please wait till BLE is fully initalized");
            }
        }

        if (refreshWifi.isMouseHere() && refreshWifi.wasPressed) {
            if (isHubObjectInitialized) {
                output("Wifi Devices Refreshing");
                wifiList.items.clear();
                hub.searchDeviceStart();
            } else {
                output("Please wait till hub is fully initalized");
            }
        }

        if(wifiIPAddressDynamic.isMouseHere() && wifiIPAddressDynamic.wasPressed) {
            hub.setWiFiStyle(WIFI_DYNAMIC);
            wifiBox.h = 200;
            String output = "Using " + (hub.getWiFiStyle() == WIFI_STATIC ? "Static" : "Dynamic") + " IP address of the WiFi Shield!";
            outputInfo(output);
            println("CP: WiFi IP: " + output);
        }

        if(wifiIPAddressStatic.isMouseHere() && wifiIPAddressStatic.wasPressed) {
            hub.setWiFiStyle(WIFI_STATIC);
            wifiBox.h = 120;
            String output = "Using " + (hub.getWiFiStyle() == WIFI_STATIC ? "Static" : "Dynamic") + " IP address of the WiFi Shield!";
            outputInfo(output);
            println("CP: WiFi IP: " + output);
        }

        // this button only used on mac
        if (isMac() && protocolBLEGanglion.isMouseHere() && protocolBLEGanglion.wasPressed) {
            println("protocolBLEGanglion");

            wifiList.items.clear();
            bleList.items.clear();
            controlPanel.hideAllBoxes();
            if (isHubObjectInitialized) {
                outputSuccess("Using built in BLE for Ganglion");
                if (hub.isPortOpen()) hub.closePort();
                ganglion.setInterface(INTERFACE_HUB_BLE);
                // hub.searchDeviceStart();
            } else {
                outputWarn("Please wait till hub is fully initalized");
            }
        }

        if (protocolBLED112Ganglion.isMouseHere() && protocolBLED112Ganglion.wasPressed) {

            wifiList.items.clear();
            bleList.items.clear();
            controlPanel.hideAllBoxes();
            if (isHubObjectInitialized) {
                output("Protocol BLED112 Selected for Ganglion");
                if (hub.isPortOpen()) hub.closePort();
                ganglion.setInterface(INTERFACE_HUB_BLED112);
                // hub.searchDeviceStart();
            } else {
                outputWarn("Please wait till hub is fully initalized");
            }
        }

        if (protocolWifiGanglion.isMouseHere() && protocolWifiGanglion.wasPressed) {
            println("protocolWifiGanglion");
            wifiList.items.clear();
            bleList.items.clear();
            controlPanel.hideAllBoxes();
            println("isHubObjectInitialized: " + (isHubObjectInitialized ? "true" : "else"));
            if (isHubObjectInitialized) {
                output("Protocol Wifi Selected for Ganglion");
                if (hub.isPortOpen()) hub.closePort();
                ganglion.setInterface(INTERFACE_HUB_WIFI);
                hub.searchDeviceStart();
            } else {
                output("Please wait till hub is fully initalized");
            }
        }

        if (protocolSerialCyton.isMouseHere() && protocolSerialCyton.wasPressed) {
            wifiList.items.clear();
            bleList.items.clear();
            controlPanel.hideAllBoxes();
            if (isHubObjectInitialized) {
                output("Protocol Serial Selected for Cyton");
                if (hub.isPortOpen()) hub.closePort();
                cyton.setInterface(INTERFACE_SERIAL);
            } else {
                output("Please wait till hub is fully initalized");
            }
        }

        if (protocolWifiCyton.isMouseHere() && protocolWifiCyton.wasPressed) {
            wifiList.items.clear();
            bleList.items.clear();
            controlPanel.hideAllBoxes();
            if (isHubObjectInitialized) {
                output("Protocol Wifi Selected for Cyton");
                if (hub.isPortOpen()) hub.closePort();
                cyton.setInterface(INTERFACE_HUB_WIFI);
                hub.searchDeviceStart();
            } else {
                output("Please wait till hub is fully initalized");
            }
        }



        if (autoSessionName.isMouseHere() && autoSessionName.wasPressed) {
            String _board = (eegDataSource == DATASOURCE_CYTON) ? "Cyton" : "Ganglion";
            String _textField = (eegDataSource == DATASOURCE_CYTON) ? "fileNameCyton" : "fileNameGanglion";
            output("Autogenerated " + _board + " Session Name based on current date & time.");
            cp5.get(Textfield.class, _textField).setText(getDateString());
        }

        if (outputODF.isMouseHere() && outputODF.wasPressed) {
            output("Output has been set to OpenBCI Data Format.");
            outputDataSource = OUTPUT_SOURCE_ODF;
            outputODF.setColorNotPressed(isSelected_color);
            outputBDF.setColorNotPressed(colorNotPressed);
            if (eegDataSource == DATASOURCE_CYTON) {
                controlPanel.dataLogBoxCyton.setToODFHeight();
            } else {
                controlPanel.dataLogBoxGanglion.setToODFHeight();
            }
        }

        if (outputBDF.isMouseHere() && outputBDF.wasPressed) {
            output(bdfMessage);
            outputDataSource = OUTPUT_SOURCE_BDF;
            outputBDF.setColorNotPressed(isSelected_color);
            outputODF.setColorNotPressed(colorNotPressed);
            if (eegDataSource == DATASOURCE_CYTON) {
                controlPanel.dataLogBoxCyton.setToBDFHeight();
            } else {
                controlPanel.dataLogBoxGanglion.setToBDFHeight();
            }
        }

        if (chanButton8.isMouseHere() && chanButton8.wasPressed) {
            updateToNChan(8);
        }

        if (chanButton16.isMouseHere() && chanButton16.wasPressed ) {
            updateToNChan(16);
        }

        if (sampleRate200.isMouseHere() && sampleRate200.wasPressed) {
            ganglion.setSampleRate(200);
        }

        if (sampleRate1600.isMouseHere() && sampleRate1600.wasPressed) {
            ganglion.setSampleRate(1600);
        }

        if (sampleRate250.isMouseHere() && sampleRate250.wasPressed) {
            cyton.setSampleRate(250);
        }

        if (sampleRate500.isMouseHere() && sampleRate500.wasPressed) {
            cyton.setSampleRate(500);
        }

        if (sampleRate1000.isMouseHere() && sampleRate1000.wasPressed) {
            cyton.setSampleRate(1000);
        }

        if (synthChanButton4.isMouseHere() && synthChanButton4.wasPressed) {
            updateToNChan(4);
        }

        if (synthChanButton8.isMouseHere() && synthChanButton8.wasPressed) {
            updateToNChan(8);
        }

        if (synthChanButton16.isMouseHere() && synthChanButton16.wasPressed) {
            updateToNChan(16);
        }

        if (latencyCyton5ms.isMouseHere() && latencyCyton5ms.wasPressed) {
            hub.setLatency(LATENCY_5_MS);
        }

        if (latencyCyton10ms.isMouseHere() && latencyCyton10ms.wasPressed) {
            hub.setLatency(LATENCY_10_MS);
        }

        if (latencyCyton20ms.isMouseHere() && latencyCyton20ms.wasPressed) {
            hub.setLatency(LATENCY_20_MS);
        }

        if (latencyGanglion5ms.isMouseHere() && latencyGanglion5ms.wasPressed) {
            hub.setLatency(LATENCY_5_MS);
        }

        if (latencyGanglion10ms.isMouseHere() && latencyGanglion10ms.wasPressed) {
            hub.setLatency(LATENCY_10_MS);
        }

        if (latencyGanglion20ms.isMouseHere() && latencyGanglion20ms.wasPressed) {
            hub.setLatency(LATENCY_20_MS);
        }

        if (wifiInternetProtocolCytonTCP.isMouseHere() && wifiInternetProtocolCytonTCP.wasPressed) {
            hub.setWifiInternetProtocol(TCP);
        }

        if (wifiInternetProtocolCytonUDP.isMouseHere() && wifiInternetProtocolCytonUDP.wasPressed) {
            hub.setWifiInternetProtocol(UDP);
        }

        if (wifiInternetProtocolCytonUDPBurst.isMouseHere() && wifiInternetProtocolCytonUDPBurst.wasPressed) {
            hub.setWifiInternetProtocol(UDP_BURST);
        }

        if (wifiInternetProtocolGanglionTCP.isMouseHere() && wifiInternetProtocolGanglionTCP.wasPressed) {
            hub.setWifiInternetProtocol(TCP);
        }

        if (wifiInternetProtocolGanglionUDP.isMouseHere() && wifiInternetProtocolGanglionUDP.wasPressed) {
            hub.setWifiInternetProtocol(UDP);
        }

        if (wifiInternetProtocolGanglionUDPBurst.isMouseHere() && wifiInternetProtocolGanglionUDPBurst.wasPressed) {
            hub.setWifiInternetProtocol(UDP_BURST);
        }

        if (selectPlaybackFile.isMouseHere() && selectPlaybackFile.wasPressed) {
            output("Select a file for playback");
            selectInput("Select a pre-recorded file for playback:", 
                        "playbackFileSelected",
                        new File(settings.guiDataPath + "Recordings"));
        }

        if (selectSDFile.isMouseHere() && selectSDFile.wasPressed) {
            output("Select an SD file to convert to a playback file");
            createPlaybackFileFromSD();
            selectInput("Select an SD file to convert for playback:", "sdFileSelected");
        }

        if (sampleDataButton.isMouseHere() && sampleDataButton.wasPressed) {
            output("Select a file for playback");
            selectInput("Select a pre-recorded file for playback:", 
                        "playbackFileSelected", 
                        new File(settings.guiDataPath + 
                                "Sample_Data" + System.getProperty("file.separator") + 
                                "OpenBCI-sampleData-2-meditation.txt"));
        }

        //reset all buttons to false
        noHubShowDoc.setIsActive(false);
        noHubShowDoc.wasPressed = false;
        refreshPort.setIsActive(false);
        refreshPort.wasPressed = false;
        refreshBLE.setIsActive(false);
        refreshBLE.wasPressed = false;
        refreshWifi.setIsActive(false);
        refreshWifi.wasPressed = false;

        // this button used on mac only
        if (isMac()) {
            protocolBLEGanglion.setIsActive(false);
            protocolBLEGanglion.wasPressed = false;
        }

        protocolBLED112Ganglion.setIsActive(false);
        protocolBLED112Ganglion.wasPressed = false;
        protocolWifiGanglion.setIsActive(false);
        protocolWifiGanglion.wasPressed = false;
        protocolSerialCyton.setIsActive(false);
        protocolSerialCyton.wasPressed = false;
        protocolWifiCyton.setIsActive(false);
        protocolWifiCyton.wasPressed = false;
        initSystemButton.setIsActive(false);
        initSystemButton.wasPressed = false;
        autoSessionName.setIsActive(false);
        autoSessionName.wasPressed = false;
        outputBDF.setIsActive(false);
        outputBDF.wasPressed = false;
        outputODF.setIsActive(false);
        outputODF.wasPressed = false;
        wifiIPAddressDynamic.setIsActive(false);
        wifiIPAddressDynamic.wasPressed = false;
        wifiIPAddressStatic.setIsActive(false);
        wifiIPAddressStatic.wasPressed = false;
        chanButton8.setIsActive(false);
        chanButton8.wasPressed = false;
        sampleRate200.setIsActive(false);
        sampleRate200.wasPressed = false;
        sampleRate1600.setIsActive(false);
        sampleRate1600.wasPressed = false;
        sampleRate250.setIsActive(false);
        sampleRate250.wasPressed = false;
        sampleRate500.setIsActive(false);
        sampleRate500.wasPressed = false;
        sampleRate1000.setIsActive(false);
        sampleRate1000.wasPressed = false;
        latencyCyton5ms.setIsActive(false);
        latencyCyton5ms.wasPressed = false;
        latencyCyton10ms.setIsActive(false);
        latencyCyton10ms.wasPressed = false;
        latencyCyton20ms.setIsActive(false);
        latencyCyton20ms.wasPressed = false;
        latencyGanglion5ms.setIsActive(false);
        latencyGanglion5ms.wasPressed = false;
        latencyGanglion10ms.setIsActive(false);
        latencyGanglion10ms.wasPressed = false;
        latencyGanglion20ms.setIsActive(false);
        latencyGanglion20ms.wasPressed = false;
        wifiInternetProtocolCytonTCP.setIsActive(false);
        wifiInternetProtocolCytonTCP.wasPressed = false;
        wifiInternetProtocolCytonUDP.setIsActive(false);
        wifiInternetProtocolCytonUDP.wasPressed = false;
        wifiInternetProtocolCytonUDPBurst.setIsActive(false);
        wifiInternetProtocolCytonUDPBurst.wasPressed = false;
        wifiInternetProtocolGanglionTCP.setIsActive(false);
        wifiInternetProtocolGanglionTCP.wasPressed = false;
        wifiInternetProtocolGanglionUDP.setIsActive(false);
        wifiInternetProtocolGanglionUDP.wasPressed = false;
        wifiInternetProtocolGanglionUDPBurst.setIsActive(false);
        wifiInternetProtocolGanglionUDPBurst.wasPressed = false;
        synthChanButton4.setIsActive(false);
        synthChanButton4.wasPressed = false;
        synthChanButton8.setIsActive(false);
        synthChanButton8.wasPressed = false;
        synthChanButton16.setIsActive(false);
        synthChanButton16.wasPressed = false;
        chanButton16.setIsActive(false);
        chanButton16.wasPressed  = false;
        selectPlaybackFile.setIsActive(false);
        selectPlaybackFile.wasPressed = false;
        selectSDFile.setIsActive(false);
        selectSDFile.wasPressed = false;
        sampleDataButton.setIsActive(false);
        sampleDataButton.wasPressed = false;
    }
};

public void initButtonPressed(){
    if (initSystemButton.but_txt == "START SESSION") {
        if ((eegDataSource == DATASOURCE_CYTON && cyton.getInterface() == INTERFACE_NONE) || (eegDataSource == DATASOURCE_GANGLION && ganglion.getInterface() == INTERFACE_NONE)) {
            output("No Transfer Protocol selected. Please select your Transfer Protocol and retry system initiation.");
            initSystemButton.wasPressed = false;
            initSystemButton.setIsActive(false);
            return;
        } else if (eegDataSource == DATASOURCE_CYTON && cyton.getInterface() == INTERFACE_SERIAL && openBCI_portName == "N/A") { //if data source == normal && if no serial port selected OR no SD setting selected
            output("No Serial/COM port selected. Please select your Serial/COM port and retry system initiation.");
            initSystemButton.wasPressed = false;
            initSystemButton.setIsActive(false);
            return;
        } else if (eegDataSource == DATASOURCE_CYTON && cyton.getInterface() == INTERFACE_HUB_WIFI && wifi_portName == "N/A" && hub.getWiFiStyle() == WIFI_DYNAMIC) {
            output("No Wifi Shield selected. Please select your Wifi Shield and retry system initiation.");
            initSystemButton.wasPressed = false;
            initSystemButton.setIsActive(false);
            return;
        } else if (eegDataSource == DATASOURCE_PLAYBACKFILE && playbackData_fname == "N/A") { //if data source == playback && playback file == 'N/A'
            output("No playback file selected. Please select a playback file and retry system initiation.");        // tell user that they need to select a file before the system can be started
            initSystemButton.wasPressed = false;
            initSystemButton.setIsActive(false);
            return;
        } else if (eegDataSource == DATASOURCE_GANGLION && (ganglion.getInterface() == INTERFACE_HUB_BLE || ganglion.getInterface() == INTERFACE_HUB_BLED112) && ganglion_portName == "N/A") {
            output("No BLE device selected. Please select your Ganglion device and retry system initiation.");
            initSystemButton.wasPressed = false;
            initSystemButton.setIsActive(false);
            return;
        } else if (eegDataSource == DATASOURCE_GANGLION && ganglion.getInterface() == INTERFACE_HUB_WIFI && wifi_portName == "N/A" && hub.getWiFiStyle() == WIFI_DYNAMIC) {
            output("No Wifi Shield selected. Please select your Wifi Shield and retry system initiation.");
            initSystemButton.wasPressed = false;
            initSystemButton.setIsActive(false);
            return;
        } else if (eegDataSource == -1) {//if no data source selected
            output("No DATA SOURCE selected. Please select a DATA SOURCE and retry system initiation.");//tell user they must select a data source before initiating system
            initSystemButton.wasPressed = false;
            initSystemButton.setIsActive(false);
            return;
        } else if (playbackFileIsEmpty) {
            outputError("Playback file appears empty. Try loading a different file.");
            initSystemButton.wasPressed = false;
            initSystemButton.setIsActive(false);
            return;
        } else { //otherwise, initiate system!
            //verbosePrint("ControlPanel: CPmouseReleased: init");
            initSystemButton.setString("STOP SESSION");
            // Global steps to START SESSION
            // Prepare the serial port
            if (eegDataSource == DATASOURCE_CYTON) {
                verbosePrint("ControlPanel — port is open: " + cyton.isPortOpen());
                if (cyton.isPortOpen() == true) {
                    cyton.closePort();
                }
                sessionName = cp5.get(Textfield.class, "fileNameCyton").getText(); // store the current text field value of "File Name" to be passed along to dataFiles
            } else if(eegDataSource == DATASOURCE_GANGLION){
                verbosePrint("ControlPanel — port is open: " + ganglion.isPortOpen());
                if (ganglion.isPortOpen()) {
                    ganglion.closePort();
                }
                sessionName = cp5.get(Textfield.class, "fileNameGanglion").getText(); // store the current text field value of "File Name" to be passed along to dataFiles
            }

            if (outputDataSource == OUTPUT_SOURCE_ODF && eegDataSource < DATASOURCE_PLAYBACKFILE) {
                settings.setLogFileMaxDuration();
            }

            if (hub.getWiFiStyle() == WIFI_STATIC && (cyton.isWifi() || ganglion.isWifi())) {
                wifi_ipAddress = cp5.get(Textfield.class, "staticIPAddress").getText();
                println("Static IP address of " + wifi_ipAddress);
            }
            midInit = true;
            println("initButtonPressed: Calling initSystem()");
            try {
                initSystem(); //found in OpenBCI_GUI.pde
            } catch (Exception e) {
                println(e.getMessage());
                haltSystem();
            }
        }
    } else {
        //if system is already active ... stop session and flip button state back
        outputInfo("Learn how to use this application and more at openbci.github.io/Documentation/");
        initSystemButton.setString("START SESSION");
        cp5.get(Textfield.class, "fileNameCyton").setText(getDateString()); //creates new data file name so that you don't accidentally overwrite the old one
        cp5.get(Textfield.class, "fileNameGanglion").setText(getDateString()); //creates new data file name so that you don't accidentally overwrite the old one
        cp5.get(Textfield.class, "staticIPAddress").setText(wifi_ipAddress); // Fills the last (or default) IP address
        haltSystem();
    }
}

public void updateToNChan(int _nchan) {
    nchan = _nchan;
    settings.slnchan = _nchan; //used in SoftwareSettings.pde only
    fftBuff = new FFT[nchan];  //reinitialize the FFT buffer
    yLittleBuff_uV = new float[nchan][nPointsPerUpdate];
    println("channel count set to " + str(nchan));
    hub.initDataPackets(_nchan, 3);
    ganglion.initDataPackets(_nchan, 3);
    cyton.initDataPackets(_nchan, 3);
    updateChannelArrays(nchan); //make sure to reinitialize the channel arrays with the right number of channels
}

//==============================================================================//
//                	BELOW ARE THE CLASSES FOR THE VARIOUS                         //
//                	CONTROL PANEL BOXes (control widgets)                        //
//==============================================================================//

class NoHubBox {
    int x, y, w, h, padding; //size and position

    NoHubBox(int _x, int _y, int _w, int _h, int _padding) {
        x = _x;
        y = _y;
        w = _w;
        h = 73;
        padding = _padding;

        noHubShowDoc = new Button (x + padding, y + padding*2 + 13, w - padding*2, 24, "OPENBCI GUI INSTALL GUIDE", fontInfo.buttonLabel_size);
        noHubShowDoc.setURL("https://openbci.github.io/Documentation/docs/06Software/01-OpenBCISoftware/GUIDocs");
    }

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(bgColor);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("HUB NOT CONNECTED", x + padding, y + padding);
        noHubShowDoc.draw();
        popStyle();
    }
};

class DataSourceBox {
    int x, y, w, h, padding; //size and position
    int numItems = 4;
    int boxHeight = 24;
    int spacing = 43;


    CheckBox sourceCheckBox;

    DataSourceBox(int _x, int _y, int _w, int _h, int _padding) {
        x = _x;
        y = _y;
        w = _w;
        h = spacing + (numItems * boxHeight);
        padding = _padding;

        sourceList = new MenuList(cp5, "sourceList", w - padding*2, numItems * boxHeight, p4);
        // sourceList.itemHeight = 28;
        // sourceList.padding = 9;
        sourceList.setPosition(x + padding, y + padding*2 + 13);
        sourceList.addItem(makeItem("LIVE (from Cyton)"));
        sourceList.addItem(makeItem("LIVE (from Ganglion)"));
        sourceList.addItem(makeItem("PLAYBACK (from file)"));
        sourceList.addItem(makeItem("SYNTHETIC (algorithmic)"));

        sourceList.scrollerLength = 10;
    }

    public void update() {

    }

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(bgColor);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("DATA SOURCE", x + padding, y + padding);
        popStyle();
        //draw contents of Data Source Box at top of control panel
        //Title
        //checkboxes of system states
    }
};

class SerialBox {
    int x, y, w, h, padding; //size and position
    Button autoConnect;

    SerialBox(int _x, int _y, int _w, int _h, int _padding) {
        x = _x;
        y = _y;
        w = _w;
        h = 70;
        padding = _padding;

        autoConnect = new Button(x + padding, y + padding*3 + 4, w - padding*3 - 70, 24, "AUTO", fontInfo.buttonLabel_size);
        autoConnect.setHelpText("Attempt to auto-connect to Cyton. Try \"Manual\" if this does not work.");
        popOutRadioConfigButton = new Button(x + w - 70 - padding, y + padding*3 + 4, 70, 24,"Manual >",fontInfo.buttonLabel_size);
        popOutRadioConfigButton.setHelpText("Having trouble connecting to Cyton? Click here to access Radio Configuration tools.");
    }

    public void update() {
    }

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(bgColor);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("SERIAL CONNECT", x + padding, y + padding);
        popStyle();

        if (cyton.isSerial()) {
            popOutRadioConfigButton.draw();
            autoConnect.draw();
        }
    }

    public void attemptAutoConnectCyton() {
        //Fetch the number of com ports...
        int numComPorts = cp5.get(MenuList.class, "serialList").getListSize();
        String _regex = "";
        //Then look for matching cyton dongle
        for (int i = 0; i < numComPorts; i++) {
            String comPort = (String)cp5.get(MenuList.class, "serialList").getItem(i).get("headline");
            if (isMac()) {
                _regex = "^/dev/tty.usbserial-DM.*$";
            } else if (isWindows()) {
                _regex = "COM.*$";
            } else if (isLinux()) {
                _regex = "^/dev/ttyUSB.*$";
            }
            if (ableToConnect(comPort, _regex)) return;
        } //end for loop for all com ports
        
        if (!openBCI_portName.equals("N/A")) {
            outputError("Unable to auto-connect...");
        }
    } //end attempAutoConnectCyton 

    private boolean ableToConnect(String _comPort, String _regex) {
        if (systemMode < SYSTEMMODE_POSTINIT) {
            //There are quite a few serial ports on Linux, but not many that start with /dev/ttyUSB
            String[] foundCytonPort = match(_comPort, _regex);
            if (foundCytonPort != null) {  // If not null, then a match was found
                println("ControlPanel: Attempting to connect to " + _comPort);
                openBCI_portName = foundCytonPort[0];
                initButtonPressed();
                if (systemMode == SYSTEMMODE_POSTINIT) return true;
            }
            return false;
        } else {
            return true;
        }
    }
};

class ComPortBox {
    int x, y, w, h, padding; //size and position
    boolean isShowing;

    ComPortBox(int _x, int _y, int _w, int _h, int _padding) {
        x = _x;
        y = _y;
        w = _w + 10;
        h = 140 + _padding;
        padding = _padding;
        isShowing = false;

        refreshPort = new Button (x + padding, y + padding*4 + 72 + 8, w - padding*2, 24, "REFRESH LIST", fontInfo.buttonLabel_size);
        serialList = new MenuList(cp5, "serialList", w - padding*2, 72, p4);
        // println(w-padding*2);
        serialList.setPosition(x + padding, y + padding*3 + 8);
        serialPorts = Serial.list();
        for (int i = 0; i < serialPorts.length; i++) {
            String tempPort = serialPorts[(serialPorts.length-1) - i]; //list backwards... because usually our port is at the bottom
            serialList.addItem(makeItem(tempPort));
        }
    }

    public void update() {
    }

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(bgColor);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("SERIAL/COM PORT", x + padding, y + padding);
        refreshPort.draw();
        popStyle();
    }
};

class BLEBox {
    int x, y, w, h, padding; //size and position

    BLEBox(int _x, int _y, int _w, int _h, int _padding) {
        x = _x;
        y = _y;
        w = _w;
        h = 140 + _padding;
        padding = _padding;

        refreshBLE = new Button (x + padding, y + padding*4 + 72 + 8, w - padding*5, 24, "START SEARCH", fontInfo.buttonLabel_size);
        bleList = new MenuList(cp5, "bleList", w - padding*2, 72, p4);
        bleList.setPosition(x + padding, y + padding*3 + 8);
    }

    public void update() {
    }

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(bgColor);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("BLE DEVICES", x + padding, y + padding);
        popStyle();

        refreshBLE.draw();

        if(isHubInitialized && isHubObjectInitialized && ganglion.isBLE() && hub.isSearching()){
            image(loadingGIF_blue, w + 225,  y + padding*4 + 72 + 10, 20, 20);
            refreshBLE.setString("SEARCHING...");
        } else {
            refreshBLE.setString("START SEARCH");
        }
    }

    public void refreshBLEList() {
        bleList.items.clear();
        for (int i = 0; i < hub.deviceList.length; i++) {
            String tempPort = hub.deviceList[i];
            bleList.addItem(makeItem(tempPort));
        }
        bleList.updateMenu();
    }
};

class WifiBox {
    int x, y, w, h, padding; //size and position

    WifiBox(int _x, int _y, int _w, int _h, int _padding) {
        x = _x;
        y = _y;
        w = _w;
        h = 184 + _padding;
        padding = _padding;

        wifiIPAddressDynamic = new Button (x + padding, y + padding*2 + 30, (w-padding*3)/2, 24, "DYNAMIC IP", fontInfo.buttonLabel_size);
        if (hub.getWiFiStyle() == WIFI_DYNAMIC) wifiIPAddressDynamic.setColorNotPressed(isSelected_color); //make it appear like this one is already selected
        wifiIPAddressStatic = new Button (x + padding*2 + (w-padding*3)/2, y + padding*2 + 30, (w-padding*3)/2, 24, "STATIC IP", fontInfo.buttonLabel_size);
        if (hub.getWiFiStyle() == WIFI_STATIC) wifiIPAddressStatic.setColorNotPressed(isSelected_color); //make it appear like this one is already selected

        refreshWifi = new Button (x + padding, y + padding*5 + 72 + 8 + 24, w - padding*5, 24, "START SEARCH", fontInfo.buttonLabel_size);
        wifiList = new MenuList(cp5, "wifiList", w - padding*2, 72 + 8, p4);
        popOutWifiConfigButton = new Button(x+padding + (w-padding*4), y + padding, 20,20,">",fontInfo.buttonLabel_size);

        wifiList.setPosition(x + padding, y + padding*4 + 8 + 24);
        // Call to update the list

        cp5.addTextfield("staticIPAddress")
            .setPosition(x + 90, y + 100)
            .setCaptionLabel("")
            .setSize(w - padding*2, 26)
            .setFont(f2)
            .setFocus(false)
            .setColor(color(26, 26, 26))
            .setColorBackground(color(255, 255, 255)) // text field bg color
            .setColorValueLabel(color(0, 0, 0))  // text color
            .setColorForeground(isSelected_color)  // border color when not selected
            .setColorActive(isSelected_color)  // border color when selected
            .setColorCursor(color(26, 26, 26))
            .setText(wifi_ipAddress)
            .align(5, 10, 20, 40)
            .onDoublePress(cb)
            .setAutoClear(true);
    }

    public void update() {
    }

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(bgColor);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("WIFI SHIELDS", x + padding, y + padding);
        wifiIPAddressDynamic.draw();
        wifiIPAddressStatic.draw();
        wifiIPAddressDynamic.but_y = y + padding*2 + 16;
        wifiIPAddressStatic.but_y = wifiIPAddressDynamic.but_y;

        popStyle();

        popOutWifiConfigButton.but_y = y + padding;
        popOutWifiConfigButton.draw();

        if (hub.getWiFiStyle() == WIFI_STATIC) {
            pushStyle();
            fill(bgColor);
            textFont(h3, 16);
            textAlign(LEFT, TOP);
            text("ENTER IP ADDRESS", x + padding, y + h - 24 - 12 - padding*2);
            popStyle();
            cp5.get(Textfield.class, "staticIPAddress").setPosition(x + padding, y + h - 24 - padding);
        } else {
            wifiList.setPosition(x + padding, wifiIPAddressDynamic.but_y + 24 + padding);

            refreshWifi.draw();
            refreshWifi.but_y = y + h - padding - 24;
            if(isHubInitialized && isHubObjectInitialized && (ganglion.isWifi() || cyton.isWifi()) && hub.isSearching()){
                image(loadingGIF_blue, w + 225,  refreshWifi.but_y + 4, 20, 20);
                refreshWifi.setString("SEARCHING...");
            } else {
                refreshWifi.setString("START SEARCH");

                pushStyle();
                fill(0xff999999);
                ellipseMode(CENTER);
                ellipse(w + 225 + 10, refreshWifi.but_y + 12, 12, 12);
                popStyle();
            }
        }
    }

    public void refreshWifiList() {
        println("refreshWifiList");
        wifiList.items.clear();
        if (hub.deviceList != null) {
            for (int i = 0; i < hub.deviceList.length; i++) {
                String tempPort = hub.deviceList[i];
                wifiList.addItem(makeItem(tempPort));
            }
        }
        wifiList.updateMenu();
    }
};

class InterfaceBoxCyton {
    int x, y, w, h, padding; //size and position

    InterfaceBoxCyton(int _x, int _y, int _w, int _h, int _padding) {
        x = _x;
        y = _y;
        w = _w;
        h = (24 + _padding) * 3;
        padding = _padding;

        protocolSerialCyton = new Button (x + padding, y + padding * 3 + 4, w - padding * 2, 24, "Serial (from Dongle)", fontInfo.buttonLabel_size);
        protocolWifiCyton = new Button (x + padding, y + padding * 4 + 24 + 4, w - padding * 2, 24, "Wifi (from Wifi Shield)", fontInfo.buttonLabel_size);
    }

    public void update() {}

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(bgColor);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("PICK TRANSFER PROTOCOL", x + padding, y + padding);
        popStyle();

        protocolSerialCyton.draw();
        protocolWifiCyton.draw();
    }
};

class InterfaceBoxGanglion {
    int x, y, w, h, padding; //size and position

    InterfaceBoxGanglion(int _x, int _y, int _w, int _h, int _padding) {
        x = _x;
        y = _y;
        w = _w;
        padding = _padding;
        h = (24 + _padding) * 3;
        int buttonHeight = 24;

        int paddingCount = 1;
        if (isMac()) {
            protocolBLEGanglion = new Button (x + padding, y + padding * paddingCount + buttonHeight, w - padding * 2, 24, "Bluetooth (Built In)", fontInfo.buttonLabel_size);
            paddingCount ++;
            // Fix height for extra button
            h += padding + buttonHeight;
        }

        protocolBLED112Ganglion = new Button (x + padding, y + padding * paddingCount + buttonHeight * paddingCount, w - padding * 2, 24, "Bluetooth (BLED112 Dongle)", fontInfo.buttonLabel_size);
        paddingCount ++;
        protocolWifiGanglion = new Button (x + padding, y + padding * paddingCount + buttonHeight * paddingCount, w - padding * 2, 24, "Wifi (from Wifi Shield)", fontInfo.buttonLabel_size);
        paddingCount ++;
    }

    public void update() {}

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(bgColor);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("PICK TRANSFER PROTOCOL", x + padding, y + padding);
        popStyle();

        if (isMac()) {
            protocolBLEGanglion.draw();
        }
        protocolWifiGanglion.draw();
        protocolBLED112Ganglion.draw();
    }
};

class SessionDataBox {
    int x, y, w, h, padding; //size and position
    int i; //0 for Cyton, 1 for Ganglion
    String textfieldName;
    final int bdfModeHeight = 127;
    int odfModeHeight;

    ControlP5 cp5_dataLog_dropdown;
    int maxDurTextWidth = 82;
    int maxDurText_x = 0;
    String maxDurDropdownName;
    boolean dropdownWasClicked = false;

    SessionDataBox (int _x, int _y, int _w, int _h, int _padding, int _dataSource) {
        odfModeHeight = bdfModeHeight + 24 + _padding;
        x = _x;
        y = _y;
        w = _w;
        h = odfModeHeight;
        padding = _padding;
        maxDurText_x = x + padding;
        maxDurTextWidth += padding*5 + 1;

        //button to autogenerate file name based on time/date
        autoSessionName = new Button (x + padding, y + 66, w-(padding*2), 24, "GENERATE SESSION NAME", fontInfo.buttonLabel_size);
        autoSessionName.setHelpText("Autogenerate a session name based on the date and time.");
        outputODF = new Button (x + padding, y + padding*2 + 18 + 58, (w-padding*3)/2, 24, "OpenBCI", fontInfo.buttonLabel_size);
        outputODF.setHelpText("Set GUI data output to OpenBCI Data Format (.txt). A new file will be made in the session folder when the data stream is paused or max file duration is reached.");
        //Output source is ODF by default
        if (outputDataSource == OUTPUT_SOURCE_ODF) outputODF.setColorNotPressed(isSelected_color); //make it appear like this one is already selected
        outputBDF = new Button (x + padding*2 + (w-padding*3)/2, y + padding*2 + 18 + 58, (w-padding*3)/2, 24, "BDF+", fontInfo.buttonLabel_size);
        outputBDF.setHelpText("Set GUI data output to BioSemi Data Format (.bdf). All session data is contained in one .bdf file. View using an EDF/BDF browser.");
        if (outputDataSource == OUTPUT_SOURCE_BDF) outputBDF.setColorNotPressed(isSelected_color); //make it appear like this one is already selected

        //This textfield is controlled by the global cp5 instance
        textfieldName = (_dataSource == DATASOURCE_CYTON) ? "fileNameCyton" : "fileNameGanglion";
        cp5.addTextfield(textfieldName)
            .setPosition(x + 60, y + 32)
            .setCaptionLabel("")
            .setSize(187, 26)
            .setFont(f2)
            .setFocus(false)
            .setColor(color(26, 26, 26))
            .setColorBackground(color(255, 255, 255)) // text field bg color
            .setColorValueLabel(color(0, 0, 0))  // text color
            .setColorForeground(isSelected_color)  // border color when not selected
            .setColorActive(isSelected_color)  // border color when selected
            .setColorCursor(color(26, 26, 26))
            .setText(getDateString())
            .align(5, 10, 20, 40)
            .onDoublePress(cb)
            .setAutoClear(true);

        //The OpenBCI data format max duration dropdown is controlled by the local cp5 instance
        cp5_dataLog_dropdown = new ControlP5(ourApplet);
        maxDurDropdownName = (_dataSource == DATASOURCE_CYTON) ? "maxFileDurationCyton" : "maxFileDurationGanglion";
        createDropdown(maxDurDropdownName, Arrays.asList(settings.fileDurations));
        cp5_dataLog_dropdown.setGraphics(ourApplet, 0,0);
        cp5_dataLog_dropdown.get(ScrollableList.class, maxDurDropdownName).setPosition(x + maxDurTextWidth, outputODF.but_y + 24 + padding);
        cp5_dataLog_dropdown.get(ScrollableList.class, maxDurDropdownName).setSize((w-padding*3)/2, (settings.fileDurations.length + 1) * 24);
        cp5_dataLog_dropdown.setAutoDraw(false);
    }

    public void update() {
        openCloseDropdown();
    }

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(bgColor);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("Session Data", x + padding, y + padding);
        textFont(p4, 14);
        text("Name", x + padding, y + padding*2 + 14);
        popStyle();
        cp5.get(Textfield.class, textfieldName).setPosition(x + 60, y + 32);
        autoSessionName.but_y = y + 66;
        autoSessionName.draw();
        outputODF.but_y = y + padding*2 + 18 + 58;
        outputODF.draw();
        outputBDF.but_y = y + padding*2 + 18 + 58;
        outputBDF.draw();
        if (outputDataSource == OUTPUT_SOURCE_ODF) {
            pushStyle();
            //draw backgrounds to dropdown scrollableLists ... unfortunately ControlP5 doesn't have this by default, so we have to hack it to make it look nice...
            fill(bgColor);
            rect(cp5_dataLog_dropdown.getController(maxDurDropdownName).getPosition()[0]-1, cp5_dataLog_dropdown.getController(maxDurDropdownName).getPosition()[1]-1, cp5_dataLog_dropdown.get(ScrollableList.class, maxDurDropdownName).getWidth()+2, cp5_dataLog_dropdown.get(ScrollableList.class, maxDurDropdownName).getHeight()+2);
            fill(bgColor);
            textFont(p4, 14);
            text("Max File Duration", maxDurText_x, outputODF.but_y + outputODF.but_dy + padding*3 - 3);
            popStyle();
            cp5_dataLog_dropdown.get(ScrollableList.class, maxDurDropdownName).setVisible(true);
            cp5_dataLog_dropdown.get(ScrollableList.class, maxDurDropdownName).setPosition(x + maxDurTextWidth, outputODF.but_y + 24 + padding);
            //Dropdown is drawn at the end of ControlPanel.draw()
        }
    }

    public void createDropdown(String name, List<String> _items){

        cp5_dataLog_dropdown.addScrollableList(name)
            .setOpen(false)
            .setColor(settings.dropdownColors)
            /*
            .setColorBackground(color(31,69,110)) // text field bg color
            .setColorValueLabel(color(0))       // text color
            .setColorCaptionLabel(color(255))
            .setColorForeground(color(125))    // border color when not selected
            .setColorActive(color(150, 170, 200))       // border color when selected
            */
            // .setColorCursor(color(26,26,26))

            .setSize(w - padding*2,(_items.size()+1)*24)// + maxFreqList.size())
            .setBarHeight(24) //height of top/primary bar
            .setItemHeight(24) //height of all item/dropdown bars
            .addItems(_items) // used to be .addItems(maxFreqList)
            .setVisible(false)
            ;
        cp5_dataLog_dropdown.getController(name)
            .getCaptionLabel() //the caption label is the text object in the primary bar
            .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
            .setText(settings.fileDurations[settings.defaultOBCIMaxFileSize])
            .setFont(p4)
            .setSize(14)
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(4)
            ;
        cp5_dataLog_dropdown.getController(name)
            .getValueLabel() //the value label is connected to the text objects in the dropdown item bars
            .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
            .setText(settings.fileDurations[settings.defaultOBCIMaxFileSize])
            .setFont(h5)
            .setSize(12) //set the font size of the item bars to 14pt
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(3) //4-pixel vertical offset to center text
            ;
    }

    //Returns: 0 for Cyton, 1 for Ganglion
    public int getBoardType() {
        return i;
    }

    public void setToODFHeight() {
        h = odfModeHeight;
    }

    public void setToBDFHeight() {
        h = bdfModeHeight;
    }

    private void openCloseDropdown() {
        //Close the dropdown if it is open and mouse is no longer over it
        if (cp5_dataLog_dropdown.get(ScrollableList.class, maxDurDropdownName).isOpen()){
            if (!cp5_dataLog_dropdown.getController(maxDurDropdownName).isMouseOver()){
                //println("----Closing dropdown " + maxDurDropdownName);
                cp5_dataLog_dropdown.get(ScrollableList.class, maxDurDropdownName).close();
                lockElements(false);
            }

        }
        // Open the dropdown if it's not open, but not if it was recently clicked
        // Makes sure dropdown stays closed after user selects an option
        if (!dropdownWasClicked) {
            if (!cp5_dataLog_dropdown.get(ScrollableList.class, maxDurDropdownName).isOpen()){
                if (cp5_dataLog_dropdown.getController(maxDurDropdownName).isMouseOver()){
                    //println("++++Opening dropdown " + maxDurDropdownName);
                    cp5_dataLog_dropdown.get(ScrollableList.class, maxDurDropdownName).open();
                    lockElements(true);
                }
            }
        } else {
            // This flag is used to gate opening/closing the dropdown
            dropdownWasClicked = false;
        }
    }

    // True locks elements, False unlocks elements
    public void lockElements (boolean _toggle) {
        if (eegDataSource == DATASOURCE_CYTON) {
            //Cyton for Serial and WiFi (WiFi details are drawn to the right, so no need to lock)
            chanButton8.setIgnoreHover(_toggle);
            chanButton16.setIgnoreHover(_toggle);
            /*
            if (_toggle) {
                cp5.get(MenuList.class, "sdTimes").lock();
            } else {
                cp5.get(MenuList.class, "sdTimes").unlock();
            }
            cp5.get(MenuList.class, "sdTimes").setUpdate(!_toggle);
            */
            if (_toggle) {
                controlPanel.sdBox.cp5_sdBox.get(ScrollableList.class, controlPanel.sdBox.sdBoxDropdownName).lock();
            } else {
                controlPanel.sdBox.cp5_sdBox.get(ScrollableList.class, controlPanel.sdBox.sdBoxDropdownName).unlock();
            }
            controlPanel.sdBox.cp5_sdBox.get(ScrollableList.class, controlPanel.sdBox.sdBoxDropdownName).setUpdate(!_toggle);
        } else {
            //Ganglion + Wifi
            latencyGanglion5ms.setIgnoreHover(_toggle);
            latencyGanglion10ms.setIgnoreHover(_toggle);
            latencyGanglion20ms.setIgnoreHover(_toggle);
            sampleRate200.setIgnoreHover(_toggle);
            sampleRate1600.setIgnoreHover(_toggle);
        }
    }

    public void closeDropdown() {
        cp5_dataLog_dropdown.get(ScrollableList.class, maxDurDropdownName).close();
        dropdownWasClicked = true;
        lockElements(false);
        //println("---- DROPDOWN CLICKED -> CLOSING DROPDOWN");
    }
};
//////////////////////////////////////////////////////////////
// Global functions used by the above SessionDataBox dropdowns
public void maxFileDurationCyton (int n) {
    settings.cytonOBCIMaxFileSize = n;
    controlPanel.dataLogBoxCyton.closeDropdown();
    println("ControlPanel: Cyton Max Recording Duration: " + settings.fileDurations[n]);
}

public void maxFileDurationGanglion (int n) {
    settings.ganglionOBCIMaxFileSize = n;
    controlPanel.dataLogBoxGanglion.closeDropdown();
    println("ControlPanel: Ganglion Max Recording Duration: " + settings.fileDurations[n]);
}
//////////////////////////////////////////////////////////////

class ChannelCountBox {
    int x, y, w, h, padding; //size and position


    ChannelCountBox(int _x, int _y, int _w, int _h, int _padding) {
        x = _x;
        y = _y;
        w = _w;
        h = 73;
        padding = _padding;

        chanButton8 = new Button (x + padding, y + padding*2 + 18, (w-padding*3)/2, 24, "8 CHANNELS", fontInfo.buttonLabel_size);
        if (nchan == 8) chanButton8.setColorNotPressed(isSelected_color); //make it appear like this one is already selected
        chanButton16 = new Button (x + padding*2 + (w-padding*3)/2, y + padding*2 + 18, (w-padding*3)/2, 24, "16 CHANNELS", fontInfo.buttonLabel_size);
        if (nchan == 16) chanButton16.setColorNotPressed(isSelected_color); //make it appear like this one is already selected
    }

    public void update() {
    }

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(bgColor);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("CHANNEL COUNT ", x + padding, y + padding);
        fill(bgColor); //set color to green
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("  (" + str(nchan) + ")", x + padding + 142, y + padding); // print the channel count in green next to the box title
        popStyle();

        chanButton8.draw();
        chanButton8.but_y = y + padding*2 + 18;
        chanButton16.draw();
        chanButton16.but_y = y + padding*2 + 18;
    }
};

class SampleRateGanglionBox {
    int x, y, w, h, padding; //size and position

    SampleRateGanglionBox(int _x, int _y, int _w, int _h, int _padding) {
        x = _x;
        y = _y;
        w = _w;
        h = 73;
        padding = _padding;

        sampleRate200 = new Button (x + padding, y + padding*2 + 18, (w-padding*3)/2, 24, "200Hz", fontInfo.buttonLabel_size);
        sampleRate1600 = new Button (x + padding*2 + (w-padding*3)/2, y + padding*2 + 18, (w-padding*3)/2, 24, "1600Hz", fontInfo.buttonLabel_size);
        sampleRate1600.setColorNotPressed(isSelected_color); //make it appear like this one is already selected
    }

    public void update() {
    }

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(bgColor);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("SAMPLE RATE ", x + padding, y + padding);
        fill(bgColor); //set color to green
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("  " + str((int)ganglion.getSampleRate()) + "Hz", x + padding + 142, y + padding); // print the channel count in green next to the box title
        popStyle();

        sampleRate200.draw();
        sampleRate1600.draw();
        sampleRate200.but_y = y + padding*2 + 18;
        sampleRate1600.but_y = sampleRate200.but_y;
    }
};

class SampleRateCytonBox {
    int x, y, w, h, padding; //size and position

    SampleRateCytonBox(int _x, int _y, int _w, int _h, int _padding) {
        x = _x;
        y = _y;
        w = _w;
        h = 73;
        padding = _padding;

        sampleRate250 = new Button (x + padding, y + padding*2 + 18, (w-padding*4)/3, 24, "250Hz", fontInfo.buttonLabel_size);
        sampleRate500 = new Button (x + padding*2 + (w-padding*4)/3, y + padding*2 + 18, (w-padding*4)/3, 24, "500Hz", fontInfo.buttonLabel_size);
        sampleRate1000 = new Button (x + padding*3 + ((w-padding*4)/3)*2, y + padding*2 + 18, (w-padding*4)/3, 24, "1000Hz", fontInfo.buttonLabel_size);
        sampleRate1000.setColorNotPressed(isSelected_color); //make it appear like this one is already selected
    }

    public void update() {
    }

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(bgColor);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("SAMPLE RATE ", x + padding, y + padding);
        fill(bgColor); //set color to green
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("  " + str((int)cyton.getSampleRate()) + "Hz", x + padding + 142, y + padding); // print the channel count in green next to the box title
        popStyle();

        sampleRate250.draw();
        sampleRate500.draw();
        sampleRate1000.draw();
        sampleRate250.but_y = y + padding*2 + 18;
        sampleRate500.but_y = sampleRate250.but_y;
        sampleRate1000.but_y = sampleRate250.but_y;
    }
};

class LatencyGanglionBox {
    int x, y, w, h, padding; //size and position

    LatencyGanglionBox(int _x, int _y, int _w, int _h, int _padding) {
        x = _x;
        y = _y;
        w = _w;
        h = 73;
        padding = _padding;

        latencyGanglion5ms = new Button (x + padding, y + padding*2 + 18, (w-padding*4)/3, 24, "5ms", fontInfo.buttonLabel_size);
        if (hub.getLatency() == LATENCY_5_MS) latencyGanglion5ms.setColorNotPressed(isSelected_color); //make it appear like this one is already selected
        latencyGanglion10ms = new Button (x + padding*2 + (w-padding*4)/3, y + padding*2 + 18, (w-padding*4)/3, 24, "10ms", fontInfo.buttonLabel_size);
        if (hub.getLatency() == LATENCY_10_MS) latencyGanglion10ms.setColorNotPressed(isSelected_color); //make it appear like this one is already selected
        latencyGanglion20ms = new Button (x + padding*3 + ((w-padding*4)/3)*2, y + padding*2 + 18, (w-padding*4)/3, 24, "20ms", fontInfo.buttonLabel_size);
        if (hub.getLatency() == LATENCY_20_MS) latencyGanglion20ms.setColorNotPressed(isSelected_color); //make it appear like this one is already selected
    }

    public void update() {
    }

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(bgColor);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("LATENCY ", x + padding, y + padding);
        fill(bgColor); //set color to green
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("  " + str(hub.getLatency()/1000) + "ms", x + padding + 142, y + padding); // print the channel count in green next to the box title
        popStyle();

        latencyGanglion5ms.draw();
        latencyGanglion10ms.draw();
        latencyGanglion20ms.draw();
        latencyGanglion5ms.but_y = y + padding*2 + 18;
        latencyGanglion10ms.but_y = latencyGanglion5ms.but_y;
        latencyGanglion20ms.but_y = latencyGanglion5ms.but_y;
    }
};

class LatencyCytonBox {
    int x, y, w, h, padding; //size and position

    LatencyCytonBox(int _x, int _y, int _w, int _h, int _padding) {
        x = _x;
        y = _y;
        w = _w;
        h = 73;
        padding = _padding;

        latencyCyton5ms = new Button (x + padding, y + padding*2 + 18, (w-padding*4)/3, 24, "5ms", fontInfo.buttonLabel_size);
        if (hub.getLatency() == LATENCY_5_MS) latencyCyton5ms.setColorNotPressed(isSelected_color); //make it appear like this one is already selected
        latencyCyton10ms = new Button (x + padding*2 + (w-padding*4)/3, y + padding*2 + 18, (w-padding*4)/3, 24, "10ms", fontInfo.buttonLabel_size);
        if (hub.getLatency() == LATENCY_10_MS) latencyCyton10ms.setColorNotPressed(isSelected_color); //make it appear like this one is already selected
        latencyCyton20ms = new Button (x + padding*3 + ((w-padding*4)/3)*2, y + padding*2 + 18, (w-padding*4)/3, 24, "20ms", fontInfo.buttonLabel_size);
        if (hub.getLatency() == LATENCY_20_MS) latencyCyton20ms.setColorNotPressed(isSelected_color); //make it appear like this one is already selected
    }

    public void update() {
    }

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(bgColor);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("LATENCY ", x + padding, y + padding);
        fill(bgColor); //set color to green
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("  " + str(hub.getLatency()/1000) + "ms", x + padding + 142, y + padding); // print the channel count in green next to the box title
        popStyle();

        latencyCyton5ms.draw();
        latencyCyton10ms.draw();
        latencyCyton20ms.draw();
        latencyCyton5ms.but_y = y + padding*2 + 18;
        latencyCyton10ms.but_y = latencyCyton5ms.but_y;
        latencyCyton20ms.but_y = latencyCyton5ms.but_y;
    }
};

class WifiTransferProtcolGanglionBox {
    int x, y, w, h, padding; //size and position

    WifiTransferProtcolGanglionBox(int _x, int _y, int _w, int _h, int _padding) {
        x = _x;
        y = _y;
        w = _w;
        h = 73;
        padding = _padding;

        wifiInternetProtocolGanglionTCP = new Button (x + padding, y + padding*2 + 18, (w-padding*4)/3, 24, "TCP", fontInfo.buttonLabel_size);
        if (hub.getWifiInternetProtocol().equals(TCP)) wifiInternetProtocolGanglionTCP.setColorNotPressed(isSelected_color); //make it appear like this one is already selected
        wifiInternetProtocolGanglionUDP = new Button (x + padding*2 + (w-padding*4)/3, y + padding*2 + 18, (w-padding*4)/3, 24, "UDP", fontInfo.buttonLabel_size);
        if (hub.getWifiInternetProtocol().equals(UDP)) wifiInternetProtocolGanglionUDP.setColorNotPressed(isSelected_color); //make it appear like this one is already selected
        wifiInternetProtocolGanglionUDPBurst = new Button (x + padding*3 + ((w-padding*4)/3)*2, y + padding*2 + 18, (w-padding*4)/3, 24, "UDPx3", fontInfo.buttonLabel_size);
        if (hub.getWifiInternetProtocol().equals(UDP_BURST)) wifiInternetProtocolGanglionUDPBurst.setColorNotPressed(isSelected_color); //make it appear like this one is already selected
    }

    public void update() {
    }

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(bgColor);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("WiFi Transfer Protocol ", x + padding, y + padding);
        fill(bgColor); //set color to green
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        String dispText;
        if (hub.getWifiInternetProtocol().equals(TCP)) {
            dispText = "TCP";
        } else if (hub.getWifiInternetProtocol().equals(UDP)) {
            dispText = "UDP";
        } else {
            dispText = "UDPx3";
        }
        text(dispText, x + padding + 184, y + padding); // print the channel count in green next to the box title
        popStyle();

        wifiInternetProtocolGanglionTCP.draw();
        wifiInternetProtocolGanglionUDP.draw();
        wifiInternetProtocolGanglionUDPBurst.draw();
        wifiInternetProtocolGanglionTCP.but_y = y + padding*2 + 18;
        wifiInternetProtocolGanglionUDP.but_y = wifiInternetProtocolGanglionTCP.but_y;
        wifiInternetProtocolGanglionUDPBurst.but_y = wifiInternetProtocolGanglionTCP.but_y;
    }
};

class WifiTransferProtcolCytonBox {
    int x, y, w, h, padding; //size and position

    WifiTransferProtcolCytonBox(int _x, int _y, int _w, int _h, int _padding) {
        x = _x;
        y = _y;
        w = _w;
        h = 73;
        padding = _padding;

        wifiInternetProtocolCytonTCP = new Button (x + padding, y + padding*2 + 18, (w-padding*4)/3, 24, "TCP", fontInfo.buttonLabel_size);
        if (hub.getWifiInternetProtocol().equals(TCP)) wifiInternetProtocolCytonTCP.setColorNotPressed(isSelected_color); //make it appear like this one is already selected
        wifiInternetProtocolCytonUDP = new Button (x + padding*2 + (w-padding*4)/3, y + padding*2 + 18, (w-padding*4)/3, 24, "UDP", fontInfo.buttonLabel_size);
        if (hub.getWifiInternetProtocol().equals(UDP)) wifiInternetProtocolCytonUDP.setColorNotPressed(isSelected_color); //make it appear like this one is already selected
        wifiInternetProtocolCytonUDPBurst = new Button (x + padding*3 + ((w-padding*4)/3)*2, y + padding*2 + 18, (w-padding*4)/3, 24, "UDPx3", fontInfo.buttonLabel_size);
        if (hub.getWifiInternetProtocol().equals(UDP_BURST)) wifiInternetProtocolCytonUDPBurst.setColorNotPressed(isSelected_color); //make it appear like this one is already selected
    }

    public void update() {
    }

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(bgColor);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("WiFi Transfer Protocol ", x + padding, y + padding);
        fill(bgColor); //set color to green
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        String dispText;
        if (hub.getWifiInternetProtocol().equals(TCP)) {
            dispText = "TCP";
        } else if (hub.getWifiInternetProtocol().equals(UDP)) {
            dispText = "UDP";
        } else {
            dispText = "UDPx3";
        }
        text(dispText, x + padding + 184, y + padding); // print the channel count in green next to the box title
        popStyle();

        wifiInternetProtocolCytonTCP.draw();
        wifiInternetProtocolCytonUDP.draw();
        wifiInternetProtocolCytonUDPBurst.draw();
        wifiInternetProtocolCytonTCP.but_y = y + padding*2 + 18;
        wifiInternetProtocolCytonUDP.but_y = wifiInternetProtocolCytonTCP.but_y;
        wifiInternetProtocolCytonUDPBurst.but_y = wifiInternetProtocolCytonTCP.but_y;
    }
};

class SyntheticChannelCountBox {
    int x, y, w, h, padding; //size and position

    SyntheticChannelCountBox(int _x, int _y, int _w, int _h, int _padding) {
        x = _x;
        y = _y;
        w = _w;
        h = 73;
        padding = _padding;

        synthChanButton4 = new Button (x + padding, y + padding*2 + 18, (w-padding*4)/3, 24, "4 chan", fontInfo.buttonLabel_size);
        if (nchan == 4) synthChanButton4.setColorNotPressed(isSelected_color); //make it appear like this one is already selected
        synthChanButton8 = new Button (x + padding*2 + (w-padding*4)/3, y + padding*2 + 18, (w-padding*4)/3, 24, "8 chan", fontInfo.buttonLabel_size);
        if (nchan == 8) synthChanButton8.setColorNotPressed(isSelected_color); //make it appear like this one is already selected
        synthChanButton16 = new Button (x + padding*3 + ((w-padding*4)/3)*2, y + padding*2 + 18, (w-padding*4)/3, 24, "16 chan", fontInfo.buttonLabel_size);
        if (nchan == 16) synthChanButton16.setColorNotPressed(isSelected_color); //make it appear like this one is already selected
    }

    public void update() {
    }

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(bgColor);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("CHANNEL COUNT", x + padding, y + padding);
        fill(bgColor); //set color to green
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("  (" + str(nchan) + ")", x + padding + 142, y + padding); // print the channel count in green next to the box title
        popStyle();

        synthChanButton4.draw();
        synthChanButton8.draw();
        synthChanButton16.draw();
    }
};

class RecentPlaybackBox {
    int x, y, w, h, padding; //size and position
    StringList shortFileNames = new StringList();
    StringList longFilePaths = new StringList();
    private String filePickedShort = "Select Recent Playback File";
    ControlP5 cp5_recentPlayback_dropdown;

    RecentPlaybackBox(int _x, int _y, int _w, int _h, int _padding) {
        x = _x;
        y = _y;
        w = _w;
        h = 67;
        padding = _padding;

        cp5_recentPlayback_dropdown = new ControlP5(ourApplet);
        getRecentPlaybackFiles();

        String[] temp = shortFileNames.array();
        createDropdown("recentFiles", Arrays.asList(temp));
        cp5_recentPlayback_dropdown.setGraphics(ourApplet, 0,0);
        cp5_recentPlayback_dropdown.get(ScrollableList.class, "recentFiles").setPosition(x + padding, y + padding*2 + 13);
        cp5_recentPlayback_dropdown.get(ScrollableList.class, "recentFiles").setSize(w - padding*2, (temp.length + 1) * 24);
        cp5_recentPlayback_dropdown.setAutoDraw(false);
    }

    /////*Update occurs while control panel is open*/////
    public void update() {
        //Update the dropdown list if it has not already been done
        if (!recentPlaybackFilesHaveUpdated) {
            cp5_recentPlayback_dropdown.get(ScrollableList.class, "recentFiles").clear();
            getRecentPlaybackFiles();
            String[] temp = shortFileNames.array();
            cp5_recentPlayback_dropdown.get(ScrollableList.class, "recentFiles").addItems(temp);
            cp5_recentPlayback_dropdown.get(ScrollableList.class, "recentFiles").setSize(w - padding*2, (temp.length + 1) * 24);
        }
    }

    public String getFilePickedShort() {
        return filePickedShort;
    }

    public void setFilePickedShort(String _fileName) {
        filePickedShort = _fileName;
    }

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h + cp5_recentPlayback_dropdown.getController("recentFiles").getHeight() - padding*2);
        fill(bgColor);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("PLAYBACK HISTORY", x + padding, y + padding);
        popStyle();
        cp5_recentPlayback_dropdown.get(ScrollableList.class, "recentFiles").setVisible(true);
        cp5_recentPlayback_dropdown.draw();
    }

    private void getRecentPlaybackFiles() {
        int numFilesToShow = 10;
        try {
            JSONObject playbackHistory = loadJSONObject(userPlaybackHistoryFile);
            JSONArray recentFilesArray = playbackHistory.getJSONArray("playbackFileHistory");
            if (recentFilesArray.size() < 10) {
                println("CP: Playback History Size = " + recentFilesArray.size());
                numFilesToShow = recentFilesArray.size();
            }
            shortFileNames.clear();
            longFilePaths.clear();
            for (int i = numFilesToShow - 1; i >= 0; i--) {
                JSONObject playbackFile = recentFilesArray.getJSONObject(i);
                String shortFileName = playbackFile.getString("id");
                String longFilePath = playbackFile.getString("filePath");
                //truncate display name, if needed
                shortFileName = shortenString(shortFileName, w-padding*2.f, h3);
                //store to arrays to set recent playback buttons text and function
                shortFileNames.append(shortFileName);
                longFilePaths.append(longFilePath);
                //println(shortFileName + " " + longFilePath);
            }

            playbackHistoryFileExists = true;
        } catch (Exception e) {
            println("OpenBCI_GUI::Control Panel: Playback history file not found or other error.");
            playbackHistoryFileExists = false;
        }
        recentPlaybackFilesHaveUpdated = true;
    }

    public void closeAllDropdowns(){
        cp5_recentPlayback_dropdown.get(ScrollableList.class, "recentFiles").close();
    }

    public void createDropdown(String name, List<String> _items){

        cp5_recentPlayback_dropdown.addScrollableList(name)
            .setOpen(false)
            .setColorBackground(color(31,69,110)) // text field bg color
            .setColorValueLabel(color(255))       // text color
            .setColorCaptionLabel(color(255))
            .setColorForeground(color(125))    // border color when not selected
            .setColorActive(color(150, 170, 200))       // border color when selected
            // .setColorCursor(color(26,26,26))

            .setSize(w - padding*2,(_items.size()+1)*24)// + maxFreqList.size())
            .setBarHeight(24) //height of top/primary bar
            .setItemHeight(24) //height of all item/dropdown bars
            .addItems(_items) // used to be .addItems(maxFreqList)
            .setVisible(false)
            ;
        cp5_recentPlayback_dropdown.getController(name)
            .getCaptionLabel() //the caption label is the text object in the primary bar
            .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
            .setText(filePickedShort)
            .setFont(h4)
            .setSize(14)
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(4)
            ;
        cp5_recentPlayback_dropdown.getController(name)
            .getValueLabel() //the value label is connected to the text objects in the dropdown item bars
            .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
            .setText(filePickedShort)
            .setFont(h5)
            .setSize(12) //set the font size of the item bars to 14pt
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(3) //4-pixel vertical offset to center text
            ;
    }
};

class PlaybackFileBox {
    int x, y, w, h, padding; //size and position
    int sampleDataButton_w = 100;
    int sampleDataButton_h = 20;

    PlaybackFileBox(int _x, int _y, int _w, int _h, int _padding) {
        x = _x;
        y = _y;
        w = _w;
        h = 67;
        padding = _padding;

        selectPlaybackFile = new Button (x + padding, y + padding*2 + 13, w - padding*2, 24, "SELECT PLAYBACK FILE", fontInfo.buttonLabel_size);
        selectPlaybackFile.setHelpText("Click to open a dialog box to select an OpenBCI playback file (.txt or .csv).");
    
        // Sample data button
        sampleDataButton = new Button(x + w - sampleDataButton_w - padding, y + padding - 2, sampleDataButton_w, sampleDataButton_h, "Sample Data", 14);
        sampleDataButton.setCornerRoundess((int)(sampleDataButton_h));
        sampleDataButton.setFont(p4, 14);
        sampleDataButton.setColorNotPressed(color(57,128,204));
        sampleDataButton.setFontColorNotActive(color(255));
        sampleDataButton.setHelpText("Click to open the folder containing OpenBCI GUI Sample Data.");
        sampleDataButton.hasStroke(false);
    }

    public void update() {
    }

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(bgColor);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("PLAYBACK FILE", x + padding, y + padding);
        popStyle();

        selectPlaybackFile.draw();
        sampleDataButton.draw();
    }
};

class SDBox {
    final private String sdBoxDropdownName = "sdCardTimes";
    final private String[] sdTimesStrings = {
                        "Do not write to SD...", 
                        "5 minute maximum", 
                        "15 minute maximum", 
                        "30 minute maximum",
                        "1 hour maximum",
                        "2 hours maximum",
                        "4 hour maximum",
                        "12 hour maximum",
                        "24 hour maximum"
                        };
    int x, y, w, h, padding; //size and position
    ControlP5 cp5_sdBox;
    boolean dropdownWasClicked = false;

    SDBox(int _x, int _y, int _w, int _h, int _padding) {
        x = _x;
        y = _y;
        w = _w;
        h = 73;
        padding = _padding;

        cp5_sdBox = new ControlP5(ourApplet);
        createDropdown(sdBoxDropdownName, Arrays.asList(sdTimesStrings));
        cp5_sdBox.setGraphics(ourApplet, 0,0);
        cp5_sdBox.get(ScrollableList.class, sdBoxDropdownName).setPosition(x + padding, y + padding*2 + 14);
        cp5_sdBox.get(ScrollableList.class, sdBoxDropdownName).setSize(w - padding*2, PApplet.parseInt((sdTimesStrings.length / 2) + 1) * 24);
        cp5_sdBox.setAutoDraw(false);
        //sdTimes = new MenuList(cp5, "sdTimes", w - padding*2, 108, p4);
        //sdTimes.setPosition(x + padding, y + padding*2 + 13);
        
        serialPorts = Serial.list();

        /*
        //add items for the various SD times
        sdTimes.addItem(makeItem("Do not write to SD..."));
        sdTimes.addItem(makeItem("5 minute maximum"));
        sdTimes.addItem(makeItem("15 minute maximum"));
        sdTimes.addItem(makeItem("30 minute maximum"));
        sdTimes.addItem(makeItem("1 hour maximum"));
        sdTimes.addItem(makeItem("2 hours maximum"));
        sdTimes.addItem(makeItem("4 hour maximum"));
        sdTimes.addItem(makeItem("12 hour maximum"));
        sdTimes.addItem(makeItem("24 hour maximum"));

        sdTimes.activeItem = sdSetting; //added to indicate default choice (sdSetting is in OpenBCI_GUI)
        */
    }

    public void update() {
        openCloseDropdown();
    }

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(bgColor);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("WRITE TO SD CARD?", x + padding, y + padding);
        //draw backgrounds to dropdown scrollableLists ... unfortunately ControlP5 doesn't have this by default, so we have to hack it to make it look nice...
        popStyle();

        pushStyle();
        fill(150);
        rect(cp5_sdBox.getController(sdBoxDropdownName).getPosition()[0]-1, cp5_sdBox.getController(sdBoxDropdownName).getPosition()[1]-1, cp5_sdBox.get(ScrollableList.class, sdBoxDropdownName).getWidth()+2, cp5_sdBox.get(ScrollableList.class, sdBoxDropdownName).getHeight()+2);
        //cp5_sdBox.draw();
        popStyle();

        //set the correct position of the dropdown and make it visible if the SDBox class is being drawn
        cp5_sdBox.get(ScrollableList.class, sdBoxDropdownName).setPosition(x + padding, y + padding*2 + 14);
        cp5_sdBox.get(ScrollableList.class, sdBoxDropdownName).setVisible(true);
        cp5_sdBox.draw();
        
        //sdTimes.setPosition(x + padding, y + padding*2 + 13);
        //the drawing of the sdTimes is handled earlier in ControlPanel.draw()
    }

    public void createDropdown(String name, List<String> _items){

        cp5_sdBox.addScrollableList(name)
            .setOpen(false)
            .setColor(settings.dropdownColors)
            /*
            .setColorBackground(color(31,69,110)) // text field bg color
            .setColorValueLabel(color(0))       // text color
            .setColorCaptionLabel(color(255))
            .setColorForeground(color(125))    // border color when not selected
            .setColorActive(color(150, 170, 200))       // border color when selected
            */
            // .setColorCursor(color(26,26,26))

            .setSize(w - padding*2,(_items.size()+1)*24)// + maxFreqList.size())
            .setBarHeight(24) //height of top/primary bar
            .setItemHeight(24) //height of all item/dropdown bars
            .addItems(_items) // used to be .addItems(maxFreqList)
            .setVisible(false)
            ;
        cp5_sdBox.getController(name)
            .getCaptionLabel() //the caption label is the text object in the primary bar
            .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
            .setText(sdTimesStrings[0])
            .setFont(p4)
            .setSize(14)
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(4)
            ;
        cp5_sdBox.getController(name)
            .getValueLabel() //the value label is connected to the text objects in the dropdown item bars
            .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
            .setText(sdTimesStrings[0])
            .setFont(h5)
            .setSize(12) //set the font size of the item bars to 14pt
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(3) //4-pixel vertical offset to center text
            ;
    }

    private void openCloseDropdown() {
        //Close the dropdown if it is open and mouse is no longer over it
        if (cp5_sdBox.get(ScrollableList.class, sdBoxDropdownName).isOpen()){
            if (!cp5_sdBox.getController(sdBoxDropdownName).isMouseOver()){
                //println("----Closing dropdown " + maxDurDropdownName);
                cp5_sdBox.get(ScrollableList.class, sdBoxDropdownName).close();
                //lockElements(false);
            }

        }
        // Open the dropdown if it's not open, but not if it was recently clicked
        // Makes sure dropdown stays closed after user selects an option
        if (!dropdownWasClicked) {
            if (!cp5_sdBox.get(ScrollableList.class, sdBoxDropdownName).isOpen()){
                if (cp5_sdBox.getController(sdBoxDropdownName).isMouseOver()){
                    //println("++++Opening dropdown " + maxDurDropdownName);
                    cp5_sdBox.get(ScrollableList.class, sdBoxDropdownName).open();
                    //lockElements(true);
                }
            }
        } else {
            // This flag is used to gate opening/closing the dropdown
            dropdownWasClicked = false;
        }
    }

    public void closeDropdown() {
        cp5_sdBox.get(ScrollableList.class, sdBoxDropdownName).close();
        dropdownWasClicked = true;
        //lockElements(false);
        //println("---- DROPDOWN CLICKED -> CLOSING DROPDOWN");
    }
};

//////////////////////////////////////////////////////////////
// Global function used by the above SDBox dropdown
public void sdCardTimes (int n) {
    //settings.cytonOBCIMaxFileSize = n;
    sdSetting = n;
    if (sdSetting != 0) {
        output("OpenBCI microSD Setting = " + controlPanel.sdBox.sdTimesStrings[n] + " recording time");
    } else {
        output("OpenBCI microSD Setting = " + controlPanel.sdBox.sdTimesStrings[n]);
    }
    verbosePrint("SD setting = " + controlPanel.sdBox.sdTimesStrings[n]);

    controlPanel.sdBox.closeDropdown();
    //println("ControlPanel: Cyton SD Card Duration: " + controlPanel.sdBox.sdTimesStrings[n]);
}

class RadioConfigBox {
    int x, y, w, h, padding; //size and position
    String initial_message = "Having trouble connecting to your Cyton? Try AutoScan!\n\nUse this tool to get Cyton status or change settings.";
    String last_message = initial_message;
    public boolean isShowing;

    RadioConfigBox(int _x, int _y, int _w, int _h, int _padding) {
        x = _x + _w;
        y = _y;
        w = _w + 10;
        h = 275; //255 + 20 for larger autoscan button
        padding = _padding;
        isShowing = false;
        
        getChannel = new Button(x + padding, y + padding*3 + 18 + 24, (w-padding*3)/2, 24, "GET CHANNEL", fontInfo.buttonLabel_size);
        systemStatus = new Button(x + padding, y + padding*2 + 18, (w-padding*3)/2, 24, "STATUS", fontInfo.buttonLabel_size);
        setChannel = new Button(x + 2*padding + (w-padding*3)/2, y + padding*2 + 18, (w-padding*3)/2, 24, "CHANGE CHAN.", fontInfo.buttonLabel_size);
        ovrChannel = new Button(x + 2*padding + (w-padding*3)/2, y + padding*3 + 18 + 24, (w-padding*3)/2, 24, "OVERRIDE DONGLE", fontInfo.buttonLabel_size);
        //typical button height + 20 for larger autoscan button
        autoscan = new Button(x + padding, y + padding*4 + 18 + 24*2, w-(padding*2), 24 + 20, "AUTOSCAN", fontInfo.buttonLabel_size);

        //Set help text
        getChannel.setHelpText("Get the current channel of your Cyton and USB Dongle.");
        setChannel.setHelpText("Change the channel of your Cyton and USB Dongle.");
        ovrChannel.setHelpText("Change the channel of the USB Dongle only.");
        autoscan.setHelpText("Scan through channels and connect to a nearby Cyton. This button solves most connection issues!");
        systemStatus.setHelpText("Get the connection status of your Cyton system.");
    }
    public void update() {}

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(bgColor);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("RADIO CONFIGURATION", x + padding, y + padding);
        popStyle();
        getChannel.draw();
        setChannel.draw();
        ovrChannel.draw();
        systemStatus.draw();
        autoscan.draw();

        this.print_onscreen(last_message);
    }

    public void print_onscreen(String localstring){
        textAlign(LEFT);
        fill(bgColor);
        rect(x + padding, y + (padding*8) + 33 + (24*2), w-(padding*2), 135 - 21 - padding); //13 + 20 = 33 for larger autoscan
        fill(255);
        textFont(h3, 15);
        text(localstring, x + padding + 5, y + (padding*8) + 5 + (24*2) + 35, (w-padding*3 ), 135 - 24 - padding -15); //15 + 20 = 35
        this.last_message = localstring;
    }
};

class WifiConfigBox {
    int x, y, w, h, padding; //size and position
    String last_message = "";
    boolean isShowing;

    WifiConfigBox(int _x, int _y, int _w, int _h, int _padding) {
        x = _x + _w;
        y = _y;
        w = _w;
        h = 255;
        padding = _padding;
        isShowing = false;

        getTypeOfAttachedBoard = new Button(x + padding, y + padding*2 + 18, (w-padding*3)/2, 24, "OPENBCI BOARD", fontInfo.buttonLabel_size);
        getIpAddress = new Button(x + 2*padding + (w-padding*3)/2, y + padding*2 + 18, (w-padding*3)/2, 24, "IP ADDRESS", fontInfo.buttonLabel_size);
        getMacAddress = new Button(x + padding, y + padding*3 + 18 + 24, (w-padding*3)/2, 24, "MAC ADDRESS", fontInfo.buttonLabel_size);
        getFirmwareVersion = new Button(x + 2*padding + (w-padding*3)/2, y + padding*3 + 18 + 24, (w-padding*3)/2, 24, "FIRMWARE VERS.", fontInfo.buttonLabel_size);
        eraseCredentials = new Button(x + padding, y + padding*4 + 18 + 24*2, w-(padding*2), 24, "ERASE NETWORK CREDENTIALS", fontInfo.buttonLabel_size);

        //Set help text
        getTypeOfAttachedBoard.setHelpText("Get the type of OpenBCI board attached to the WiFi Shield");
        getIpAddress.setHelpText("Get the IP Address of the WiFi shield");
        getMacAddress.setHelpText("Get the MAC Address of the WiFi shield");
        getFirmwareVersion.setHelpText("Get the firmware version of the WiFi Shield");
        eraseCredentials.setHelpText("Erase the store credentials on the WiFi Shield to join another wireless network. Always remove WiFi Shield from OpenBCI board prior to erase and WiFi Shield will become a hotspot again.");
    }
    public void update() {}

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(bgColor);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("WIFI CONFIGURATION", x + padding, y + padding);
        popStyle();
        getTypeOfAttachedBoard.draw();
        getIpAddress.draw();
        getMacAddress.draw();
        getFirmwareVersion.draw();
        eraseCredentials.draw();

        this.print_onscreen(last_message);
    }

    public void updateMessage(String str) {
        last_message = str;
    }

    public void print_onscreen(String localstring){
        textAlign(LEFT);
        fill(bgColor);
        rect(x + padding, y + (padding*8) + 13 + (24*2), w-(padding*2), 135 - 21 - padding);
        fill(255);
        textFont(h3, 15);
        text(localstring, x + padding + 10, y + (padding*8) + 5 + (24*2) + 15, (w-padding*3 ), 135 - 24 - padding -15);
    }
};

class SDConverterBox {
    int x, y, w, h, padding; //size and position

    SDConverterBox(int _x, int _y, int _w, int _h, int _padding) {
        x = _x;
        y = _y;
        w = _w;
        h = 67;
        padding = _padding;

        selectSDFile = new Button (x + padding, y + padding*2 + 13, w - padding*2, 24, "SELECT SD FILE", fontInfo.buttonLabel_size);
        selectSDFile.setHelpText("Click here to select an SD file generated by Cyton or Cyton+Daisy and convert to plain text format.");
    }

    public void update() {
    }

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(bgColor);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("CONVERT SD FOR PLAYBACK", x + padding, y + padding);
        popStyle();

        selectSDFile.draw();
    }
};

class ChannelPopup {
    int x, y, w, h, padding; //size and position
    boolean clicked;
    String title = "";

    ChannelPopup(int _x, int _y, int _w, int _h, int _padding) {
        x = _x + _w * 2;
        y = _y;
        w = _w;
        h = 171 + _padding;
        padding = _padding;
        clicked = false;

        channelList = new MenuList(cp5Popup, "channelListCP", w - padding*2, 140, p4);
        channelList.setPosition(x+padding, y+padding*3);

        for (int i = 1; i < 26; i++) {
            channelList.addItem(makeItem(String.valueOf(i)));
        }
    }

    public void update() {
    }

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(bgColor);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text(title, x + padding, y + padding);
        popStyle();
    }

    public void setClicked(boolean click) { this.clicked = click; }
    public boolean wasClicked() { return this.clicked; }
    public void setTitle(String s) { title = s; }
};

class PollPopup {
    int x, y, w, h, padding; //size and position
    boolean clicked;

    PollPopup(int _x, int _y, int _w, int _h, int _padding) {
        x = _x + _w * 2;
        y = _y;
        w = _w;
        h = 171 + _padding;
        padding = _padding;
        clicked = false;

        pollList = new MenuList(cp5Popup, "pollList", w - padding*2, 140, p4);
        pollList.setPosition(x+padding, y+padding*3);

        for (int i = 0; i < 256; i++) {
            pollList.addItem(makeItem(String.valueOf(i)));
        }
    }

    public void update() {
    }

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        fill(bgColor);
        textFont(h3, 16);
        textAlign(LEFT, TOP);
        text("POLL SELECTION", x + padding, y + padding);
        popStyle();
    }

    public void setClicked(boolean click) { this.clicked = click; }
    public boolean wasClicked() { return this.clicked; }
};

class InitBox {
    int x, y, w, h, padding; //size and position

    InitBox(int _x, int _y, int _w, int _h, int _padding) {
        x = _x;
        y = _y;
        w = _w;
        h = 50;
        padding = _padding;

        initSystemButton = new Button (padding, y + padding, w-padding*2, h - padding*2, "START SESSION", fontInfo.buttonLabel_size);
    }

    public void update() {
    }

    public void draw() {
        pushStyle();
        fill(boxColor);
        stroke(boxStrokeColor);
        strokeWeight(1);
        rect(x, y, w, h);
        popStyle();
        initSystemButton.draw();
    }
};

//===================== MENU LIST CLASS =============================//
//================== EXTENSION OF CONTROLP5 =========================//
//============== USED FOR SOURCEBOX & SERIALBOX =====================//
//
// Created: Conor Russomanno Oct. 2014
// Based on ControlP5 Processing Library example, written by Andreas Schlegel
//
/////////////////////////////////////////////////////////////////////

//makeItem function used by MenuList class below
public Map<String, Object> makeItem(String theHeadline) {
    Map m = new HashMap<String, Object>();
    m.put("headline", theHeadline);
    return m;
}

//makeItem function used by MenuList class below
public Map<String, Object> makeItem(String theHeadline, String theSubline, String theCopy) {
    Map m = new HashMap<String, Object>();
    m.put("headline", theHeadline);
    m.put("subline", theSubline);
    m.put("copy", theCopy);
    return m;
}

//=======================================================================================================================================
//
//                    MenuList Class
//
//The MenuList class is implemented by the Control Panel. It allows you to set up a list of selectable items within a fixed rectangle size
//Currently used for Serial/COM select, SD settings, and System Mode
//
//=======================================================================================================================================

public class MenuList extends controlP5.Controller {

    float pos, npos;
    int itemHeight = 24;
    int scrollerLength = 40;
    int scrollerWidth = 15;
    List< Map<String, Object>> items = new ArrayList< Map<String, Object>>();
    PGraphics menu;
    boolean updateMenu;
    int hoverItem = -1;
    int activeItem = -1;
    PFont menuFont = p4;
    int padding = 7;

    MenuList(ControlP5 c, String theName, int theWidth, int theHeight, PFont theFont) {

        super( c, theName, 0, 0, theWidth, theHeight );
        c.register( this );
        menu = createGraphics(getWidth(),getHeight());
        final ControlP5 cc = c; //allows check for isLocked() below
        final String _theName = theName;

        menuFont = p4;
        getValueLabel().setSize(14);
        getCaptionLabel().setSize(14);

        setView(new ControllerView<MenuList>() {

            public void display(PGraphics pg, MenuList t) {
                if (updateMenu && !cc.get(MenuList.class, _theName).isLock()) {
                    updateMenu();
                }
                if (isMouseOver()) {
                    menu.beginDraw();
                    int len = -(itemHeight * items.size()) + getHeight();
                    int ty;
                    if(len != 0){
                        ty = PApplet.parseInt(map(pos, len, 0, getHeight() - scrollerLength - 2, 2 ) );
                    } else {
                        ty = 0;
                    }
                    menu.fill(bgColor, 100);
                    if(ty > 0){
                        menu.rect(getWidth()-scrollerWidth-2, ty, scrollerWidth, scrollerLength );
                    }
                    menu.endDraw();
                }
                pg.image(menu, 0, 0);
            }
        }
        );
        updateMenu();
    }

    /* only update the image buffer when necessary - to save some resources */
    public void updateMenu() {
        int len = -(itemHeight * items.size()) + getHeight();
        npos = constrain(npos, len, 0);
        pos += (npos - pos) * 0.1f;
        //    pos += (npos - pos) * 0.1;
        menu.beginDraw();
        menu.noStroke();
        menu.background(255, 64);
        // menu.textFont(cp5.getFont().getFont());
        menu.textFont(menuFont);
        menu.pushMatrix();
        menu.translate( 0, pos );
        menu.pushMatrix();

        int i0;
        if((itemHeight * items.size()) != 0){
            i0 = PApplet.max( 0, PApplet.parseInt(map(-pos, 0, itemHeight * items.size(), 0, items.size())));
        } else{
            i0 = 0;
        }
        int range = ceil((PApplet.parseFloat(getHeight())/PApplet.parseFloat(itemHeight))+1);
        int i1 = PApplet.min( items.size(), i0 + range );

        menu.translate(0, i0*itemHeight);

        for (int i=i0; i<i1; i++) {
            Map m = items.get(i);
            menu.fill(255, 100);
            if (i == hoverItem) {
                menu.fill(127, 134, 143);
            }
            if (i == activeItem) {
                menu.stroke(184, 220, 105, 255);
                menu.strokeWeight(1);
                menu.fill(184, 220, 105, 255);
                menu.rect(0, 0, getWidth()-1, itemHeight-1 );
                menu.noStroke();
            } else {
                menu.rect(0, 0, getWidth(), itemHeight-1 );
            }
            menu.fill(bgColor);
            menu.textFont(menuFont);

            //make sure there is something in the Ganglion serial list...
            try {
                menu.text(m.get("headline").toString(), 8, itemHeight - padding); // 5/17
                menu.translate( 0, itemHeight );
            } catch(Exception e){
                println("Nothing in list...");
            }
        }
        menu.popMatrix();
        menu.popMatrix();
        menu.endDraw();
        updateMenu = abs(npos-pos)>0.01f ? true:false;
    }

    /* when detecting a click, check if the click happend to the far right, if yes, scroll to that position,
      * otherwise do whatever this item of the list is supposed to do.
      */
    public void onClick() {
        println(getName() + ": click! ");
        if (items.size() > 0) { //Fixes #480
            if (getPointer().x()>getWidth()-scrollerWidth) {
                if(getHeight() != 0){
                    npos= -map(getPointer().y(), 0, getHeight(), 0, items.size()*itemHeight);
                }
                updateMenu = true;
            } else {
                int len = itemHeight * items.size();
                int index = 0;
                if(len != 0){
                    index = PApplet.parseInt( map( getPointer().y() - pos, 0, len, 0, items.size() ) ) ;
                }
                setValue(index);
                activeItem = index;
            }
            updateMenu = true;
        }
    }

    public void onMove() {
        if (getPointer().x()>getWidth() || getPointer().x()<0 || getPointer().y()<0  || getPointer().y()>getHeight() ) {
            hoverItem = -1;
        } else {
            int len = itemHeight * items.size();
            int index = 0;
            if(len != 0){
                index = PApplet.parseInt( map( getPointer().y() - pos, 0, len, 0, items.size() ) ) ;
            }
            hoverItem = index;
        }
        updateMenu = true;
    }

    public void onDrag() {
        if (getPointer().x() > (getWidth()-scrollerWidth)) {
            npos= -map(getPointer().y(), 0, getHeight(), 0, items.size()*itemHeight);
            updateMenu = true;
        } else {
            npos += getPointer().dy() * 2;
            updateMenu = true;
        }
    }

    public void onScroll(int n) {
        npos += ( n * 4 );
        updateMenu = true;
    }

    public void addItem(Map<String, Object> m) {
        items.add(m);
        updateMenu = true;
    }

    public void removeItem(Map<String, Object> m) {
        items.remove(m);
        updateMenu = true;
    }

    //Returns null if selecting an item that does not exist
    public Map<String, Object> getItem(int theIndex) {
        Map<String, Object> m = new HashMap<String, Object>();
        try {
            m = items.get(theIndex);
        } catch (Exception e) {
            //println("Item " + theIndex + " does not exist.");
        }
        return m;
    }

    public int getListSize() {
       return items.size(); 
    }
};

////////////////////////////////////////////////////////////
// Purpose: Handle OpenBCI Data Format and BDF+ file writing
// Created: Chip Audette  May 2, 2014
// Modified: Richard Waltman July 1, 2019
//
////////////////////////////////////////////////////////////

//------------------------------------------------------------------------
//                       Global Functions
//------------------------------------------------------------------------

public void openNewLogFile(String _fileName) {
    //close the file if it's open
    switch (outputDataSource) {
        case OUTPUT_SOURCE_ODF:
            openNewLogFileODF(_fileName);
            break;
        case OUTPUT_SOURCE_BDF:
            openNewLogFileBDF(_fileName);
            break;
        case OUTPUT_SOURCE_NONE:
        default:
            // Do nothing...
            break;
    }
    settings.setLogFileIsOpen(true);
}

/**
  * @description Opens (and closes if already open) and BDF file. BDF is the
  *  biosemi data format.
  * @param `_fileName` {String} - The meat of the file name
  */
public void openNewLogFileBDF(String _fileName) {
    if (fileoutput_bdf != null) {
        println("OpenBCI_GUI: closing log file");
        closeLogFile();
    }
    //open the new file
    fileoutput_bdf = new OutputFile_BDF(getSampleRateSafe(), nchan, _fileName);

    output_fname = fileoutput_bdf.fname;
    println("OpenBCI_GUI: openNewLogFile: opened BDF output file: " + output_fname); //Print filename of new BDF file to console
}

/**
  * @description Opens (and closes if already open) and ODF file. ODF is the
  *  openbci data format.
  * @param `_fileName` {String} - The meat of the file name
  */
public void openNewLogFileODF(String _fileName) {
    if (fileoutput_odf != null) {
        println("OpenBCI_GUI: closing log file");
        closeLogFile();
    }
    //open the new file
    fileoutput_odf = new OutputFile_rawtxt(getSampleRateSafe(), sessionName, _fileName);

    output_fname = fileoutput_odf.fname;
    println("OpenBCI_GUI: openNewLogFile: opened ODF output file: " + output_fname); //Print filename of new ODF file to console
}

public void closeLogFile() {
    switch (outputDataSource) {
        case OUTPUT_SOURCE_ODF:
            closeLogFileODF();
            break;
        case OUTPUT_SOURCE_BDF:
            closeLogFileBDF();
            break;
        case OUTPUT_SOURCE_NONE:
        default:
            // Do nothing...
            break;
    }
    settings.setLogFileIsOpen(false);
}

/**
  * @description Close an open BDF file. This will also update the number of data
  *  records.
  */
public void closeLogFileBDF() {
    if (fileoutput_bdf != null) {
        fileoutput_bdf.closeFile();
    }
    fileoutput_bdf = null;
}

/**
  * @description Close an open ODF file.
  */
public void closeLogFileODF() {
    if (fileoutput_odf != null) {
        fileoutput_odf.closeFile();
    }
    fileoutput_odf = null;
}

public void fileSelected(File selection) {  //called by the Open File dialog box after a file has been selected
    if (selection == null) {
        println("fileSelected: no selection so far...");
    } else {
        //inputFile = selection;
        playbackData_fname = selection.getAbsolutePath(); //<>// //<>//
    }
}

public String getDateString() {
    String fname = year() + "-";
    if (month() < 10) fname=fname+"0";
    fname = fname + month() + "-";
    if (day() < 10) fname = fname + "0";
    fname = fname + day();

    fname = fname + "_";
    if (hour() < 10) fname = fname + "0";
    fname = fname + hour() + "-";
    if (minute() < 10) fname = fname + "0";
    fname = fname + minute() + "-";
    if (second() < 10) fname = fname + "0";
    fname = fname + second();
    return fname;
}

//these functions are relevant to convertSDFile
public void createPlaybackFileFromSD() {
    logFileName = settings.guiDataPath+"SDconverted-"+getDateString()+".csv";
    dataWriter = createWriter(logFileName);
    dataWriter.println("%OBCI SD Convert - " + getDateString());
    dataWriter.println("%");
    dataWriter.println("%Sample Rate = 250.0 Hz");
    dataWriter.println("%First Column = SampleIndex");
    dataWriter.println("%Last Column = Timestamp");
    dataWriter.println("%Other Columns = EEG data in microvolts followed by Accel Data (in G) interleaved with Aux Data");

}

public void sdFileSelected(File selection) {
    if (selection == null) {
        println("Window was closed or the user hit cancel.");
    } else {
        println("User selected " + selection.getAbsolutePath());
        dataReader = createReader(selection.getAbsolutePath()); // ("positions.txt");
        controlPanel.convertingSD = true;
        println("Timing SD file conversion...");
        thatTime = millis();
    }
}

//------------------------------------------------------------------------
//                            CLASSES
//------------------------------------------------------------------------

//write data to a text file
public class OutputFile_rawtxt {
    PrintWriter output;
    String fname;
    private int rowsWritten;
    private long logFileStartTime;

    OutputFile_rawtxt(float fs_Hz) {

        //build up the file name
        fname = settings.guiDataPath+"OpenBCI-RAW-";

        //add year month day to the file name
        fname = fname + year() + "-";
        if (month() < 10) fname=fname+"0";
        fname = fname + month() + "-";
        if (day() < 10) fname = fname + "0";
        fname = fname + day();

        //add hour minute sec to the file name
        fname = fname + "_";
        if (hour() < 10) fname = fname + "0";
        fname = fname + hour() + "-";
        if (minute() < 10) fname = fname + "0";
        fname = fname + minute() + "-";
        if (second() < 10) fname = fname + "0";
        fname = fname + second();

        //add the extension
        fname = fname + ".txt";

        //open the file
        output = createWriter(fname);

        //add the header
        writeHeader(fs_Hz);

        //init the counter
        rowsWritten = 0;
    }

    //variation on constructor to have custom name
    OutputFile_rawtxt(float fs_Hz, String _sessionName, String _fileName) {
        settings.setSessionPath(settings.recordingsPath + "OpenBCISession_" + _sessionName + File.separator);
        fname = settings.getSessionPath();
        fname += "OpenBCI-RAW-";
        fname += _fileName;
        fname += ".txt";
        output = createWriter(fname);        //open the file
        writeHeader(fs_Hz);    //add the header
        rowsWritten = 0;    //init the counter
    }

    public void writeHeader(float fs_Hz) {
        output.println("%OpenBCI Raw EEG Data");
        output.println("%Number of channels = " + nchan);
        output.println("%Sample Rate = " + fs_Hz + " Hz");
        output.println("%First Column = SampleIndex");
        output.println("%Last Column = Timestamp ");
        output.println("%Other Columns = EEG data in microvolts followed by Accel Data (in G) interleaved with Aux Data");
        output.flush();
    }

    public void writeRawData_dataPacket(DataPacket_ADS1299 data, float scale_to_uV, float scale_for_aux, int stopByte, long timestamp) {
        //get current date time with Date()
        if (output != null) {
            output.print(Integer.toString(data.sampleIndex));
            writeValues(data.values,scale_to_uV);
            if (eegDataSource == DATASOURCE_GANGLION) {
                writeAccValues(data.auxValues, scale_for_aux);
            } else {
                if (stopByte == 0xC1) {
                    writeAuxValues(data);
                } else {
                    writeAccValues(data.auxValues, scale_for_aux);
                }
            }
            output.print( ", " + dateFormat.format(new Date(timestamp)));
            output.print( ", " + timestamp);
            output.println(); rowsWritten++;
            //output.flush();
        }
    }

    private void writeValues(int[] values, float scale_fac) {
        int nVal = values.length;
        for (int Ival = 0; Ival < nVal; Ival++) {
            output.print(", ");
            output.print(String.format(Locale.US, "%.2f", scale_fac * PApplet.parseFloat(values[Ival])));
        }
    }

    private void writeAccValues(int[] values, float scale_fac) {
        int nVal = values.length;
        for (int Ival = 0; Ival < nVal; Ival++) {
            output.print(", ");
            output.print(String.format(Locale.US, "%.3f", scale_fac * PApplet.parseFloat(values[Ival])));
        }
    }

    private void writeAuxValues(DataPacket_ADS1299 data) {
        if (eegDataSource == DATASOURCE_CYTON) {
            // println("board mode: " + cyton.getBoardMode());
            if (cyton.getBoardMode() == BoardMode.DIGITAL) {
                if (cyton.isWifi()) {
                    output.print(", " + ((data.auxValues[0] & 0xFF00) >> 8));
                    output.print(", " + (data.auxValues[0] & 0xFF));
                    output.print(", " + data.auxValues[1]);
                } else {
                    output.print(", " + ((data.auxValues[0] & 0xFF00) >> 8));
                    output.print(", " + (data.auxValues[0] & 0xFF));
                    output.print(", " + ((data.auxValues[1] & 0xFF00) >> 8));
                    output.print(", " + (data.auxValues[1] & 0xFF));
                    output.print(", " + data.auxValues[2]);
                }
            } else if (cyton.getBoardMode() == BoardMode.ANALOG) {
                if (cyton.isWifi()) {
                    output.print(", " + data.auxValues[0]);
                    output.print(", " + data.auxValues[1]);
                } else {
                    output.print(", " + data.auxValues[0]);
                    output.print(", " + data.auxValues[1]);
                    output.print(", " + data.auxValues[2]);
                }
            } else if (cyton.getBoardMode() == BoardMode.MARKER) {
                output.print(", " + data.auxValues[0]);
                if ( data.auxValues[0] > 0) {
                    hub.validLastMarker = data.auxValues[0];
                }

            } else {
                for (int Ival = 0; Ival < 3; Ival++) {
                    output.print(", " + data.auxValues[Ival]);
                }
            }
        } else {
            for (int i = 0; i < 3; i++) {
                output.print(", " + (data.auxValues[i] & 0xFF));
                output.print(", " + ((data.auxValues[i] & 0xFF00) >> 8));
            }
        }
    }

    public void closeFile() {
        output.flush();
        output.close();
    }

    public int getRowsWritten() {
        return rowsWritten;
    }

    public void limitRecordingFileDuration() {
        if (settings.maxLogTimeReached()) {
            println("DataLogging: Max recording duration reached for OpenBCI data format. Creating a new recording file in the session folder.");
            closeLogFile();
            //open data file if it has not already been opened
            if (!settings.isLogFileOpen()) {
                if (eegDataSource == DATASOURCE_CYTON) openNewLogFile(getDateString());
                if (eegDataSource == DATASOURCE_GANGLION) openNewLogFile(getDateString());
            }
            settings.setLogFileStartTime(System.nanoTime());
        }
    }
};

//write data to a text file in BDF+ format http://www.biosemi.com/faq/file_format.htm
public class OutputFile_BDF {
    private PrintWriter writer;
    private OutputStream dstream;
    // private FileOutputStream fstream;
    // private BufferedOutputStream bstream;
    // private DataOutputStream dstream;

    // Each header component has a max allocated amount of ascii spaces
    // SPECS FOR BDF http://www.biosemi.com/faq/file_format.htm
    // ADDITIONAL SPECS FOR EDF+ http://www.edfplus.info/specs/edfplus.html#additionalspecs
    // A good resource for a comparison between BDF and EDF http://www.teuniz.net/edfbrowser/bdfplus%20format%20description.html
    final static int BDF_HEADER_SIZE_VERSION = 8; // Version of this data format Byte 1: "255" (non ascii) Bytes 2-8 : "BIOSEMI" (ASCII)
    final static int BDF_HEADER_SIZE_PATIENT_ID = 80; // Local patient identification (mind item 3 of the additional EDF+ specs)
    final static int BDF_HEADER_SIZE_RECORDING_ID = 80; // Local recording identification (mind item 4 of the additional EDF+ specs)
    final static int BDF_HEADER_SIZE_RECORDING_START_DATE = 8; // Start date of recording (dd.mm.yy) (mind item 2 of the additional EDF+ specs)
    final static int BDF_HEADER_SIZE_RECORDING_START_TIME = 8; // Start time of recordign (hh.mm.ss)
    final static int BDF_HEADER_SIZE_BYTES_IN_HEADER = 8; // Number of bytes in header record
    final static int BDF_HEADER_SIZE_RESERVED = 44; // Reserved
    final static int BDF_HEADER_SIZE_NUMBER_DATA_RECORDS = 8; // Number of data records (-1 if unknown, obey item 10 of the additional EDF+ specs)
    final static int BDF_HEADER_SIZE_DURATION_OF_DATA_RECORD = 8; // Duration of a data record, in seconds
    final static int BDF_HEADER_SIZE_NUMBER_SIGNALS = 4; // Number of signals (ns) in data record
    final static int BDF_HEADER_NS_SIZE_LABEL = 16; // ns * 16 ascii : ns * label (e.g. EEG Fpz-Cz or Body temp) (mind item 9 of the additional EDF+ specs)
    final static int BDF_HEADER_NS_SIZE_TRANSDUCER_TYPE = 80; // ns * 80 ascii : ns * transducer type (e.g. AgAgCl electrode)
    final static int BDF_HEADER_NS_SIZE_PHYSICAL_DIMENSION = 8; // ns * 8 ascii : ns * physical dimension (e.g. uV or degreeC)
    final static int BDF_HEADER_NS_SIZE_PHYSICAL_MINIMUM = 8; // ns * 8 ascii : ns * physical minimum (e.g. -500 or 34)
    final static int BDF_HEADER_NS_SIZE_PHYSICAL_MAXIMUM = 8; // ns * 8 ascii : ns * physical maximum (e.g. 500 or 40)
    final static int BDF_HEADER_NS_SIZE_DIGITAL_MINIMUM = 8; // ns * 8 ascii : ns * digital minimum (e.g. -2048)
    final static int BDF_HEADER_NS_SIZE_DIGITAL_MAXIMUM = 8; // ns * 8 ascii : ns * digital maximum (e.g. 2047)
    final static int BDF_HEADER_NS_SIZE_PREFILTERING = 80; // ns * 80 ascii : ns * prefiltering (e.g. HP:0.1Hz LP:75Hz)
    final static int BDF_HEADER_NS_SIZE_NR = 8; // ns * 8 ascii : ns * nr of samples in each data record
    final static int BDF_HEADER_NS_SIZE_RESERVED = 32; // ns * 32 ascii : ns * reserved

    // Ref: http://www.edfplus.info/specs/edfplus.html#header
    final static String BDF_HEADER_DATA_CONTINUOUS = "BDF+C";
    final static String BDF_HEADER_DATA_DISCONTINUOUS = "BDF+D";
    final static String BDF_HEADER_PHYSICAL_DIMENISION_UV = "uV";
    final static String BDF_HEADER_PHYSICAL_DIMENISION_G = "g";
    final static String BDF_HEADER_TRANSDUCER_AGAGCL = "AgAgCl electrode";
    final static String BDF_HEADER_TRANSDUCER_MEMS = "MEMS";
    final static String BDF_HEADER_ANNOTATIONS = "BDF Annotations ";

    final static int BDF_HEADER_BYTES_BLOCK = 256;

    DateFormat startDateFormat = new SimpleDateFormat("dd.MM.yy");
    DateFormat startTimeFormat = new SimpleDateFormat("hh.mm.ss");

    private char bdf_version_header = 0xFF;
    private char[] bdf_version = {'B', 'I', 'O', 'S', 'E', 'M', 'I'};

    private String bdf_patient_id_subfield_hospoital_code = "X"; // The code by which the patient is known in the hospital administration.
    private String bdf_patient_id_subfield_sex = "X"; // Sex (English, so F or M).
    private String bdf_patient_id_subfield_birthdate = "X"; // (e.g. 24-NOV-1992) Birthdate in dd-MM-yyyy format using the English 3-character abbreviations of the month in capitals. 02-AUG-1951 is OK, while 2-AUG-1951 is not.
    private String bdf_patient_id_subfield_name = "X"; // the patients name. No spaces! Use "_" where ever a space is

    private String bdf_recording_id_subfield_prefix = "X"; //"Startdate"; // The text 'Startdate'
    private String bdf_recording_id_subfield_startdate = "X"; // getDateString(startDateFormat); // The startdate itself in dd-MM-yyyy format using the English 3-character abbreviations of the month in capitals.
    private String bdf_recording_id_subfield_admin_code = "X"; // The hospital administration code of the investigation, i.e. EEG number or PSG number.
    private String bdf_recording_id_subfield_investigator = "X"; // A code specifying the responsible investigator or technician.
    private String bdf_recording_id_subfield_equipment = "X"; // A code specifying the used equipment.

    // Digital max and mins
    private String bdf_digital_minimum_ADC_24bit = "-8388608"; // -1 * 2^23
    private String bdf_digital_maximum_ADC_24bit = "8388607"; // 2^23 - 1
    private String bdf_digital_minimum_ADC_12bit = "-2048"; // -1 * 2^11
    private String bdf_digital_maximum_ADC_12bit = "2047"; // 2^11 - 1

    // Physcial max and mins
    private String bdf_physical_minimum_ADC_24bit = "-187500"; // 4.5 / 24 / (2^23) * 1000000 *  (2^23)
    private String bdf_physical_maximum_ADC_24bit = "187500"; // 4.5 / 24 / (2^23) * 1000000 * -1 * (2^23)
    private String bdf_physical_minimum_ADC_Accel = "-4";
    private String bdf_physical_maximum_ADC_Accel = "4";

    private String bdf_physical_minimum_ADC_24bit_ganglion = "-15686";
    private String bdf_physical_maximum_ADC_24bit_ganglion = "15686";

    private final float ADS1299_Vref = 4.5f;  //reference voltage for ADC in ADS1299.  set by its hardware
    private float ADS1299_gain = 24.0f;  //assumed gain setting for ADS1299.  set by its Arduino code
    private float scale_fac_uVolts_per_count = ADS1299_Vref / ((float)(pow(2,23)-1)) / ADS1299_gain  * 1000000.f; //ADS1299 datasheet Table 7, confirmed through experiment

    public boolean continuous = true;
    public boolean write_accel = true;

    private int nbAnnotations = 1;
    private int nbAux = 3;
    private int nbChan = 8;
    private int sampleSize = 3; // Number of bytes in a sample

    private String labelsAnnotations[] = new String[nbAnnotations];
    private String transducerAnnotations[] = new String[nbAnnotations];
    private String physicalDimensionAnnotations[] = new String[nbAnnotations];
    private String physicalMinimumAnnotations[] = new String[nbAnnotations];
    private String physicalMaximumAnnotations[] = new String[nbAnnotations];
    private String digitalMinimumAnnotations[] = new String[nbAnnotations];
    private String digitalMaximumAnnotations[] = new String[nbAnnotations];
    private String prefilteringAnnotations[] = new String[nbAnnotations];
    private String nbSamplesPerDataRecordAnnotations[] = new String[nbAnnotations];
    private String reservedAnnotations[] = new String[nbAnnotations];

    private String labelsAux[] = new String[nbAux];
    private String transducerAux[] = new String[nbAux];
    private String physicalDimensionAux[] = new String[nbAux];
    private String physicalMinimumAux[] = new String[nbAux];
    private String physicalMaximumAux[] = new String[nbAux];
    private String digitalMinimumAux[] = new String[nbAux];
    private String digitalMaximumAux[] = new String[nbAux];
    private String prefilteringAux[] = new String[nbAux];
    private String nbSamplesPerDataRecordAux[] = new String[nbAux];
    private String reservedAux[] = new String[nbAux];

    private String labelsEEG[] = new String[nbChan];
    private String transducerEEG[] = new String[nbChan];
    private String physicalDimensionEEG[] = new String[nbChan];
    private String physicalMinimumEEG[] = new String[nbChan];
    private String physicalMaximumEEG[] = new String[nbChan];
    private String digitalMinimumEEG[] = new String[nbChan];
    private String digitalMaximumEEG[] = new String[nbChan];
    private String prefilteringEEG[] = new String[nbChan];
    private String nbSamplesPerDataRecordEEG[] = new String[nbChan];
    private String reservedEEG[] = new String[nbChan];

    private String tempWriterPrefix = settings.recordingsPath+"temp.txt";

    private int fs_Hz = 250;
    private int accel_Hz = 25;

    private int samplesInDataRecord = 0;
    private int dataRecordsWritten = 0;

    private Date startTime;
    private boolean startTimeCaptured = false;

    private int timeDataRecordStart = 0;

    private byte auxValBuf[][][];
    private byte auxValBuf_buffer[][][];
    private byte chanValBuf[][][];
    private byte chanValBuf_buffer[][][];

    public String fname = "";

    public int nbSamplesPerAnnontation = 20;

    private int totalByteCount = 0;

    /**
      * @description Creates an EDF writer! Name of output file based on current
      *  date and time.
      * @param `_fs_Hz` {float} - The sample rate of the data source. Going to be
      *  `250` for OpenBCI 32bit board, `125` for OpenBCI 32bit board + daisy, or
      *  `256` for the Ganglion.
      * @param `_nbChan` {int} - The number of channels of the data source. Going to be
      *  `8` for OpenBCI 32bit board, `16` for OpenBCI 32bit board + daisy, or
      *  `4` for the Ganglion.
      * @constructor
      */
    OutputFile_BDF(float _fs_Hz, int _nbChan) {

        fname = getFileName();
        fs_Hz = (int)_fs_Hz;
        nbChan = _nbChan;

        init();
    }

    /**
      * @description Creates an EDF writer! The output file will contain the `_filename`.
      * @param `_fs_Hz` {float} - The sample rate of the data source. Going to be
      *  `250` for OpenBCI 32bit board, `125` for OpenBCI 32bit board + daisy, or
      *  `256` for the Ganglion.
      * @param `_nbChan` {int} - The number of channels of the data source. Going to be
      *  `8` for OpenBCI 32bit board, `16` for OpenBCI 32bit board + daisy, or
      *  `4` for the Ganglion.
      * @param `_fileName` {String} - Main component of the output file name.
      * @constructor
      */
    OutputFile_BDF(float _fs_Hz, int _nbChan, String _fileName) {

        fname = getFileName(_fileName);
        fs_Hz = (int)_fs_Hz;
        nbChan = _nbChan;

        init();
    }

    /**
      * @description Used to initalize the writer.
      */
    private void init() {

        // Set the arrays needed for header
        setNbAnnotations(nbAnnotations);
        setNbAux(nbAux);
        setNbChan(nbChan);

        // Create the aux value buffer
        auxValBuf = new byte[nbAux][fs_Hz][sampleSize];
        auxValBuf_buffer = new byte[nbAux][fs_Hz][sampleSize];

        // Create the channel value buffer
        chanValBuf = new byte[nbChan][fs_Hz][sampleSize];
        chanValBuf_buffer = new byte[nbChan][fs_Hz][sampleSize];

        // Create the output stream for raw data
        dstream = createOutput(tempWriterPrefix);

        // Init the counter
        dataRecordsWritten = 0;
    }

    /**
      * @description Writes a raw data packet to the buffer. Also will flush the
      *  buffer if it is filled with one second worth of data. Will also capture
      *  the start time, or the first time a packet is recieved.
      * @param `data` {DataPacket_ADS1299} - A data packet
      */
    public void writeRawData_dataPacket(DataPacket_ADS1299 data) {

        if (!startTimeCaptured) {
            startTime = new Date();
            startTimeCaptured = true;
            timeDataRecordStart = millis();
        }

        writeChannelDataValues(data.rawValues);
        if (eegDataSource == DATASOURCE_CYTON) {
            writeAuxDataValues(data.rawAuxValues);
        }
        samplesInDataRecord++;
        // writeValues(data.auxValues,scale_for_aux);
        if (samplesInDataRecord >= fs_Hz) {
            arrayCopy(chanValBuf,chanValBuf_buffer);
            if (eegDataSource == DATASOURCE_CYTON) {
                arrayCopy(auxValBuf,auxValBuf_buffer);
            }

            samplesInDataRecord = 0;
            writeDataOut();
        }
    }

    private void writeDataOut() {
        try {
            for (int i = 0; i < nbChan; i++) {
                for (int j = 0; j < fs_Hz; j++) {
                    for (int k = 0; k < 3; k++) {
                        dstream.write(chanValBuf_buffer[i][j][k]);
                    }
                }
            }
            if (eegDataSource == DATASOURCE_CYTON) {
                for (int i = 0; i < nbAux; i++) {
                    for (int j = 0; j < fs_Hz; j++) {
                        for (int k = 0; k < 3; k++) {
                            dstream.write(auxValBuf_buffer[i][j][k]);
                        }
                    }
                }
            }

            // Write the annotations
            dstream.write('+');
            String _t = Integer.toString((millis() - timeDataRecordStart) / 1000);
            int strLen = _t.length();
            for (int i = 0; i < strLen; i++) {
                dstream.write(_t.charAt(i));
            }
            dstream.write(20);
            dstream.write(20);
            int lenWritten = 1 + strLen + 1 + 1;
            // for (int i = lenWritten; i < fs_Hz * sampleSize; i++) {
            for (int i = lenWritten; i < nbSamplesPerAnnontation * sampleSize; i++) {
                dstream.write(0);
            }
            dataRecordsWritten++;

        } catch (Exception e) {
            println("writeRawData_dataPacket: Exception ");
            e.printStackTrace();
        }
    }

    public void closeFile() {

        println("Closed the temp data file. Now opening a new file.");
        try {
            dstream.close();
        } catch (Exception e) {
            println("closeFile: dstream close exception ");
            e.printStackTrace();
        }
        println("closeFile: Started...");

        OutputStream o = createOutput(fname);
        println("closeFile: Made file");

        // Create a new writer with the same file name
        // Write the header
        writeHeader(o);
        println("closeFile: Wrote header");

        writeData(o);
        println("closeFile: Data written. Closing new BDF+ file.");
        try {
            o.close();
            println("closeFile: wrote data");
            File tempFile = new File(tempWriterPrefix);
            if (Files.deleteIfExists(tempFile.toPath())) {
                println("closeFile: BDF+ temporary file deleted.");
                output("BDF+ file has been made.");
            } else {
                println("closeFile: error deleting temp file");
            }
        } catch (IOException e) {
            println("Error closing BDF OutputStream");
        }

    }

    public int getRecordsWritten() {
        return dataRecordsWritten;
    }

    /**
      * @description Resizes and resets the per aux channel arrays to size `n`
      * @param `n` {int} - The new size of arrays
      */
    public void setAnnotationsArraysToSize(int n) {
        labelsAnnotations = new String[n];
        transducerAnnotations = new String[n];
        physicalDimensionAnnotations = new String[n];
        physicalMinimumAnnotations = new String[n];
        physicalMaximumAnnotations = new String[n];
        digitalMinimumAnnotations = new String[n];
        digitalMaximumAnnotations = new String[n];
        prefilteringAnnotations = new String[n];
        nbSamplesPerDataRecordAnnotations = new String[n];
        reservedAnnotations = new String[n];
    }

    /**
      * @description Resizes and resets the per aux channel arrays to size `n`
      * @param `n` {int} - The new size of arrays
      */
    public void setAuxArraysToSize(int n) {
        labelsAux = new String[n];
        transducerAux = new String[n];
        physicalDimensionAux = new String[n];
        physicalMinimumAux = new String[n];
        physicalMaximumAux = new String[n];
        digitalMinimumAux = new String[n];
        digitalMaximumAux = new String[n];
        prefilteringAux = new String[n];
        nbSamplesPerDataRecordAux = new String[n];
        reservedAux = new String[n];
    }

    /**
      * @description Resizes and resets the per channel arrays to size `n`
      * @param `n` {int} - The new size of arrays
      */
    public void setEEGArraysToSize(int n) {
        labelsEEG = new String[n];
        transducerEEG = new String[n];
        physicalDimensionEEG = new String[n];
        physicalMinimumEEG = new String[n];
        physicalMaximumEEG = new String[n];
        digitalMinimumEEG = new String[n];
        digitalMaximumEEG = new String[n];
        prefilteringEEG = new String[n];
        nbSamplesPerDataRecordEEG = new String[n];
        reservedEEG = new String[n];
    }

    /**
      * @description Set an EEG 10-20 label for a given channel. (e.g. EEG Fpz-Cz)
      * @param `s` {String} - The string to store to the `labels` string array
      * @param `index` {int} - The position in the `labels` array to insert the
      *  string `str`. Must be smaller than `nbChan`.
      * @returns {boolean} - `true` if the label was added, `false` if not able to
      */
    public boolean setEEGLabelForIndex(String s, int index) {
        if (index < nbChan) {
            labelsEEG[index] = s;
            return true;
        } else {
            return false;
        }
    }

    /**
      * @description Set the number of annotation signals.
      * @param `n` {int} - The new number of channels
      */
    public void setNbAnnotations(int n) {
        if (n < 1) n = 1;

        // Set the main variable
        nbAnnotations = n;
        // Resize the arrays
        setAnnotationsArraysToSize(n);
        // Fill any arrays that can be filled
        setAnnotationsArraysToDefaults();
    }

    /**
      * @description Set the number of aux signals.
      * @param `n` {int} - The new number of aux channels
      */
    public void setNbAux(int n) {
        if (n < 1) n = 1;

        // Set the main variable
        nbAux = n;
        // Resize the arrays
        setAuxArraysToSize(n);
        // Fill any arrays that can be filled
        setAuxArraysToDefaults();
    }

    /**
      * @description Set the number of channels. Important to do. This will nuke
      *  the labels array if the size increases or decreases.
      * @param `n` {int} - The new number of channels
      */
    public void setNbChan(int n) {
        if (n < 1) n = 1;

        // Set the main variable
        nbChan = n;
        // Resize the arrays
        setEEGArraysToSize(n);
        // Fill any arrays that can be filled
        setEEGArraysToDefaults();
    }

    /**
      * @description Sets the patient's sex.
      * @param `s` {String} - The patients sex (e.g. M or F)
      * @returns {String} - The string that was set.
      */
    public String setPatientIdSex(String s) {
        return bdf_patient_id_subfield_sex = swapSpacesForUnderscores(s);
    }

    /**
      * @description Sets the patient's birthdate.
      * @param `s` {String} - The patients birth date (e.g. 24-NOV-1992)
      * @returns {String} - The string that was set.
      */
    public String setPatientIdBirthdate(String s) {
        return bdf_patient_id_subfield_birthdate = swapSpacesForUnderscores(s);
    }

    /**
      * @description Sets the patient's name. Note that spaces will be swapped for
      *  underscores.
      * @param `s` {String} - The patients name.
      * @returns {String} - The string that was set.
      */
    public String setPatientIdName(String s) {
        return bdf_patient_id_subfield_name = swapSpacesForUnderscores(s);
    }

    /**
      * @description Set any prefilerting for a given channel. (e.g. HP:0.1Hz LP:75Hz)
      * @param `s` {String} - The string to store to the `prefiltering` string array
      * @param `index` {int} - The position in the `prefiltering` array to insert the
      *  string `str`. Must be smaller than `nbChan`.
      * @returns {boolean} - `true` if the string was added, `false` if not able to
      */
    public boolean setEEGPrefilterForIndex(String s, int index) {
        if (index < nbChan) {
            prefilteringEEG[index] = s;
            return true;
        } else {
            return false;
        }
    }

    /**
      * @description Sets the recording admin code. Note that spaces will be
      *  swapped for underscores.
      * @param `s` {String} - The recording admin code.
      * @returns {String} - The string that was set.
      */
    public String setRecordingIdAdminCode(String s) {
        return bdf_recording_id_subfield_admin_code = swapSpacesForUnderscores(s);
    }

    /**
      * @description Sets the recording admin code. Note that spaces will be
      *  swapped for underscores. (e.g. AJ Keller)
      * @param `s` {String} - The recording id of the investigator.
      * @returns {String} - The string that was set. (e.g. AJ_Keller)
      */
    public String setRecordingIdInvestigator(String s) {
        return bdf_recording_id_subfield_investigator = swapSpacesForUnderscores(s);
    }

    /**
      * @description Sets the recording equipment code. Note that spaces will be
      *  swapped for underscores. (e.g. OpenBCI 32bit or OpenBCI Ganglion)
      * @param `s` {String} - The recording equipment id.
      * @returns {String} - The string that was set.
      */
    public String setRecordingIdEquipment(String s) {
        return bdf_recording_id_subfield_equipment = swapSpacesForUnderscores(s);
    }

    /**
      * @description Set a transducer type for a given channel. (e.g. AgAgCl electrode)
      * @param `s` {String} - The string to store to the `transducerEEG` string array
      * @param `index` {int} - The position in the `transducerEEG` array to insert the
      *  string `str`. Must be smaller than `nbChan`.
      * @returns {boolean} - `true` if the string was added, `false` if not able to
      */
    public boolean setTransducerForIndex(String s, int index) {
        if (index < nbChan) {
            transducerEEG[index] = s;
            return true;
        } else {
            return false;
        }
    }

    /**
      * @description Used to combine a `str` (string) into one big string a certain number of
      *  `times` with left justification padding of `size`.
      * @param `s` {String} - The string to be inserted
      * @param `size` {int} - The total allowable size for `str` to be inserted.
      *  If `str.length()` < `size` then `str` will essentially be right padded with
      *  spaces till the `output` is of length `size`.
      * @param `times` {int} - The number of times to repeat the `str` with `padding`
      * @returns {String} - The `str` right padded with spaces to beome `size` length
      *  and that repeated `times`.
      */
    private String combineStringIntoSizeTimes(String s, int size, int times) {
        String output = "";
        for (int i = 0; i < times; i++) {
            output += padStringRight(s, size);
        }
        return output;
    }

    /**
      * @description Calculate the number of bytes in the header. Entirerly based
      *  off the number of channels (`nbChan`)
      * @returns {int} - The number of bytes in the header is 256 + (256 * N) where
      *  N is the number of channels (signals)
      */
    private int getBytesInHeader() {
        return BDF_HEADER_BYTES_BLOCK + (BDF_HEADER_BYTES_BLOCK * getNbSignals()); // Add one for the annotations channel
    }

    /**
      * @description Used to get the continuity of the EDF file based on class public
      *  boolean variable `continuous`. If stop stream then start stream is pressed
      *  we must set the variable `continuous` to false.
      * @returns {String} - The string with NO spacing
      */
    private String getContinuity() {
        if (continuous) {
            return BDF_HEADER_DATA_CONTINUOUS;
        } else {
            return BDF_HEADER_DATA_DISCONTINUOUS;
        }
    }

    /**
      * @description Returns a string of the date based on the input DateFormat `d`
      * @param `d` {DateFormat} - The format you want the date/time in
      * @returns {String} - The current date/time formatted based on `d`
      */
    private String getDateString(DateFormat d) {
        // Get current date time with Date()
        return d.format(new Date());
    }

    /**
      * @description Returns a string of the date based on the input DateFormat `d`
      * @param `d` {DateFormat} - The format you want the date/time in
      * @returns {String} - The current date/time formatted based on `d`
      */
    private String getDateString(Date d, DateFormat df) {
        // Get current date time with Date()
        return df.format(d);
    }

    /**
      * @description Generate a file name for the EDF file that has the current date
      *  and time injected into it.
      * @returns {String} - A fully qualified name of an output file with the date
      *  and time.
      */
    private String getFileName() {
        //build up the file name
        String output = "";

        // If no file name is supplied then we generate one based off the current
        //  date and time of day.
        output += year() + "-";
        if (month() < 10) output += "0";
        output += month() + "-";
        if (day() < 10) output += "0";
        output += day();

        output += "_";
        if (hour() < 10) output += "0";
        output += hour() + "-";
        if (minute() < 10) output += "0";
        output += minute() + "-";
        if (second() < 10) output += "0";
        output += second();

        return getFileName(output);
    }

    /**
      * @description Generate a file name for the EDF file with `str` string embedded
      *  within.
      * @param `s` {String} - The string to inject
      * @returns {String} - A fully qualified name of an output file with `str`.
      */
    private String getFileName(String s) {
        String output = settings.recordingsPath+"OpenBCI-BDF-";
        output += s;
        output += ".bdf";
        return output;
    }

    /**
      * @description Get's the number of signal channels to write out. Have to
      *  keep in mind that the annotations channel counts.
      * @returns {int} - The number of signals in the header.
      */
    private int getNbSignals() {
        if (eegDataSource == DATASOURCE_CYTON) {
            return nbChan + nbAux + nbAnnotations;
        } else {
            return nbChan + nbAnnotations;
        }

    }

    /**
      * @description Takes an array of strings and joins split by `delimiter`
      * @param `stringArray` {String []} - An array of strings
      * @param `delimiter` {String} - The delimiter to split the strings with
      * @returns `String` - All the strings from `stringArray` separated by
      *  `delimiter`.
      * @reference http://www.edfplus.info/specs/edf.html
      */
    private String joinStringArray(String[] stringArray, String delimiter) {
        String output = "";

        // Number of elecments to add
        int numberOfElements = stringArray.length;

        // Each element will be written
        for (int i = 0; i < numberOfElements; i++) {
            // Add the element
            output += stringArray[i];
            // Add a delimiter between
            output += delimiter;
        }

        return output;
    }

    /**
      * @description Used to combine a `str` (string) with left justification padding of `size`.
      * @param `s` {String} - The string to be inserted
      * @param `size` {int} - The total allowable size for `str` to be inserted.
      *  If `str.length()` < `size` then `str` will essentially be right padded with
      *  spaces till the `output` is of length `size`.
      * @returns {String} - The `str` right padded with spaces to become `size` length.
      */
    private String padStringRight(String s, int size) {
        char[] output = new char[size];
        int len = 0;
        if (s != null) len = s.length();
        for (int i = 0; i < size; i++) {
            if (i < len) {
                output[i] = s.charAt(i);
            } else {
                output[i] = ' ';
            }
        }
        return new String(output, 0, size);
    }

    /**
      * @description Sets the header per channel arrays to their default values
      */
    private void setAuxArraysToDefaults() {
        labelsAux[0] = "Accel X";
        labelsAux[1] = "Accel Y";
        labelsAux[2] = "Accel Z";
        setStringArray(transducerAux, BDF_HEADER_TRANSDUCER_MEMS, nbAux);
        setStringArray(physicalDimensionAux, BDF_HEADER_PHYSICAL_DIMENISION_G, nbAux);
        setStringArray(digitalMinimumAux, bdf_digital_minimum_ADC_12bit, nbAux);
        setStringArray(digitalMaximumAux, bdf_digital_maximum_ADC_12bit, nbAux);
        setStringArray(physicalMinimumAux, bdf_physical_minimum_ADC_Accel, nbAux);
        setStringArray(physicalMaximumAux, bdf_physical_maximum_ADC_Accel, nbAux);
        setStringArray(prefilteringAux, " ", nbAux);
        setStringArray(nbSamplesPerDataRecordAux, Integer.toString(fs_Hz), nbAux);
        setStringArray(reservedAux, " ", nbAux);
    }

    /**
      * @description Sets the header per channel arrays to their default values
      */
    private void setAnnotationsArraysToDefaults() {
        setStringArray(labelsAnnotations, BDF_HEADER_ANNOTATIONS, 1); // Leave space for the annotations space
        setStringArray(transducerAnnotations, " ", 1);
        setStringArray(physicalDimensionAnnotations, " ", 1);
        setStringArray(digitalMinimumAnnotations, bdf_digital_minimum_ADC_24bit, 1);
        setStringArray(digitalMaximumAnnotations, bdf_digital_maximum_ADC_24bit, 1);
        if (eegDataSource == DATASOURCE_GANGLION) {
            setStringArray(physicalMinimumAnnotations, bdf_physical_minimum_ADC_24bit_ganglion, 1);
            setStringArray(physicalMaximumAnnotations, bdf_physical_maximum_ADC_24bit_ganglion, 1);
        } else {
            setStringArray(physicalMinimumAnnotations, bdf_physical_minimum_ADC_24bit, 1);
            setStringArray(physicalMaximumAnnotations, bdf_physical_maximum_ADC_24bit, 1);
        }
        setStringArray(prefilteringAnnotations, " ", 1);
        nbSamplesPerDataRecordAnnotations[0] = Integer.toString(nbSamplesPerAnnontation);
        setStringArray(reservedAnnotations, " ", 1);
    }

    /**
      * @description Sets the header per channel arrays to their default values
      */
    private void setEEGArraysToDefaults() {
        for (int i = 1; i <= nbChan; i++) {
            labelsEEG[i - 1] = "EEG " + i;
        }
        setStringArray(transducerEEG, BDF_HEADER_TRANSDUCER_AGAGCL, nbChan);
        setStringArray(physicalDimensionEEG, BDF_HEADER_PHYSICAL_DIMENISION_UV, nbChan);
        setStringArray(digitalMinimumEEG, bdf_digital_minimum_ADC_24bit, nbChan);
        setStringArray(digitalMaximumEEG, bdf_digital_maximum_ADC_24bit, nbChan);
        setStringArray(physicalMinimumEEG, bdf_physical_minimum_ADC_24bit, nbChan);
        setStringArray(physicalMaximumEEG, bdf_physical_maximum_ADC_24bit, nbChan);
        setStringArray(prefilteringEEG, " ", nbChan);
        setStringArray(nbSamplesPerDataRecordEEG, Integer.toString(fs_Hz), nbChan);
        setStringArray(reservedEEG, " ", nbChan);
    }

    /**
      * @description Convience function to fill a string array with the same values
      * @param `arr` {String []} - A string array to fill
      * @param `val` {Stirng} - The string to be inserted into `arr`
      */
    private void setStringArray(String[] arr, String val, int len) {
        for (int i = 0; i < len; i++) {
            arr[i] = val;
        }
    }

    /**
      * @description Converts a byte from Big Endian to Little Endian
      * @param `val` {byte} - The byte to swap
      * @returns {byte} - The swapped byte.
      */
    private byte swapByte(byte val) {
        int mask = 0x80;
        int res = 0;
        // println("swapByte: starting to swap val: 0b" + binary(val,8));
        for (int i = 0; i < 8; i++) {
            // println("\nswapByte: i: " + i);
            // Isolate the MSB with a big mask i.e. 10000000, 01000000, etc...
            int temp = (val & mask);
            // println("swapByte: temp:    0b" + binary(temp,8));
            // Save this temp value
            res = (res >> 1) | (temp << i);
            // println("swapByte: res:     0b" + binary(res,8));
            // Move mask one place
            mask = mask >> 1;
            // println("swapByte: mask: 0b" + binary(mask,32));
        }
        // println("swapByte: ending swapped val: 0b" + binary(res,8));
        return (byte)res;
    }

    /**
      * @description Swaps any spaces for underscores because EDF+ calls for it
      * @param `s` {String} - A string containing spaces
      * @returns {String} - A string with underscores instead of spaces.
      * @reference http://www.edfplus.info/specs/edfplus.html#additionalspecs
      */
    private String swapSpacesForUnderscores(String s) {
        int len = s.length();
        char[] output = new char[len];
        // Loop through the String
        for (int i = 0; i < len; i++) {
            if (s.charAt(i) == ' ') {
                output[i] = '_';
            } else {
                output[i] = s.charAt(i);
            }
        }
        return new String(output, 0, len);
    }

    /**
      * @description Moves a packet worth of data into channel buffer, also converts
      *  from Big Endian to Little Indian as per the specs of BDF+.
      *  Ref [1]: http://www.biosemi.com/faq/file_format.htm
      * @param `values` {byte[][]} - A byte array that is n_chan X sample size (3)
      */
    private void writeChannelDataValues(byte[][] values) {
        for (int i = 0; i < nbChan; i++) {
            // Make the values little endian
            chanValBuf[i][samplesInDataRecord][0] = swapByte(values[i][2]);
            chanValBuf[i][samplesInDataRecord][1] = swapByte(values[i][1]);
            chanValBuf[i][samplesInDataRecord][2] = swapByte(values[i][0]);
        }
    }

    /**
      * @description Moves a packet worth of data into aux buffer, also converts
      *  from Big Endian to Little Indian as per the specs of BDF+.
      *  Ref [1]: http://www.biosemi.com/faq/file_format.htm
      * @param `values` {byte[][]} - A byte array that is n_aux X sample size (3)
      */
    private void writeAuxDataValues(byte[][] values) {
        for (int i = 0; i < nbAux; i++) {
            if (write_accel) {
                // grab the lower part of
                boolean zeroPack = true;
                // shift right
                int t = (int)values[i][0] & 0x0F;
                values[i][0] = (byte)((int)values[i][0] >> 4);
                if (values[i][0] >= 8) {
                    zeroPack = false;
                }
                values[i][1] = (byte)((int)values[i][1] >> 4);
                values[i][1] = (byte)((int)values[i][1] | t);
                if (!zeroPack) {
                    values[i][0] = (byte)((int)values[i][0] | 0xF0);
                }
                // make msb -> lsb
                auxValBuf[i][samplesInDataRecord][0] = swapByte(values[i][1]);
                auxValBuf[i][samplesInDataRecord][1] = swapByte(values[i][0]);
                // pad byte
                if (zeroPack) {
                    auxValBuf[i][samplesInDataRecord][2] = (byte)0x00;
                } else {
                    auxValBuf[i][samplesInDataRecord][2] = (byte)0xFF;
                }
            } else {
                // TODO: Implement once GUI gets support for non standard packets
            }
        }
    }

    /**
      * @description Writes data from a temp file over to the final file with the
      *  header in place already.
      *  TODO: Stop keeping it in memory.
      * @param `o` {OutputStream} - An output stream to write to.
      */
    private void writeData(OutputStream o) {

        InputStream input = createInput(tempWriterPrefix);

        try {
            println("writeData: started...");
            int data = input.read();
            int byteCount = 0;
            while (data != -1) {
                o.write(data);
                data = input.read();
                byteCount++;
                if (isVerbose) {
                    if (byteCount % (3*fs_Hz*nbChan) == 0) verbosePrint("+ 1 Second Of Data Written to BDF");
                }
            }
            verbosePrint("writeData: finished: wrote " + byteCount + " bytes");
            totalByteCount += byteCount;
            verbosePrint("Estimated file size == " + totalByteCount);
            totalByteCount = 0;
        }
        catch (IOException e) {
            print("writeData: ");
            e.printStackTrace();
        }
        finally {
            try {
                input.close();
            }
            catch (IOException e) {
                print("writeData: ");
                e.printStackTrace();
            }
        }
    }

    /**
      * @description Writes a fully qualified BDF+ header
      */
    private void writeHeader(OutputStream o) {
        // writer.write(0xFF); // Write the first byte of the header here
        try {
            // println("writeHeader: starting...");

            o.write(0xFF);
            writeString(padStringRight(new String(bdf_version),BDF_HEADER_SIZE_VERSION - 1), o); // Do one less then supposed to because of the first byte already written.
            String[] temp1  = {bdf_patient_id_subfield_hospoital_code,bdf_patient_id_subfield_sex,bdf_patient_id_subfield_birthdate,bdf_patient_id_subfield_name};
            writeString(padStringRight(joinStringArray(temp1, " "), BDF_HEADER_SIZE_PATIENT_ID), o);
            String[] temp2 = {bdf_recording_id_subfield_prefix,bdf_recording_id_subfield_startdate,bdf_recording_id_subfield_admin_code,bdf_recording_id_subfield_investigator,bdf_recording_id_subfield_equipment};
            writeString(padStringRight(joinStringArray(temp2, " "), BDF_HEADER_SIZE_RECORDING_ID), o);
            writeString(getDateString(startTime, startDateFormat), o);
            writeString(getDateString(startTime, startTimeFormat), o);
            writeString(padStringRight(Integer.toString(getBytesInHeader()),BDF_HEADER_SIZE_BYTES_IN_HEADER), o);
            verbosePrint("writeHeader: Bytes in header == " + getBytesInHeader());
            totalByteCount += getBytesInHeader();
            writeString(padStringRight("24BIT",BDF_HEADER_SIZE_RESERVED), o);//getContinuity(),BDF_HEADER_SIZE_RESERVED), o);
            writeString(padStringRight(Integer.toString(dataRecordsWritten),BDF_HEADER_SIZE_NUMBER_DATA_RECORDS), o);
            println("writeHeader: Writing " + dataRecordsWritten + " Seconds of Data to BDF");
            writeString(padStringRight("1",BDF_HEADER_SIZE_DURATION_OF_DATA_RECORD), o);
            writeString(padStringRight(Integer.toString(getNbSignals()),BDF_HEADER_SIZE_NUMBER_SIGNALS), o);

            writeStringArrayWithPaddingTimes(labelsEEG, BDF_HEADER_NS_SIZE_LABEL, o);
            if (eegDataSource == DATASOURCE_CYTON) writeStringArrayWithPaddingTimes(labelsAux, BDF_HEADER_NS_SIZE_LABEL, o);
            writeStringArrayWithPaddingTimes(labelsAnnotations, BDF_HEADER_NS_SIZE_LABEL, o);

            writeStringArrayWithPaddingTimes(transducerEEG, BDF_HEADER_NS_SIZE_TRANSDUCER_TYPE, o);
            if (eegDataSource == DATASOURCE_CYTON) writeStringArrayWithPaddingTimes(transducerAux, BDF_HEADER_NS_SIZE_TRANSDUCER_TYPE, o);
            writeStringArrayWithPaddingTimes(transducerAnnotations, BDF_HEADER_NS_SIZE_TRANSDUCER_TYPE, o);

            writeStringArrayWithPaddingTimes(physicalDimensionEEG, BDF_HEADER_NS_SIZE_PHYSICAL_DIMENSION, o);
            if (eegDataSource == DATASOURCE_CYTON) writeStringArrayWithPaddingTimes(physicalDimensionAux, BDF_HEADER_NS_SIZE_PHYSICAL_DIMENSION, o);
            writeStringArrayWithPaddingTimes(physicalDimensionAnnotations, BDF_HEADER_NS_SIZE_PHYSICAL_DIMENSION, o);

            writeStringArrayWithPaddingTimes(physicalMinimumEEG, BDF_HEADER_NS_SIZE_PHYSICAL_MINIMUM, o);
            if (eegDataSource == DATASOURCE_CYTON) writeStringArrayWithPaddingTimes(physicalMinimumAux, BDF_HEADER_NS_SIZE_PHYSICAL_MINIMUM, o);
            writeStringArrayWithPaddingTimes(physicalMinimumAnnotations, BDF_HEADER_NS_SIZE_PHYSICAL_MINIMUM, o);

            writeStringArrayWithPaddingTimes(physicalMaximumEEG, BDF_HEADER_NS_SIZE_PHYSICAL_MAXIMUM, o);
            if (eegDataSource == DATASOURCE_CYTON) writeStringArrayWithPaddingTimes(physicalMaximumAux, BDF_HEADER_NS_SIZE_PHYSICAL_MAXIMUM, o);
            writeStringArrayWithPaddingTimes(physicalMaximumAnnotations, BDF_HEADER_NS_SIZE_PHYSICAL_MAXIMUM, o);

            writeStringArrayWithPaddingTimes(digitalMinimumEEG, BDF_HEADER_NS_SIZE_DIGITAL_MINIMUM, o);
            if (eegDataSource == DATASOURCE_CYTON) writeStringArrayWithPaddingTimes(digitalMinimumAux, BDF_HEADER_NS_SIZE_DIGITAL_MINIMUM, o);
            writeStringArrayWithPaddingTimes(digitalMinimumAnnotations, BDF_HEADER_NS_SIZE_DIGITAL_MINIMUM, o);

            writeStringArrayWithPaddingTimes(digitalMaximumEEG, BDF_HEADER_NS_SIZE_DIGITAL_MAXIMUM, o);
            if (eegDataSource == DATASOURCE_CYTON) writeStringArrayWithPaddingTimes(digitalMaximumAux, BDF_HEADER_NS_SIZE_DIGITAL_MAXIMUM, o);
            writeStringArrayWithPaddingTimes(digitalMaximumAnnotations, BDF_HEADER_NS_SIZE_DIGITAL_MAXIMUM, o);

            writeStringArrayWithPaddingTimes(prefilteringEEG, BDF_HEADER_NS_SIZE_PREFILTERING, o);
            if (eegDataSource == DATASOURCE_CYTON) writeStringArrayWithPaddingTimes(prefilteringAux, BDF_HEADER_NS_SIZE_PREFILTERING, o);
            writeStringArrayWithPaddingTimes(prefilteringAnnotations, BDF_HEADER_NS_SIZE_PREFILTERING, o);

            writeStringArrayWithPaddingTimes(nbSamplesPerDataRecordEEG, BDF_HEADER_NS_SIZE_NR, o);
            if (eegDataSource == DATASOURCE_CYTON) writeStringArrayWithPaddingTimes(nbSamplesPerDataRecordAux, BDF_HEADER_NS_SIZE_NR, o);
            writeStringArrayWithPaddingTimes(nbSamplesPerDataRecordAnnotations, BDF_HEADER_NS_SIZE_NR, o);

            writeStringArrayWithPaddingTimes(reservedEEG, BDF_HEADER_NS_SIZE_RESERVED, o);
            if (eegDataSource == DATASOURCE_CYTON) writeStringArrayWithPaddingTimes(reservedAux, BDF_HEADER_NS_SIZE_RESERVED, o);
            writeStringArrayWithPaddingTimes(reservedAnnotations, BDF_HEADER_NS_SIZE_RESERVED, o);

            // println("writeHeader: done...");

        } catch(Exception e) {
            println("writeHeader: Exception " + e);
        }
    }

    /**
      * @description Write out an array of strings with `padding` on each element.
      *  Each element is padded right.
      * @param `arr` {String []} - An array of strings to write out
      * @param `padding` {int} - The amount of padding for each `arr` element.
      * @param `o` {OutputStream} - The output stream to write to.
      */
    private void writeStringArrayWithPaddingTimes(String[] arr, int padding, OutputStream o) {
        int len = arr.length;
        for (int i = 0; i < len; i++) {
            writeString(padStringRight(arr[i], padding), o);
        }
    }

    /**
      * @description Writes a string to an OutputStream s
      * @param `s` {String} - The string to write.
      * @param `o` {OutputStream} - The output stream to write to.
      */
    private void writeString(String s, OutputStream o) {
        int len = s.length();
        try {
            for (int i = 0; i < len; i++) {
                o.write((int)s.charAt(i));
            }
        } catch (Exception e) {
            println("writeString: exception: " + e);
        }
    }

};

///////////////////////////////////////////////////////////////
//
// Class: Table_CSV
// Purpose: Extend the Table class to handle data files with comment lines
// Created: Chip Audette  May 2, 2014
//
// Usage: Only invoke this object when you want to read in a data
//    file in CSV format.  Read it in at the time of creation via
//
//    String fname = "myfile.csv";
//    TableCSV myTable = new TableCSV(fname);
//
///////////////////////////////////////////////////////////////

class Table_CSV extends Table {
    private int sampleRate;
    public int getSampleRate() { return sampleRate; }
    Table_CSV(String fname) throws IOException {
        init();
        readCSV(PApplet.createReader(createInput(fname)));
    }

    //this function is nearly completely copied from parseBasic from Table.java
    public void readCSV(BufferedReader reader) throws IOException {
        boolean header=false;  //added by Chip, May 2, 2014;
        boolean tsv = false;  //added by Chip, May 2, 2014;

        String line = null;
        int row = 0;
        if (rowCount == 0) {
            setRowCount(10);
        }
        //int prev = 0;  //-1;
        try {
            while ( (line = reader.readLine ()) != null) {
                //added by Chip, May 2, 2014 to ignore lines that are comments
                if (line.charAt(0) == '%') {
                    if (line.length() > 18) {
                        if (line.charAt(1) == 'S') {
                            sampleRate = Integer.parseInt(line.substring(15, 18));
                            if (sampleRate == 100 || sampleRate == 160) {
                                sampleRate = Integer.parseInt(line.substring(15, 19));
                            }
                            println("Sample rate set to " + sampleRate);
                        }
                    }
                    println("readCSV: " + line);
                    continue;
                }

                if (row == getRowCount()) {
                    setRowCount(row << 1);
                }
                if (row == 0 && header) {
                    setColumnTitles(tsv ? PApplet.split(line, '\t') : split(line,','));
                    header = false;
                }
                else {
                    setRow(row, tsv ? PApplet.split(line, '\t') : split(line,','));
                    row++;
                }

                // this is problematic unless we're going to calculate rowCount first
                if (row % 10000 == 0) {
                    try {
                        // Sleep this thread so that the GC can catch up
                        Thread.sleep(10);
                    }
                    catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        } catch (Exception e) {
            throw new RuntimeException("Error reading table on line " + row, e);
        }
        // shorten or lengthen based on what's left
        if (row != getRowCount()) {
            setRowCount(row);
        }
    }
}

//////////////////////////////////
//
//    This collection of functions/methods - convertSDFile, createPlaybackFileFromSD, & sdFileSelected - contains code
//    used to convert HEX files (stored by OpenBCI on the local SD) into text files that can be used for PLAYBACK mode.
//    Created: Conor Russomanno - 10/22/14 (based on code written by Joel Murphy summer 2014)
//    Updated: Joel Murphy - 6/26/17
//
//////////////////////////////////

//variables for SD file conversion
BufferedReader dataReader;
String dataLine;
PrintWriter dataWriter;
String h;
float[] floatData = new float[20];
float[] intData = new float[20];
String logFileName;
String[] hexNums;
long thisTime;
long thatTime;
boolean printNextLine = false;

public void convertSDFile() {
    try {
        dataLine = dataReader.readLine();
    }
    catch (IOException e) {
        e.printStackTrace();
        dataLine = null;
    }

    if (dataLine == null) {
        // Stop reading because of an error or file is empty
        thisTime = millis() - thatTime;
        controlPanel.convertingSD = false;
        println("nothing left in file");
        println("SD file conversion took "+thisTime+" mS");
        outputSuccess("SD file converted to " + logFileName);
        dataWriter.flush();
        dataWriter.close();
    }
        else
    {
        hexNums = splitTokens(dataLine, ",");

        if (hexNums[0].charAt(0) == '%') {
            //          println(dataLine);
            // dataWriter.println(dataLine);
            println("convertSDFile: " + dataLine);
            printNextLine = true;
        } else {
            if (hexNums.length < 13){
                convert8channelLine();
            } else {
                convert16channelLine();
            }
            if(printNextLine){
                printNextLine = false;
            }
        }
    }
}

public void convert16channelLine() {
    String consoleMsg = "";
    if(printNextLine){
        for(int i=0; i<hexNums.length; i++){
            h = hexNums[i];
            if (h.length()%2 == 0 && h.length() <= 10) {  // make sure this is a real number
                intData[i] = unhex(h);
            } else {
                intData[i] = 0;
            }
            dataWriter.print(intData[i]);
            consoleMsg = Integer.toString(PApplet.parseInt(intData[i]));
            if(hexNums.length > 1){
                dataWriter.print(", ");
                consoleMsg += ", ";
            }
        }
        dataWriter.println();
        println("convert16channelLine: " + consoleMsg);
        return;
    }
    for (int i=0; i<hexNums.length; i++) {
        h = hexNums[i];
        if (i > 0) {
            if (h.charAt(0) > '7') {  // if the number is negative
                h = "FF" + hexNums[i];   // keep it negative
            } else {                  // if the number is positive
                h = "00" + hexNums[i];   // keep it positive
            }
            if (i > 16) { // accelerometer data needs another byte
                if (h.charAt(0) == 'F') {
                    h = "FF" + h;
                } else {
                    h = "00" + h;
                }
            }
        }
        // println(h); // use for debugging
        if (h.length()%2 == 0 && h.length() <= 10) {  // make sure this is a real number
            floatData[i] = unhex(h);
        } else {
            floatData[i] = 0;
        }

        if (i>=1 && i<=16) {
            floatData[i] *= cyton.get_scale_fac_uVolts_per_count();
        }else if(i != 0){
            floatData[i] *= cyton.get_scale_fac_accel_G_per_count();
        }

        if(i == 0){
            dataWriter.print(PApplet.parseInt(floatData[i]));  // print the sample counter
        }else{
            dataWriter.print(floatData[i]);  // print the current channel value
        }
        if (i < hexNums.length-1) {  // print the current channel value
            dataWriter.print(",");  // print "," separator
        }
    }
    dataWriter.println();
}

public void convert8channelLine() {
    String consoleMsg = "";
    if(printNextLine){
        for(int i=0; i<hexNums.length; i++){
            h = hexNums[i];
            if (h.length()%2 == 0) {  // make sure this is a real number
                intData[i] = unhex(h);
            } else {
                intData[i] = 0;
            }
            consoleMsg = str(PApplet.parseInt(intData[i]));
            dataWriter.print(intData[i]);
            if(hexNums.length > 1){
                dataWriter.print(", ");
                consoleMsg += ", ";
            }
        }
        dataWriter.println();
        println("convert8channelLine: " + consoleMsg);
        return;
    }
    for (int i=0; i<hexNums.length; i++) {
        h = hexNums[i];
        if (i > 0) {
            if (h.charAt(0) > '7') {  // if the number is negative
                h = "FF" + hexNums[i];   // keep it negative
            } else {                  // if the number is positive
                h = "00" + hexNums[i];   // keep it positive
            }
            if (i > 8) { // accelerometer data needs another byte
                if (h.charAt(0) == 'F') {
                    h = "FF" + h;
                } else {
                    h = "00" + h;
                }
            }
        }
        // println(h + " " + h.length()); // use for debugging
        if (h.length() > 8) {
            break;
        }
        if (h.length()%2 == 0) {  // make sure this is a real number
            floatData[i] = unhex(h);
        } else {
            floatData[i] = 0;
        }

        if (i>=1 && i<=8) {
            floatData[i] *= cyton.get_scale_fac_uVolts_per_count();
        }else if(i != 0){
            floatData[i] *= cyton.get_scale_fac_accel_G_per_count();
        }

        if(i == 0){
            dataWriter.print(PApplet.parseInt(floatData[i]));  // print the sample counter
        }else{
            dataWriter.print(floatData[i]);  // print the current channel value
        }
        if (i < hexNums.length-1) {
            dataWriter.print(",");  // print "," separator
        }
    }
    dataWriter.println();
}

//------------------------------------------------------------------------
//                       Global Variables & Instances
//------------------------------------------------------------------------
 //for FFT

DataProcessing dataProcessing;
String curTimestamp;
boolean hasRepeated = false;
HashMap<Integer,String> index_of_times;

// indexes
final int DELTA = 0; // 1-4 Hz
final int THETA = 1; // 4-8 Hz
final int ALPHA = 2; // 8-13 Hz
final int BETA = 3; // 13-30 Hz
final int GAMMA = 4; // 30-55 Hz

float playback_speed_fac = 1.0f;  //make 1.0 for real-time.  larger for faster playback

//------------------------------------------------------------------------
//                       Global Functions
//------------------------------------------------------------------------

//called from systemUpdate when mode=10 and isRunning = true
public void process_input_file() throws Exception {
    index_of_times = new HashMap<Integer, String>();
    indices = 0;
    try {
        while (!hasRepeated) {
            currentTableRowIndex = getPlaybackDataFromTable(playbackData_table, currentTableRowIndex, cyton.get_scale_fac_uVolts_per_count(), cyton.get_scale_fac_accel_G_per_count(), dataPacketBuff[lastReadDataPacketInd]);
            if (curTimestamp != null) {
                index_of_times.put(indices, curTimestamp.substring(1)); //remove white space from timestamp
            } else {
                index_of_times.put(indices, "notFound");
            }
            indices++;
        }
        println("number of indexes "+indices);
        println("Finished filling hashmap");
        has_processed = true;
    }
    catch (Exception e) {
        e.printStackTrace();
        throw new Exception();
    }
}

/*************************/
public int getDataIfAvailable(int pointCounter) {

    if (eegDataSource == DATASOURCE_CYTON) {
        //get data from serial port as it streams in
        //next, gather any new data into the "little buffer"
        while ( (curDataPacketInd != lastReadDataPacketInd) && (pointCounter < nPointsPerUpdate)) {
            lastReadDataPacketInd = (lastReadDataPacketInd+1) % dataPacketBuff.length;  //increment to read the next packet
            for (int Ichan=0; Ichan < nchan; Ichan++) {   //loop over each cahnnel
                //scale the data into engineering units ("microvolts") and save to the "little buffer"
                yLittleBuff_uV[Ichan][pointCounter] = dataPacketBuff[lastReadDataPacketInd].values[Ichan] * cyton.get_scale_fac_uVolts_per_count();
            }
            for (int auxChan=0; auxChan < 3; auxChan++) auxBuff[auxChan][pointCounter] = dataPacketBuff[lastReadDataPacketInd].auxValues[auxChan];
            pointCounter++; //increment counter for "little buffer"
        }
    } else if (eegDataSource == DATASOURCE_GANGLION) {
        //get data from ble as it streams in
        //next, gather any new data into the "little buffer"
        while ( (curDataPacketInd != lastReadDataPacketInd) && (pointCounter < nPointsPerUpdate)) {
            lastReadDataPacketInd = (lastReadDataPacketInd + 1) % dataPacketBuff.length;  //increment to read the next packet
            for (int Ichan=0; Ichan < nchan; Ichan++) {   //loop over each cahnnel
                //scale the data into engineering units ("microvolts") and save to the "little buffer"
                yLittleBuff_uV[Ichan][pointCounter] = dataPacketBuff[lastReadDataPacketInd].values[Ichan] * ganglion.get_scale_fac_uVolts_per_count();
            }
            pointCounter++; //increment counter for "little buffer"
        }

    } else {
        // make or load data to simulate real time

        //has enough time passed?
        int current_millis = millis();
        if (current_millis >= nextPlayback_millis) {
            //prepare for next time
            int increment_millis = PApplet.parseInt(round(PApplet.parseFloat(nPointsPerUpdate)*1000.f/getSampleRateSafe())/playback_speed_fac);
            if (nextPlayback_millis < 0) nextPlayback_millis = current_millis;
            nextPlayback_millis += increment_millis;

            // generate or read the data
            lastReadDataPacketInd = 0;
            for (int i = 0; i < nPointsPerUpdate; i++) {
                dataPacketBuff[lastReadDataPacketInd].sampleIndex++;
                switch (eegDataSource) {
                case DATASOURCE_SYNTHETIC: //use synthetic data (for GUI debugging)
                    synthesizeData(nchan, getSampleRateSafe(), cyton.get_scale_fac_uVolts_per_count(), dataPacketBuff[lastReadDataPacketInd]);
                    break;
                case DATASOURCE_PLAYBACKFILE:
                    currentTableRowIndex=getPlaybackDataFromTable(playbackData_table, currentTableRowIndex, cyton.get_scale_fac_uVolts_per_count(), cyton.get_scale_fac_accel_G_per_count(), dataPacketBuff[lastReadDataPacketInd]);
                    break;
                default:
                    //no action
                }
                //gather the data into the "little buffer"
                for (int Ichan=0; Ichan < nchan; Ichan++) {
                    //scale the data into engineering units..."microvolts"
                    yLittleBuff_uV[Ichan][pointCounter] = dataPacketBuff[lastReadDataPacketInd].values[Ichan]* cyton.get_scale_fac_uVolts_per_count();
                }

                pointCounter++;
            } //close the loop over data points
        } // close "has enough time passed"
    }
    return pointCounter;
}

RunningMean avgBitRate = new RunningMean(10);  //10 point running average...at 5 points per second, this should be 2 second running average

public void processNewData() {

    //compute instantaneous byte rate
    float inst_byteRate_perSec = (int)(1000.f * ((float)(openBCI_byteCount - prevBytes)) / ((float)(millis() - prevMillis)));

    prevMillis=millis();           //store for next time
    prevBytes = openBCI_byteCount; //store for next time

    //compute smoothed byte rate
    avgBitRate.addValue(inst_byteRate_perSec);
    byteRate_perSec = (int)avgBitRate.calcMean();

    //update the data buffers
    for (int Ichan=0; Ichan < nchan; Ichan++) {
        //append the new data to the larger data buffer...because we want the plotting routines
        //to show more than just the most recent chunk of data.  This will be our "raw" data.
        appendAndShift(dataBuffY_uV[Ichan], yLittleBuff_uV[Ichan]);

        //make a copy of the data that we'll apply processing to.  This will be what is displayed on the full montage
        dataBuffY_filtY_uV[Ichan] = dataBuffY_uV[Ichan].clone();
    }

    //if you want to, re-reference the montage to make it be a mean-head reference
    if (false) rereferenceTheMontage(dataBuffY_filtY_uV);

    //apply additional processing for the time-domain montage plot (ie, filtering)
    dataProcessing.process(yLittleBuff_uV, dataBuffY_uV, dataBuffY_filtY_uV, fftBuff);

    dataProcessing_user.process(yLittleBuff_uV, dataBuffY_uV, dataBuffY_filtY_uV, fftBuff);
    dataProcessing.newDataToSend = true;

    //look to see if the latest data is railed so that we can notify the user on the GUI
    for (int Ichan=0; Ichan < nchan; Ichan++) is_railed[Ichan].update(dataPacketBuff[lastReadDataPacketInd].values[Ichan]);

    //compute the electrode impedance. Do it in a very simple way [rms to amplitude, then uVolt to Volt, then Volt/Amp to Ohm]
    for (int Ichan=0; Ichan < nchan; Ichan++) {
        // Calculate the impedance
        float impedance = (sqrt(2.0f)*dataProcessing.data_std_uV[Ichan]*1.0e-6f) / cyton.get_leadOffDrive_amps();
        // Subtract the 2.2kOhm resistor
        impedance -= cyton.get_series_resistor();
        // Verify the impedance is not less than 0
        if (impedance < 0) {
            // Incase impedance some how dipped below 2.2kOhm
            impedance = 0;
        }
        // Store to the global variable
        data_elec_imp_ohm[Ichan] = impedance;
    }
}

//helper function in handling the EEG data
public void appendAndShift(float[] data, float[] newData) {
    int nshift = newData.length;
    int end = data.length-nshift;
    for (int i=0; i < end; i++) {
        data[i]=data[i+nshift];  //shift data points down by 1
    }
    for (int i=0; i<nshift; i++) {
        data[end+i] = newData[i];  //append new data
    }
}

//help append and shift a single data
public void appendAndShift(float[] data, float newData) {
    int nshift = 1;
    int end = data.length-nshift;
    for (int i=0; i < end; i++) {
        data[i]=data[i+nshift];  //shift data points down by 1
    }
    data[end] = newData;  //append new data
}

final float sine_freq_Hz = 10.0f;
float[] sine_phase_rad = new float[nchan];

public void synthesizeData(int nchan, float fs_Hz, float scale_fac_uVolts_per_count, DataPacket_ADS1299 curDataPacket) {
    float val_uV;
    for (int Ichan=0; Ichan < nchan; Ichan++) {
        if (isChannelActive(Ichan)) {
            val_uV = randomGaussian()*sqrt(fs_Hz/2.0f); // ensures that it has amplitude of one unit per sqrt(Hz) of signal bandwidth
            if (Ichan==0) val_uV*= 10f;  //scale one channel higher

            if (Ichan==1) {
                //add sine wave at 10 Hz at 10 uVrms
                sine_phase_rad[Ichan] += 2.0f*PI * sine_freq_Hz / fs_Hz;
                if (sine_phase_rad[Ichan] > 2.0f*PI) sine_phase_rad[Ichan] -= 2.0f*PI;
                val_uV += 10.0f * sqrt(2.0f)*sin(sine_phase_rad[Ichan]);
            } else if (Ichan==2) {
                //50 Hz interference at 50 uVrms
                sine_phase_rad[Ichan] += 2.0f*PI * 50.0f / fs_Hz;  //60 Hz
                if (sine_phase_rad[Ichan] > 2.0f*PI) sine_phase_rad[Ichan] -= 2.0f*PI;
                val_uV += 50.0f * sqrt(2.0f)*sin(sine_phase_rad[Ichan]);    //20 uVrms
            } else if (Ichan==3) {
                //60 Hz interference at 50 uVrms
                sine_phase_rad[Ichan] += 2.0f*PI * 60.0f / fs_Hz;  //50 Hz
                if (sine_phase_rad[Ichan] > 2.0f*PI) sine_phase_rad[Ichan] -= 2.0f*PI;
                val_uV += 50.0f * sqrt(2.0f)*sin(sine_phase_rad[Ichan]);  //20 uVrms
            }
        } else {
            val_uV = 0.0f;
        }
        curDataPacket.values[Ichan] = (int) (0.5f+ val_uV / scale_fac_uVolts_per_count); //convert to counts, the 0.5 is to ensure rounding
    }
}

//some data initialization routines
public void prepareData(float[] dataBuffX, float[][] dataBuffY_uV, float fs_Hz) {
    //initialize the x and y data
    int xoffset = dataBuffX.length - 1;
    for (int i=0; i < dataBuffX.length; i++) {
        dataBuffX[i] = ((float)(i-xoffset)) / fs_Hz; //x data goes from minus time up to zero
        for (int Ichan = 0; Ichan < nchan; Ichan++) {
            dataBuffY_uV[Ichan][i] = 0f;  //make the y data all zeros
        }
    }
}


public void initializeFFTObjects(FFT[] fftBuff, float[][] dataBuffY_uV, int Nfft, float fs_Hz) {

    float[] fooData;
    for (int Ichan=0; Ichan < nchan; Ichan++) {
        //make the FFT objects...Following "SoundSpectrum" example that came with the Minim library
        fftBuff[Ichan].window(FFT.HAMMING);

        //do the FFT on the initial data
        if (isFFTFiltered == true) {
            fooData = dataBuffY_filtY_uV[Ichan];  //use the filtered data for the FFT
        } else {
            fooData = dataBuffY_uV[Ichan];  //use the raw data for the FFT
        }
        fooData = Arrays.copyOfRange(fooData, fooData.length-Nfft, fooData.length);
        fftBuff[Ichan].forward(fooData); //compute FFT on this channel of data
    }
}


public int getPlaybackDataFromTable(Table datatable, int currentTableRowIndex, float scale_fac_uVolts_per_count, float scale_fac_accel_G_per_count, DataPacket_ADS1299 curDataPacket) {
    float val_uV = 0.0f;
    float[] acc_G = new float[n_aux_ifEnabled];
    boolean acc_newData = false;

    //check to see if we can load a value from the table
    if (currentTableRowIndex >= datatable.getRowCount()) {
        //end of file
        println("OpenBCI_GUI: getPlaybackDataFromTable: End of playback data file.  Starting over...");
        hasRepeated = true;
        currentTableRowIndex = 0;
    } else {
        //get the row
        TableRow row = datatable.getRow(currentTableRowIndex);
        currentTableRowIndex++; //increment to the next row

        //get each value
        for (int Ichan=0; Ichan < nchan; Ichan++) {
            if (isChannelActive(Ichan) && (Ichan < datatable.getColumnCount())) {
                val_uV = row.getFloat(Ichan);
            } else {
                //use zeros for the missing channels
                val_uV = 0.0f;
            }

            //put into data structure
            curDataPacket.values[Ichan] = (int) (0.5f+ val_uV / scale_fac_uVolts_per_count); //convert to counts, the 0.5 is to ensure rounding
        }

        // get accelerometer data
        try{
            for (int Iacc=0; Iacc < n_aux_ifEnabled; Iacc++) {

                if (Iacc < datatable.getColumnCount()) {
                    acc_G[Iacc] = row.getFloat(Iacc + nchan);
                    if (Float.isNaN(acc_G[Iacc])) {
                        acc_G[Iacc] = 0.0f;
                    }
                } else {
                    //use zeros for bad data :)
                    acc_G[Iacc] = 0.0f;
                }

                //put into data structure
                curDataPacket.auxValues[Iacc] = (int) (0.5f+ acc_G[Iacc] / scale_fac_accel_G_per_count); //convert to counts, the 0.5 is to ensure rounding

                // Wangshu Dec.6 2016
                // as long as xyz are not zero at the same time, it should be fine...otherwise it will ignore it.
                if (acc_G[Iacc] > 0.000001f) {
                    acc_newData = true;
                }
            }
        } catch (ArrayIndexOutOfBoundsException e){
        // println("Data does not exist... possibly an old file.");
        }
        if (acc_newData) {
            for (int Iacc=0; Iacc < n_aux_ifEnabled; Iacc++) {
                appendAndShift(accelerometerBuff[Iacc], acc_G[Iacc]);
            }
        }
        // if available, get time stamp for use in playback
        if (row.getColumnCount() >= nchan + NUM_ACCEL_DIMS + 2) {
            try{
                if (!isOldData) curTimestamp = row.getString(row.getColumnCount() - 1);
            } catch (ArrayIndexOutOfBoundsException e) {
                println("Data does not exist... possibly an old file.");
            }
        } else {
            curTimestamp = "-1";
        }
    } //end else
    return currentTableRowIndex;
}

//------------------------------------------------------------------------
//                          CLASSES
//------------------------------------------------------------------------

class DataProcessing {
    private float fs_Hz;  //sample rate
    private int nchan;
    final int N_FILT_CONFIGS = 5;
    FilterConstants[] filtCoeff_bp = new FilterConstants[N_FILT_CONFIGS];
    final int N_NOTCH_CONFIGS = 3;
    FilterConstants[] filtCoeff_notch = new FilterConstants[N_NOTCH_CONFIGS];
    private int currentFilt_ind = 3;
    private int currentNotch_ind = 0;  // set to 0 to default to 60Hz, set to 1 to default to 50Hz
    float data_std_uV[];
    float polarity[];
    boolean newDataToSend;
    final int[] processing_band_low_Hz = {
        1, 4, 8, 13, 30
    }; //lower bound for each frequency band of interest (2D classifier only)
    final int[] processing_band_high_Hz = {
        4, 8, 13, 30, 55
    };  //upper bound for each frequency band of interest
    float avgPowerInBins[][];
    float headWidePower[];

    DataProcessing(int NCHAN, float sample_rate_Hz) {
        nchan = NCHAN;
        fs_Hz = sample_rate_Hz;
        data_std_uV = new float[nchan];
        polarity = new float[nchan];
        newDataToSend = false;
        avgPowerInBins = new float[nchan][processing_band_low_Hz.length];
        headWidePower = new float[processing_band_low_Hz.length];

        defineFilters();  //define the filters anyway just so that the code doesn't bomb
    }

    //define filters depending on the sampling rate
    private void defineFilters() {
        int n_filt;
        double[] b, a, b2, a2;
        String filt_txt, filt_txt2;
        String short_txt, short_txt2;

        //------------ loop over all of the pre-defined filter types -----------
        //------------ notch filters ------------
        n_filt = filtCoeff_notch.length;
        for (int Ifilt=0; Ifilt < n_filt; Ifilt++) {
            switch (Ifilt) {
                case 0:
                    //60 Hz notch filter, 2nd Order Butterworth: [b, a] = butter(2,[59.0 61.0]/(fs_Hz / 2.0), 'stop') %matlab command
                    switch(PApplet.parseInt(fs_Hz)) {
                        case 125:
                            b2 = new double[] { 0.931378858122982f, 3.70081291785747f, 5.53903191270520f, 3.70081291785747f, 0.931378858122982f };
                            a2 = new double[] { 1, 3.83246204081167f, 5.53431749515949f, 3.56916379490328f, 0.867472133791669f };
                            break;
                        case 200:
                            b2 = new double[] { 0.956543225556877f, 1.18293615779028f, 2.27881429174348f, 1.18293615779028f, 0.956543225556877f };
                            a2 = new double[] { 1, 1.20922304075909f, 2.27692490805580f, 1.15664927482146f, 0.914975834801436f };
                            break;
                        case 250:
                            b2 = new double[] { 0.965080986344733f, -0.242468320175764f, 1.94539149412878f, -0.242468320175764f, 0.965080986344733f };
                            a2 = new double[] { 1, -0.246778261129785f, 1.94417178469135f, -0.238158379221743f, 0.931381682126902f };
                            break;
                        case 500:
                            b2 = new double[] { 0.982385438526095f, -2.86473884662109f, 4.05324051877773f, -2.86473884662109f, 0.982385438526095f};
                            a2 = new double[] { 1, -2.89019558531207f, 4.05293022193077f, -2.83928210793009f, 0.965081173899134f };
                            break;
                        case 1000:
                            b2 = new double[] { 0.991153595101611f, -3.68627799048791f, 5.40978944177152f, -3.68627799048791f, 0.991153595101611f };
                            a2 = new double[] { 1, -3.70265590760266f, 5.40971118136100f, -3.66990007337352f, 0.982385450614122f };
                            break;
                        case 1600:
                            b2 = new double[] { 0.994461788958027f, -3.86796874670208f, 5.75004904085114f, -3.86796874670208f, 0.994461788958027f };
                            a2 = new double[] { 1, -3.87870938463296f, 5.75001836883538f, -3.85722810877252f, 0.988954249933128f };
                            break;
                        default:
                            println("EEG_Processing: *** ERROR *** Filters can only work at 125Hz, 200Hz, 250 Hz, 1000Hz or 1600Hz");
                            b2 = new double[] { 1.0f };
                            a2 = new double[] { 1.0f };
                    }
                    filtCoeff_notch[Ifilt] =  new FilterConstants(b2, a2, "Notch 60Hz", "60Hz");
                    break;
                case 1:
                    //50 Hz notch filter, 2nd Order Butterworth: [b, a] = butter(2,[49.0 51.0]/(fs_Hz / 2.0), 'stop')
                    switch(PApplet.parseInt(fs_Hz)) {
                        case 125:
                            b2 = new double[] { 0.931378858122983f, 3.01781693143160f, 4.30731047590091f, 3.01781693143160f, 0.931378858122983f };
                            a2 = new double[] { 1, 3.12516981877757f, 4.30259605835520f, 2.91046404408562f, 0.867472133791670f };
                            break;
                        case 200:
                            b2 = new double[] { 0.956543225556877f, -2.34285519884863e-16f, 1.91308645111375f, -2.34285519884863e-16f, 0.956543225556877f };
                            a2 = new double[] { 1, -1.41553435639707e-15f, 1.91119706742607f, -1.36696209906972e-15f, 0.914975834801435f };
                            break;
                        case 250:
                            b2 = new double[] { 0.965080986344734f, -1.19328255433335f, 2.29902305135123f, -1.19328255433335f, 0.965080986344734f };
                            a2 = new double[] { 1, -1.21449347931898f, 2.29780334191380f, -1.17207162934771f, 0.931381682126901f };
                            break;
                        case 500:
                            b2 = new double[] { 0.982385438526090f, -3.17931708468811f, 4.53709552901242f, -3.17931708468811f, 0.982385438526090f };
                            a2 = new double[] { 1, -3.20756923909868f, 4.53678523216547f, -3.15106493027754f, 0.965081173899133f };
                            break;
                        case 1000:
                            b2 = new double[] { 0.991153595101607f, -3.77064677042206f, 5.56847615976560f, -3.77064677042206f, 0.991153595101607f };
                            a2 = new double[] { 1, -3.78739953308251f, 5.56839789935513f, -3.75389400776205f, 0.982385450614127f };
                            break;
                        case 1600:
                            b2 = new double[] { 0.994461788958316f, -3.90144402068168f, 5.81543195046478f, -3.90144402068168f, 0.994461788958316f };
                            a2 = new double[] { 1, -3.91227761329151f, 5.81540127844733f, -3.89061042807090f, 0.988954249933127f };
                            break;
                        default:
                            println("EEG_Processing: *** ERROR *** Filters can only work at 125Hz, 200Hz, 250 Hz, 1000Hz or 1600Hz");
                            b2 = new double[] { 1.0f };
                            a2 = new double[] { 1.0f };
                    }
                    filtCoeff_notch[Ifilt] =  new FilterConstants(b2, a2, "Notch 50Hz", "50Hz");
                    break;
                case 2:
                    //no notch filter
                    b2 = new double[] { 1.0f };
                    a2 = new double[] { 1.0f };
                    filtCoeff_notch[Ifilt] =  new FilterConstants(b2, a2, "No Notch", "None");
                    break;
                }
            }// end loop over notch filters

            //------------ bandpass filters ------------
            n_filt = filtCoeff_bp.length;
            for (int Ifilt=0; Ifilt<n_filt; Ifilt++) {
                //define bandpass filter
                switch (Ifilt) {
                case 0:
                    //1-50 Hz band pass filter, 2nd Order Butterworth: [b, a] = butter(2,[1.0 50.0]/(fs_Hz / 2.0))
                    switch(PApplet.parseInt(fs_Hz)) {
                        case 125:
                            b = new double[] { 0.615877232553135f, 0, -1.23175446510627f, 0, 0.615877232553135f };
                            a = new double[] { 1, -0.789307541613509f, -0.853263915766877f, 0.263710995896442f, 0.385190413112446f };
                            break;
                        case 200:
                            b = new double[] { 0.283751216219319f, 0, -0.567502432438638f, 0, 0.283751216219319f };
                            a = new double[] { 1, -1.97380379923172f, 1.17181238127012f, -0.368664525962831f, 0.171812381270120f };
                            break;
                        case 250:
                            b = new double[] { 0.200138725658073f, 0, -0.400277451316145f, 0, 0.200138725658073f };
                            a = new double[] { 1, -2.35593463113158f, 1.94125708865521f, -0.784706375533419f, 0.199907605296834f };
                            break;
                        case 500:
                            b = new double[] { 0.0652016551604422f, 0, -0.130403310320884f, 0, 0.0652016551604422f };
                            a = new double[] { 1, -3.14636562553919f, 3.71754597063790f, -1.99118301927812f, 0.420045500522989f };
                            break;
                        case 1000:
                            b = new double[] { 0.0193615659240911f, 0, -0.0387231318481823f, 0, 0.0193615659240911f };
                            a = new double[] { 1, -3.56607203834158f, 4.77991824545949f, -2.86091191298975f, 0.647068888346475f };
                            break;
                        case 1600:
                            b = new double[] { 0.00812885687466408f, 0, -0.0162577137493282f, 0, 0.00812885687466408f };
                            a = new double[] { 1, -3.72780746887970f, 5.21756471024747f, -3.25152171857009f, 0.761764999239264f };
                            break;
                        default:
                            println("EEG_Processing: *** ERROR *** Filters can only work at 125Hz, 200Hz, 250 Hz, 1000Hz or 1600Hz");
                            b = new double[] { 1.0f };
                            a = new double[] { 1.0f };
                    }
                    filt_txt = "Bandpass 1-50Hz";
                    short_txt = "1-50 Hz";
                    break;
                case 1:
                    //7-13 Hz band pass filter, 2nd Order Butterworth: [b, a] = butter(2,[7.0 13.0]/(fs_Hz / 2.0))
                    switch(PApplet.parseInt(fs_Hz)) {
                        case 125:
                            b = new double[] { 0.0186503962278349f, 0, -0.0373007924556699f, 0, 0.0186503962278349f };
                            a = new double[] { 1, -3.17162467236842f, 4.11670870329067f, -2.55619949640702f, 0.652837763407545f };
                            break;
                        case 200:
                            b = new double[] { 0.00782020803349772f, 0, -0.0156404160669954f, 0, 0.00782020803349772f };
                            a = new double[] { 1, -3.56776916484310f, 4.92946172209398f, -3.12070317627516f, 0.766006600943265f };
                            break;
                        case 250:
                            b = new double[] { 0.00512926836610803f, 0, -0.0102585367322161f, 0, 0.00512926836610803f };
                            a = new double[] { 1, -3.67889546976404f, 5.17970041352212f, -3.30580189001670f, 0.807949591420914f };
                            break;
                        case 500:
                            b = new double[] { 0.00134871194834618f, 0, -0.00269742389669237f, 0, 0.00134871194834618f };
                            a = new double[] { 1, -3.86550956895320f, 5.63152598761351f, -3.66467991638185f, 0.898858994155253f };
                            break;
                        case 1000:
                            b = new double[] { 0.000346041337684191f, 0, -0.000692082675368382f, 0, 0.000346041337684191f };
                            a = new double[] { 1, -3.93960949694447f, 5.82749974685320f, -3.83595939375067f, 0.948081706106736f };
                            break;
                        case 1600:
                            b = new double[] { 0.000136510722194708f, 0, -0.000273021444389417f, 0, 0.000136510722194708f };
                            a = new double[] { 1, -3.96389829181139f, 5.89507193593518f, -3.89839913574117f, 0.967227428151860f };
                            break;
                        default:
                            println("EEG_Processing: *** ERROR *** Filters can only work at 125Hz, 200Hz, 250 Hz, 1000Hz or 1600Hz");
                            b = new double[] { 1.0f };
                            a = new double[] { 1.0f };
                    }
                    filt_txt = "Bandpass 7-13Hz";
                    short_txt = "7-13 Hz";
                    break;
                case 2:
                    //15-50 Hz band pass filter, 2nd Order Butterworth: [b, a] = butter(2,[15.0 50.0]/(fs_Hz / 2.0))
                    switch(PApplet.parseInt(fs_Hz)) {
                        case 125:
                            b = new double[] { 0.350346377855414f, 0, -0.700692755710828f, 0, 0.350346377855414f };
                            a = new double[] { 1, 0.175228265043619f, -0.211846955102387f, 0.0137230352398757f, 0.180232073898346f };
                            break;
                        case 200:
                            b = new double[] { 0.167483800127017f, 0, -0.334967600254034f, 0, 0.167483800127017f };
                            a = new double[] { 1, -1.56695061045088f, 1.22696619781982f, -0.619519163981229f, 0.226966197819818f };
                            break;
                        case 250:
                            b = new double[] { 0.117351036724609f, 0, -0.234702073449219f, 0, 0.117351036724609f };
                            a = new double[] { 1, -2.13743018017206f, 2.03857800810852f, -1.07014439920093f, 0.294636527587914f };
                            break;
                        case 500:
                            b = new double[] { 0.0365748358439273f, 0, -0.0731496716878546f, 0, 0.0365748358439273f };
                            a = new double[] { 1, -3.18880661866679f, 3.98037203788323f, -2.31835989524663f, 0.537194624801103f };
                            break;
                        case 1000:
                            b = new double[] { 0.0104324133710872f, 0, -0.0208648267421744f, 0, 0.0104324133710872f };
                            a = new double[] { 1, -3.63626742713985f, 5.01393973667604f, -3.10964559897057f, 0.732726030371817f };
                            break;
                        case 1600:
                            b = new double[] { 0.00429884732196394f, 0, -0.00859769464392787f, 0, 0.00429884732196394f };
                            a = new double[] { 1, -3.78412985599134f, 5.39377521548486f, -3.43287342581222f, 0.823349595537562f };
                            break;
                        default:
                            println("EEG_Processing: *** ERROR *** Filters can only work at 125Hz, 200Hz, 250 Hz, 1000Hz or 1600Hz");
                            b = new double[] { 1.0f };
                            a = new double[] { 1.0f };
                    }
                    filt_txt = "Bandpass 15-50Hz";
                    short_txt = "15-50 Hz";
                    break;
                case 3:
                    //5-50 Hz band pass filter, 2nd Order Butterworth: [b, a] = butter(2,[5.0 50.0]/(fs_Hz / 2.0))
                    switch(PApplet.parseInt(fs_Hz)) {
                        case 125:
                            b = new double[] { 0.529967227069348f, 0, -1.05993445413870f, 0, 0.529967227069348f };
                            a = new double[] { 1, -0.517003774490767f, -0.734318454224823f, 0.103843398397761f, 0.294636527587914f };
                            break;
                        case 200:
                            b = new double[] { 0.248341078962541f, 0, -0.496682157925081f, 0, 0.248341078962541f };
                            a = new double[] { 1, -1.86549482213123f, 1.17757811892770f, -0.460665534278457f, 0.177578118927698f };
                            break;
                        case 250:
                            b = new double[] { 0.175087643672101f, 0, -0.350175287344202f, 0, 0.175087643672101f };
                            a = new double[] { 1, -2.29905535603850f, 1.96749775998445f, -0.874805556449481f, 0.219653983913695f };
                            break;
                        case 500:
                            b = new double[] { 0.0564484622607352f, 0, -0.112896924521470f, 0, 0.0564484622607352f };
                            a = new double[] { 1, -3.15946330211917f, 3.79268442285094f, -2.08257331718360f, 0.450445430056042f };
                            break;
                        case 1000:
                            b = new double[] { 0.0165819316692804f, 0, -0.0331638633385608f, 0, 0.0165819316692804f };
                            a = new double[] { 1, -3.58623980811691f, 4.84628980428803f, -2.93042721682014f, 0.670457905953175f };
                            break;
                        case 1600:
                            b = new double[] { 0.00692579317243661f, 0, -0.0138515863448732f, 0, 0.00692579317243661f };
                            a = new double[] { 1, -3.74392328264678f, 5.26758817627966f, -3.30252568902969f, 0.778873972655117f };
                            break;
                        default:
                            println("EEG_Processing: *** ERROR *** Filters can only work at 125Hz, 200Hz, 250 Hz, 1000Hz or 1600Hz");
                            b = new double[] { 1.0f };
                            a = new double[] { 1.0f };
                    }
                    filt_txt = "Bandpass 5-50Hz";
                    short_txt = "5-50 Hz";
                    break;
                default:
                    //no filtering
                    b = new double[] { 1.0f };
                    a = new double[] { 1.0f };
                    filt_txt = "No BP Filter";
                    short_txt = "No Filter";
                }  //end switch block

                //create the bandpass filter
                filtCoeff_bp[Ifilt] =  new FilterConstants(b, a, filt_txt, short_txt);
        } //end loop over band pass filters
    }
    //end defineFilters method

    public String getFilterDescription() {
        return filtCoeff_bp[currentFilt_ind].name + ", " + filtCoeff_notch[currentNotch_ind].name;
    }
    public String getShortFilterDescription() {
        return filtCoeff_bp[currentFilt_ind].short_name;
    }
    public String getShortNotchDescription() {
        return filtCoeff_notch[currentNotch_ind].short_name;
    }

    public void incrementFilterConfiguration() {
        //increment the index
        currentFilt_ind++;
        if (currentFilt_ind >= N_FILT_CONFIGS) currentFilt_ind = 0;
        settings.dataProcessingBandpassSave = currentFilt_ind;//store the value to save bandpass setting
    }

    public void incrementNotchConfiguration() {
        //increment the index
        currentNotch_ind++;
        if (currentNotch_ind >= N_NOTCH_CONFIGS) currentNotch_ind = 0;
        settings.dataProcessingNotchSave = currentNotch_ind;
    }

    public void process(float[][] data_newest_uV, //holds raw EEG data that is new since the last call
        float[][] data_long_uV, //holds a longer piece of buffered EEG data, of same length as will be plotted on the screen
        float[][] data_forDisplay_uV, //put data here that should be plotted on the screen
        FFT[] fftData) {              //holds the FFT (frequency spectrum) of the latest data
        int Nfft = getNfftSafe();
        //loop over each EEG channel
        for (int Ichan=0; Ichan < nchan; Ichan++) {

            //filter the data in the time domain
            filterIIR(filtCoeff_notch[currentNotch_ind].b, filtCoeff_notch[currentNotch_ind].a, data_forDisplay_uV[Ichan]); //notch
            filterIIR(filtCoeff_bp[currentFilt_ind].b, filtCoeff_bp[currentFilt_ind].a, data_forDisplay_uV[Ichan]); //bandpass

            //compute the standard deviation of the filtered signal...this is for the head plot
            float[] fooData_filt = dataBuffY_filtY_uV[Ichan];  //use the filtered data
            fooData_filt = Arrays.copyOfRange(fooData_filt, fooData_filt.length-((int)fs_Hz), fooData_filt.length);   //just grab the most recent second of data
            data_std_uV[Ichan]=std(fooData_filt); //compute the standard deviation for the whole array "fooData_filt"
        } //close loop over channels


        // calculate FFT after filter

        //println("PPP" + fftBuff[0].specSize());
        float prevFFTdata[] = new float[fftBuff[0].specSize()];
        double foo;

        //update the FFT (frequency spectrum)
        // println("nchan = " + nchan);
        for (int Ichan=0; Ichan < nchan; Ichan++) {

            //copy the previous FFT data...enables us to apply some smoothing to the FFT data
            for (int I=0; I < fftBuff[Ichan].specSize(); I++) {
                prevFFTdata[I] = fftBuff[Ichan].getBand(I); //copy the old spectrum values
            }

            //prepare the data for the new FFT
            float[] fooData;
            if (isFFTFiltered == true) {
                fooData = dataBuffY_filtY_uV[Ichan];  //use the filtered data for the FFT
            } else {
                fooData = dataBuffY_uV[Ichan];  //use the raw data for the FFT
            }
            fooData = Arrays.copyOfRange(fooData, fooData.length-Nfft, fooData.length);   //trim to grab just the most recent block of data
            float meanData = mean(fooData);  //compute the mean
            for (int I=0; I < fooData.length; I++) fooData[I] -= meanData; //remove the mean (for a better looking FFT

            //compute the FFT
            fftBuff[Ichan].forward(fooData); //compute FFT on this channel of data

            //convert to uV_per_bin...still need to confirm the accuracy of this code.
            //Do we need to account for the power lost in the windowing function?   CHIP  2014-10-24

            // FFT ref: https://www.mathworks.com/help/matlab/ref/fft.html
            // first calculate double-sided FFT amplitude spectrum
            for (int I=0; I <= Nfft/2; I++) {
                fftBuff[Ichan].setBand(I, (float)(fftBuff[Ichan].getBand(I) / Nfft));
            }
            // then convert into single-sided FFT spectrum: DC & Nyquist (i=0 & i=N/2) remain the same, others multiply by two.
            for (int I=1; I < Nfft/2; I++) {
                fftBuff[Ichan].setBand(I, (float)(fftBuff[Ichan].getBand(I) * 2));
            }

            //average the FFT with previous FFT data so that it makes it smoother in time
            double min_val = 0.01d;
            for (int I=0; I < fftBuff[Ichan].specSize(); I++) {   //loop over each fft bin
                if (prevFFTdata[I] < min_val) prevFFTdata[I] = (float)min_val; //make sure we're not too small for the log calls
                foo = fftBuff[Ichan].getBand(I);
                if (foo < min_val) foo = min_val; //make sure this value isn't too small

                if (true) {
                    //smooth in dB power space
                    foo =   (1.0d-smoothFac[smoothFac_ind]) * java.lang.Math.log(java.lang.Math.pow(foo, 2));
                    foo += smoothFac[smoothFac_ind] * java.lang.Math.log(java.lang.Math.pow((double)prevFFTdata[I], 2));
                    foo = java.lang.Math.sqrt(java.lang.Math.exp(foo)); //average in dB space
                } else {
                    //smooth (average) in linear power space
                    foo =   (1.0d-smoothFac[smoothFac_ind]) * java.lang.Math.pow(foo, 2);
                    foo+= smoothFac[smoothFac_ind] * java.lang.Math.pow((double)prevFFTdata[I], 2);
                    // take sqrt to be back into uV_rtHz
                    foo = java.lang.Math.sqrt(foo);
                }
                fftBuff[Ichan].setBand(I, (float)foo); //put the smoothed data back into the fftBuff data holder for use by everyone else
                // fftBuff[Ichan].setBand(I, 1.0f);  // test
            } //end loop over FFT bins

            // calculate single-sided psd by single-sided FFT amplitude spectrum
            // PSD ref: https://www.mathworks.com/help/dsp/ug/estimate-the-power-spectral-density-in-matlab.html
            // when i = 1 ~ (N/2-1), psd = (N / fs) * mag(i)^2 / 4
            // when i = 0 or i = N/2, psd = (N / fs) * mag(i)^2

            for (int i = 0; i < processing_band_low_Hz.length; i++) {
                float sum = 0;
                // int binNum = 0;
                for (int Ibin = 0; Ibin <= Nfft/2; Ibin ++) { // loop over FFT bins
                    float FFT_freq_Hz = fftBuff[Ichan].indexToFreq(Ibin);   // center frequency of this bin
                    float psdx = 0;
                    // if the frequency matches a band
                    if (FFT_freq_Hz >= processing_band_low_Hz[i] && FFT_freq_Hz < processing_band_high_Hz[i]) {
                        if (Ibin != 0 && Ibin != Nfft/2) {
                            psdx = fftBuff[Ichan].getBand(Ibin) * fftBuff[Ichan].getBand(Ibin) * Nfft/getSampleRateSafe() / 4;
                        }
                        else {
                            psdx = fftBuff[Ichan].getBand(Ibin) * fftBuff[Ichan].getBand(Ibin) * Nfft/getSampleRateSafe();
                        }
                        sum += psdx;
                        // binNum ++;
                    }
                }
                avgPowerInBins[Ichan][i] = sum;   // total power in a band
                // println(i, binNum, sum);
            }
        } //end the loop over channels.
        for (int i = 0; i < processing_band_low_Hz.length; i++) {
            float sum = 0;

            for (int j = 0; j < nchan; j++) {
                sum += avgPowerInBins[j][i];
            }
            headWidePower[i] = sum/nchan;   // averaging power over all channels
        }

        //delta in channel 2 ... avgPowerInBins[1][DELTA];
        //headwide beta ... headWidePower[BETA];

        //find strongest channel
        int refChanInd = findMax(data_std_uV);
        //println("EEG_Processing: strongest chan (one referenced) = " + (refChanInd+1));
        float[] refData_uV = dataBuffY_filtY_uV[refChanInd];  //use the filtered data
        refData_uV = Arrays.copyOfRange(refData_uV, refData_uV.length-((int)fs_Hz), refData_uV.length);   //just grab the most recent second of data


        //compute polarity of each channel
        for (int Ichan=0; Ichan < nchan; Ichan++) {
            float[] fooData_filt = dataBuffY_filtY_uV[Ichan];  //use the filtered data
            fooData_filt = Arrays.copyOfRange(fooData_filt, fooData_filt.length-((int)fs_Hz), fooData_filt.length);   //just grab the most recent second of data
            float dotProd = calcDotProduct(fooData_filt, refData_uV);
            if (dotProd >= 0.0f) {
                polarity[Ichan]=1.0f;
            } else {
                polarity[Ichan]=-1.0f;
            }
        }
    }
}
//create DetectedPeak class
class DetectedPeak { 
    int bin;
    float freq_Hz;
    float rms_uV_perBin;
    float background_rms_uV_perBin;
    float SNR_dB;
    boolean isDetected;
    float threshold_dB;
    
    DetectedPeak() {
      clear();
    }
    
    public void clear() {
      bin=0;
      freq_Hz = 0.0f;
      rms_uV_perBin = 0.0f;
      background_rms_uV_perBin = 0.0f;
      SNR_dB = -100.0f;
      isDetected = false;
      threshold_dB = 0.0f;
    }
    
    public void copyTo(DetectedPeak target) {
      target.bin = bin;
      target.freq_Hz = freq_Hz;
      target.rms_uV_perBin = rms_uV_perBin;
      target.background_rms_uV_perBin = background_rms_uV_perBin;
      target.SNR_dB = SNR_dB;
      target.isDetected = isDetected;
      target.threshold_dB = threshold_dB;
    }
}
//------------------------------------------------------------------------
//                       Global Variables & Instances
//------------------------------------------------------------------------

DataProcessing_User dataProcessing_user;

//------------------------------------------------------------------------
//                            Classes
//------------------------------------------------------------------------

class DataProcessing_User {
    private float fs_Hz;  //sample rate
    private int n_chan;
  
    //add your own variables here
    final float min_allowed_peak_freq_Hz = 4.0f; //input, for peak frequency detection
    final float max_allowed_peak_freq_Hz = 15.0f; //input, for peak frequency detection
    final float detection_thresh_dB = 6.0f; //how much bigger must the peak be relative to the background
    final float[] processing_band_low_Hz = {4.0f,  6.5f,  9,  13.5f}; //lower bound for each frequency band of interest (2D classifier only)
    final float[] processing_band_high_Hz = {6.5f,  9,  12, 16.5f};  //upper bound for each frequency band of interest
    DetectedPeak[] detectedPeak;  //output per channel, from peak frequency detection
    DetectedPeak[] peakPerBand;
    Arduino arduino;
    boolean showDetectionOnGUI = true;
    public boolean useClassfier_2DTraining = true;  //use the fancier classifier?

    //create an empty constructor for compiling's sake
    DataProcessing_User(){

    }

    //class constructor
    DataProcessing_User(int NCHAN, float sample_rate_Hz, Arduino duino) {
        nchan = NCHAN;
        fs_Hz = sample_rate_Hz;
        arduino = duino;
        detectedPeak = new DetectedPeak[nchan];
        for (int Ichan=0;Ichan<nchan;Ichan++) detectedPeak[Ichan]=new DetectedPeak();
    
        int nBands = processing_band_low_Hz.length;
        peakPerBand = new DetectedPeak[nBands];
        for (int Iband=0;Iband<nBands;Iband++) peakPerBand[Iband] = new DetectedPeak();
    }

    //add some functions here...if you'd like


    public void findPeakFrequency(FFT[] fftData,int Ichan) {
    
        //loop over each EEG channel and find the frequency with the peak amplitude
        float FFT_freq_Hz, FFT_value_uV;
        //for (int Ichan=0;Ichan < nchan; Ichan++) {
      
        //clear the data structure that will hold the peak for this channel
        detectedPeak[Ichan].clear();
      
        //loop over each frequency bin to find the one with the strongest peak
        int nBins =  fftData[Ichan].specSize();
        for (int Ibin=0; Ibin < nBins; Ibin++){
            FFT_freq_Hz = fftData[Ichan].indexToFreq(Ibin); //here is the frequency of htis bin
        
            //is this bin within the frequency band of interest?
            if ((FFT_freq_Hz >= min_allowed_peak_freq_Hz) && (FFT_freq_Hz <= max_allowed_peak_freq_Hz)) {
               //we are within the frequency band of interest

               //get the RMS voltage (per bin)
                FFT_value_uV = fftData[Ichan].getBand(Ibin) / ((float)nBins); 
           
                //decide if this is the maximum, compared to previous bins for this channel
                if (FFT_value_uV > detectedPeak[Ichan].rms_uV_perBin) {
                    //this is bigger, so hold onto this value as the new "maximum"
                    detectedPeak[Ichan].bin  = Ibin;
                    detectedPeak[Ichan].freq_Hz = FFT_freq_Hz;
                    detectedPeak[Ichan].rms_uV_perBin = FFT_value_uV;
                } 
          
            } //close if within frequency band
        } //close loop over bins
   
      //loop over the bins again (within the sense band) to get the average background power, excluding the bins on either side of the peak
        float sum_pow=0.0f;
        int count=0;
        for (int Ibin=0; Ibin < nBins; Ibin++){
            FFT_freq_Hz = fftData[Ichan].indexToFreq(Ibin);
            if ((FFT_freq_Hz >= min_allowed_peak_freq_Hz) && (FFT_freq_Hz <= max_allowed_peak_freq_Hz)) {
                if ((Ibin < detectedPeak[Ichan].bin - 1) || (Ibin > detectedPeak[Ichan].bin + 1)) {
                    FFT_value_uV = fftData[Ichan].getBand(Ibin) / ((float)nBins);  //get the RMS per bin
                    sum_pow+=pow(FFT_value_uV,2.0f);
                    count++;
                }
            }
        }
        //compute mean
        detectedPeak[Ichan].background_rms_uV_perBin = sqrt(sum_pow / count);
      
        //decide if peak is big enough to be detected
        detectedPeak[Ichan].SNR_dB = 20.0f*(float)java.lang.Math.log10(detectedPeak[Ichan].rms_uV_perBin / detectedPeak[Ichan].background_rms_uV_perBin);
        if (detectedPeak[Ichan].SNR_dB >= detection_thresh_dB) {
            detectedPeak[Ichan].threshold_dB = detection_thresh_dB;
            detectedPeak[Ichan].isDetected = true;
        }
    } //end method findPeakFrequency


    //FUNCTION TAKEN FROM CHIP AUDETTE'S CODE
    public void findBestFrequency_2DTraining(FFT[] fftData,int Ichan) {
    
        //loop over each EEG channel
        float FFT_freq_Hz, FFT_value_uV;
        //for (int Ichan=0;Ichan < nchan; Ichan++) {
        int nBins =  fftData[Ichan].specSize();
      
        //loop over all bins and comptue SNR for each bin
        float[] SNR_dB = new float[nBins];
        float noise_pow_uV = detectedPeak[Ichan].background_rms_uV_perBin;
        for (int Ibin=0; Ibin < nBins; Ibin++) {
            FFT_value_uV = fftData[Ichan].getBand(Ibin) / ((float)nBins);  //get the RMS per bin
            SNR_dB[Ibin] = 20.0f*(float)java.lang.Math.log10(FFT_value_uV / noise_pow_uV);
        }
        
        //find peak SNR in each freq band
        float this_SNR_dB=0.0f;
        int nBands=peakPerBand.length;
        for (int Iband=0; Iband<nBands; Iband++) {
        //peakPerBand[Iband] = new DetectedPeak();
        //init variables for this frequency band
        peakPerBand[Iband].clear();
        peakPerBand[Iband].SNR_dB = -100.0f;
        peakPerBand[Iband].background_rms_uV_perBin = detectedPeak[Ichan].background_rms_uV_perBin;

        //loop over all bins
        for (int Ibin=0; Ibin < nBins; Ibin++) {
          FFT_freq_Hz = fftData[Ichan].indexToFreq(Ibin); //here is the frequency of this bin
          if (FFT_freq_Hz >= processing_band_low_Hz[Iband]) {
            if (FFT_freq_Hz <= processing_band_high_Hz[Iband]) {
              if (SNR_dB[Ibin] > peakPerBand[Iband].SNR_dB) {
                peakPerBand[Iband].bin = Ibin;
                peakPerBand[Iband].freq_Hz = FFT_freq_Hz;
                peakPerBand[Iband].rms_uV_perBin = fftData[Ichan].getBand(Ibin) / ((float)nBins);
                peakPerBand[Iband].SNR_dB = SNR_dB[Ibin];
              }  
            }
          }
        } //end loop over bins    
      } //end loop over frequency bands
    
      //apply new 2D detection rules
      applyDetectionRules_2D(peakPerBand, detectedPeak[Ichan]);
  }


    //here is the processing routine called by the OpenBCI main program...update this with whatever you'd like to do
    public void process(float[][] data_newest_uV, //holds raw bio data that is new since the last call
        float[][] data_long_uV, //holds a longer piece of buffered EEG data, of same length as will be plotted on the screen
        float[][] data_forDisplay_uV, //this data has been filtered and is ready for plotting on the screen
        FFT[] fftData) {              //holds the FFT (frequency spectrum) of the latest data

        //THIS CODE WAS BASED ON PROCESS FUNCTION FROM CHIP AUDETTE

        //user functions here...
        int Ichan = 2-1;  //which channel to act on
        if (fftData != null) findPeakFrequency(fftData,Ichan); //find the frequency for each channel with the peak amplitude
        if (useClassfier_2DTraining) {
          //new processing for improved selectivity
          if (fftData != null) findBestFrequency_2DTraining(fftData,Ichan);      
        }
      
        //issue new command to the Hex Bug, if there is a peak that was detected
        if (detectedPeak[Ichan].isDetected) {
          String txt = "";
          if (detectedPeak[Ichan].freq_Hz < processing_band_high_Hz[1-1]) {
            arduino.right();txt = "Right";
         } else if (detectedPeak[Ichan].freq_Hz < processing_band_high_Hz[2-1]) {
           arduino.left();txt = "Left";
         } else if (detectedPeak[Ichan].freq_Hz < processing_band_high_Hz[3-1]) {
           arduino.forward(); txt = "Forward";
         } else if (detectedPeak[Ichan].freq_Hz < processing_band_high_Hz[4-1]) {
           //the other way to get a LEFT command! 
              arduino.left();txt = "Left";
            }

        //for example, you could loop over each EEG channel to do some sort of time-domain processing
        //using the sample values that have already been filtered, as will be plotted on the display
        float EEG_value_uV;
      } 
    }
}

//////////////////////////////////////
//
// This file contains classes that are helpful for debugging, as well as the HelpWidget,
// which is used to give feedback to the GUI user in the small text window at the bottom of the GUI
//
// Created: Conor Russomanno, June 2016
// Based on code: Chip Audette, Oct 2013 - Dec 2014
//
//
/////////////////////////////////////



//------------------------------------------------------------------------
//                       Global Variables & Instances
//------------------------------------------------------------------------

//set true if you want more verbosity in console.. verbosePrint("print_this_thing") is used to output feedback when isVerbose = true
boolean isVerbose = false;

//Help Widget initiation
HelpWidget helpWidget;

//use signPost(String identifier) to print 'identifier' text and time since last signPost() for debugging latency/timing issues
boolean printSignPosts = true;
float millisOfLastSignPost = 0.0f;
float millisSinceLastSignPost = 0.0f;

static enum OutputLevel {
    DEFAULT,
    INFO,
    SUCCESS,
    WARN,
    ERROR
}

//------------------------------------------------------------------------
//                       Global Functions
//------------------------------------------------------------------------

public void verbosePrint(String _string) {
    if (isVerbose) {
        println(_string);
    }
}

//this class is used to create the help widget that provides system feedback in response to interactivity
//it is intended to serve as a pseudo-console, allowing us to print useful information to the interface as opposed to an IDE console

class HelpWidget {

    public float x, y, w, h;
    int padding;

    //current text shown in help widget, based on most recent command
    String currentOutput = "Learn how to use this application and more at openbci.github.io/Documentation/";
    OutputLevel curOutputLevel = OutputLevel.INFO;

    HelpWidget(float _xPos, float _yPos, float _width, float _height) {
        x = _xPos;
        y = _yPos;
        w = _width;
        h = _height;
        padding = 5;
    }

    public void update() {
    }

    public void draw() {

        pushStyle();

        if(colorScheme == COLOR_SCHEME_DEFAULT){
            // draw background of widget
            stroke(bgColor);
            fill(255);
            rect(-1, height-h, width+2, h);
            noStroke();

            //draw bg of text field of widget
            strokeWeight(1);
            stroke(color(0, 5, 11));
            fill(color(0, 5, 11));
            rect(x + padding, height-h + padding, width - padding*2, h - padding *2);

            textFont(p4);
            textSize(14);
            fill(255);
            textAlign(LEFT, TOP);
            text(currentOutput, padding*2, height - h + padding);
        } else if (colorScheme == COLOR_SCHEME_ALTERNATIVE_A){
            // draw background of widget
            stroke(bgColor);
            fill(31,69,110);
            rect(-1, height-h, width+2, h);
            noStroke();

            //draw bg of text field of widget
            strokeWeight(1);
            stroke(getBackgroundColor());
            // fill(200);
            // fill(255);
            fill(getBackgroundColor());
            // fill(57,128,204);
            rect(x + padding, height-h + padding, width - padding*2, h - padding *2);

            textFont(p4);
            textSize(14);
            // fill(bgColor);
            fill(getTextColor());
            // fill(57,128,204);
            // fill(openbciBlue);
            textAlign(LEFT, TOP);
            text(currentOutput, padding*2, height - h + padding);
        }

        popStyle();
    }

    private int getTextColor() {
        switch (curOutputLevel) {
            case INFO:
                return 0xff00529B;
            case SUCCESS:
                return 0xff4F8A10;
            case WARN:
                return 0xff9F6000;
            case ERROR:
                return 0xffD8000C;
            case DEFAULT:
            default:
                return color(0, 5, 11);
        }
    }

    private int getBackgroundColor() {
        switch (curOutputLevel) {
            case INFO:
                return 0xffBDE5F8;
            case SUCCESS:
                return 0xffDFF2BF;
            case WARN:
                return 0xffFEEFB3;
            case ERROR:
                return 0xffFFD2D2;
            case DEFAULT:
            default:
                return color(255);
        }
    }

    public void output(String _output, OutputLevel level) {
        curOutputLevel = level;
        currentOutput = _output;

        String outputWithPrefix = "[" + level.name() + "]: " + _output;
        println(outputWithPrefix); // add this output to the console log
    }
};

public void output(String _output) {
    output(_output, OutputLevel.DEFAULT);
}

public void output(String _output, OutputLevel level) {
    helpWidget.output(_output, level);
}

public void outputError(String _output) {
    output(_output, OutputLevel.ERROR);
}

public void outputInfo(String _output) {
    output(_output, OutputLevel.INFO);
}

public void outputSuccess(String _output) {
    output(_output, OutputLevel.SUCCESS);
}

public void outputWarn(String _output) {
    output(_output, OutputLevel.WARN);
}

// created 2/10/16 by Conor Russomanno to dissect the aspects of the GUI that are slowing it down
// here I will create methods used to identify where there are inefficiencies in the code
// note to self: make sure to check the frameRate() in setup... switched from 16 to 30... working much faster now... still a useful method below.
// --------------------------------------------------------------  START -------------------------------------------------------------------------------

//method for printing out an ["indentifier"][millisSinceLastSignPost] for debugging purposes... allows us to look at what is taking too long.
public void signPost(String identifier) {
    if (printSignPosts) {
        millisSinceLastSignPost = millis() - millisOfLastSignPost;
        println("SIGN POST: [" + identifier + "][" + millisSinceLastSignPost + "]");
        millisOfLastSignPost = millis();
    }
}
// ---------------------------------------------------------------- FINISH -----------------------------------------------------------------------------

//////////////////////////////////////
//
// This file contains classes that are helfpul in some way.
// Created: Chip Audette, Oct 2013 - Dec 2014
//
/////////////////////////////////////

//------------------------------------------------------------------------
//                       Global Variables & Instances
//------------------------------------------------------------------------

//------------------------------------------------------------------------
//                       Global Functions
//------------------------------------------------------------------------

//////////////////////////////////////////////////
//
// Formerly, Math.pde
//  - std
//  - mean
//  - medianDestructive
//  - findMax
//  - mean
//  - sum
//  - CalcDotProduct
//  - log10
//  - filterWEA_1stOrderIIR
//  - filterIIR
//  - removeMean
//  - rereferenceTheMontage
//  - CLASS RunningMean
//
// Created: Chip Audette, Oct 2013
//
//////////////////////////////////////////////////

//compute the standard deviation
public float std(float[] data) {
    //calc mean
    float ave = mean(data);

    //calc sum of squares relative to mean
    float val = 0;
    for (int i=0; i < data.length; i++) {
        val += pow(data[i]-ave,2);
    }

    // divide by n to make it the average
    val /= data.length;

    //take square-root and return the standard
    return (float)Math.sqrt(val);
}

public float mean(float[] data) {
    return mean(data,data.length);
}

//////////////////////////////////////////////////
//
// Some functions to implement some math and some filtering.  These functions
// probably already exist in Java somewhere, but it was easier for me to just
// recreate them myself as I needed them.
//
// Created: Chip Audette, Oct 2013
//
//////////////////////////////////////////////////

public int findMax(float[] data) {
    float maxVal = data[0];
    int maxInd = 0;
    for (int I=1; I<data.length; I++) {
        if (data[I] > maxVal) {
            maxVal = data[I];
            maxInd = I;
        }
    }
    return maxInd;
}

public float mean(float[] data, int Nback) {
    return sum(data,Nback)/Nback;
}

public float sum(float[] data) {
    return sum(data, data.length);
}

public float sum(float[] data, int Nback) {
    float sum = 0;
    if (Nback > 0) {
        for (int i=(data.length)-Nback; i < data.length; i++) {
            sum += data[i];
        }
    }
    return sum;
}

public float calcDotProduct(float[] data1, float[] data2) {
    int len = min(data1.length, data2.length);
    float val=0.0f;
    for (int I=0;I<len;I++) {
        val+=data1[I]*data2[I];
    }
    return val;
}


public float log10(float val) {
    return (float)Math.log10(val);
}

public float filterWEA_1stOrderIIR(float[] filty, float learn_fac, float filt_state) {
    float prev = filt_state;
    for (int i=0; i < filty.length; i++) {
        filty[i] = prev*(1-learn_fac) + filty[i]*learn_fac;
        prev = filty[i]; //save for next time
    }
    return prev;
}

public void filterIIR(double[] filt_b, double[] filt_a, float[] data) {
    int Nback = filt_b.length;
    double[] prev_y = new double[Nback];
    double[] prev_x = new double[Nback];

    //step through data points
    for (int i = 0; i < data.length; i++) {
        //shift the previous outputs
        for (int j = Nback-1; j > 0; j--) {
            prev_y[j] = prev_y[j-1];
            prev_x[j] = prev_x[j-1];
        }

        //add in the new point
        prev_x[0] = data[i];

        //compute the new data point
        double out = 0;
        for (int j = 0; j < Nback; j++) {
            out += filt_b[j]*prev_x[j];
            if (j > 0) {
                out -= filt_a[j]*prev_y[j];
            }
        }

        //save output value
        prev_y[0] = out;
        data[i] = (float)out;
    }
}


public void removeMean(float[] filty, int Nback) {
    float meanVal = mean(filty,Nback);
    for (int i=0; i < filty.length; i++) {
        filty[i] -= meanVal;
    }
}

public void rereferenceTheMontage(float[][] data) {
    int n_chan = data.length;
    int n_points = data[0].length;
    float sum, mean;

    //loop over all data points
    for (int Ipoint=0;Ipoint<n_points;Ipoint++) {
        //compute mean signal right now
        sum=0.0f;
        for (int Ichan=0;Ichan<n_chan;Ichan++) sum += data[Ichan][Ipoint];
        mean = sum / n_chan;

        //remove the mean signal from all channels
        for (int Ichan=0;Ichan<n_chan;Ichan++) data[Ichan][Ipoint] -= mean;
    }
}

// shortens a string to a given width by adding [...] in the middle
// make sure to pass the right font for accurate sizing
public String shortenString(String str, float maxWidth, PFont font) {
    if (textWidth(str) <= maxWidth) {
        return str;
    }

    textFont(font); // set font for accurate sizing
    int firstIndex = 0; // forward iterator
    int lastIndex = str.length()-1; // reverse iterator
    float spaceLeft = maxWidth - textWidth("..."); // account for the space taken by "..."

    while (firstIndex < lastIndex && spaceLeft >= 0.f) {
        spaceLeft -= textWidth(str.charAt(firstIndex)); // subtract space taken by first char
        spaceLeft -= textWidth(str.charAt(lastIndex)); // and last char

        // move interators inward
        firstIndex ++;
        lastIndex --;
    }

    String s1 = str.substring(0, firstIndex); // firstIndex is excluded here
    String s2 = str.substring(lastIndex + 1, str.length()); // manually exclude lastIndex
    return s1 + "..." + s2;
}

public int lerpInt(int first, int second, float bias)
{
    return round(lerp(first, second, bias));    
}

// creates an DataPacket_ADS1299 with interpolated values.
// the bias is a float between 0 and 1. It's the weight between the two packets.
// a bias of 0 will return packet "first"
// a bias of 1 will return packet "second"
// a bias of 0.5 will return the average of the two.
// This is exactly the behavior of a lerp() function
public DataPacket_ADS1299 CreateInterpolatedPacket(DataPacket_ADS1299 first, DataPacket_ADS1299 second, float bias) {
    int nValues = first.values.length;
    int nAuxValues = first.auxValues.length;

    DataPacket_ADS1299 interpolated = new DataPacket_ADS1299(nValues, nAuxValues);
    first.copyTo(interpolated);
    
    interpolated.interpolated = true;

    for (int i=0; i < nValues; i++) {
        interpolated.values[i] = lerpInt(first.values[i], second.values[i], bias);
    }

    for (int i=0; i < nAuxValues; i++) {
        interpolated.auxValues[i] = lerpInt(first.auxValues[i], second.auxValues[i], bias);
    }

    interpolated.sampleIndex = lerpInt(first.sampleIndex, second.sampleIndex, bias);

    return interpolated;
}

//------------------------------------------------------------------------
//                            Classes
//------------------------------------------------------------------------

class RunningMean {
    private float[] values;
    private int cur_ind = 0;
    RunningMean(int N) {
        values = new float[N];
        cur_ind = 0;
    }
    public void addValue(float val) {
        values[cur_ind] = val;
        cur_ind = (cur_ind + 1) % values.length;
    }
    public float calcMean() {
        return mean(values);
    }
};

class DataPacket_ADS1299 {
    private final int rawAdsSize = 3;
    private final int rawAuxSize = 2;

    int sampleIndex;
    int[] values;
    int[] auxValues;
    byte[][] rawValues;
    byte[][] rawAuxValues;
    boolean interpolated;

    //constructor, give it "nValues", which should match the number of values in the
    //data payload in each data packet from the Arduino.  This is likely to be at least
    //the number of EEG channels in the OpenBCI system (ie, 8 channels if a single OpenBCI
    //board) plus whatever auxiliary data the Arduino is sending.
    DataPacket_ADS1299(int nValues, int nAuxValues) {
        values = new int[nValues];
        auxValues = new int[nAuxValues];
        rawValues = new byte[nValues][rawAdsSize];
        rawAuxValues = new byte[nAuxValues][rawAdsSize];
        interpolated = false; // default
    }

    public int copyTo(DataPacket_ADS1299 target) { return copyTo(target, 0, 0); }
    public int copyTo(DataPacket_ADS1299 target, int target_startInd_values, int target_startInd_aux) {
        target.sampleIndex = sampleIndex;
        return copyValuesAndAuxTo(target, target_startInd_values, target_startInd_aux);
    }
    public int copyValuesAndAuxTo(DataPacket_ADS1299 target, int target_startInd_values, int target_startInd_aux) {
        int nvalues = values.length;
        for (int i=0; i < nvalues; i++) {
            target.values[target_startInd_values + i] = values[i];
            target.rawValues[target_startInd_values + i] = rawValues[i];
        }
        nvalues = auxValues.length;
        for (int i=0; i < nvalues; i++) {
            target.auxValues[target_startInd_aux + i] = auxValues[i];
            target.rawAuxValues[target_startInd_aux + i] = rawAuxValues[i];
        }
        return 0;
    }
};

class DataStatus {
    public boolean is_railed;
    private int threshold_railed;
    public boolean is_railed_warn;
    private int threshold_railed_warn;

    DataStatus(int thresh_railed, int thresh_railed_warn) {
        is_railed = false;
        threshold_railed = thresh_railed;
        is_railed_warn = false;
        threshold_railed_warn = thresh_railed_warn;
    }
    public void update(int data_value) {
        is_railed = false;
        if (abs(data_value) >= threshold_railed) is_railed = true;
        is_railed_warn = false;
        if (abs(data_value) >= threshold_railed_warn) is_railed_warn = true;
    }
};

class FilterConstants {
    public double[] a;
    public double[] b;
    public String name;
    public String short_name;
    FilterConstants(double[] b_given, double[] a_given, String name_given, String short_name_given) {
        b = new double[b_given.length];a = new double[b_given.length];
        for (int i=0; i<b.length;i++) { b[i] = b_given[i];}
        for (int i=0; i<a.length;i++) { a[i] = a_given[i];}
        name = name_given;
        short_name = short_name_given;
    }
};

class DetectionData_FreqDomain {
    public float inband_uV = 0.0f;
    public float inband_freq_Hz = 0.0f;
    public float guard_uV = 0.0f;
    public float thresh_uV = 0.0f;
    public boolean isDetected = false;

    DetectionData_FreqDomain() {
    }
};

class GraphDataPoint {
    public double x;
    public double y;
    public String x_units;
    public String y_units;
};

class PlotFontInfo {
        String fontName = "fonts/Raleway-Regular.otf";
        int axisLabel_size = 16;
        int tickLabel_size = 14;
        int buttonLabel_size = 12;
};

class TextBox {
    public int x, y;
    public int textColor;
    public int backgroundColor;
    private PFont font;
    private int fontSize;
    public String string;
    public boolean drawBackground;
    public int backgroundEdge_pixels;
    public int alignH,alignV;

    TextBox(String s, int x1, int y1) {
        string = s; x = x1; y = y1;
        backgroundColor = color(255,255,255);
        textColor = color(0,0,0);
        fontSize = 12;
        font = p5;
        backgroundEdge_pixels = 1;
        drawBackground = false;
        alignH = LEFT;
        alignV = BOTTOM;
    }
    public void setFontSize(int size) {
        fontSize = size;
        font = p5;
    }
    public void draw() {
        //define text
        noStroke();
        textFont(font);

        //draw the box behind the text
        if (drawBackground == true) {
            int w = PApplet.parseInt(round(textWidth(string)));
            int xbox = x - backgroundEdge_pixels;
            switch (alignH) {
                case LEFT:
                    xbox = x - backgroundEdge_pixels;
                    break;
                case RIGHT:
                    xbox = x - w - backgroundEdge_pixels;
                    break;
                case CENTER:
                    xbox = x - PApplet.parseInt(round(w/2.0f)) - backgroundEdge_pixels;
                    break;
            }
            w = w + 2*backgroundEdge_pixels;
            int h = PApplet.parseInt(textAscent())+2*backgroundEdge_pixels;
            int ybox = y - PApplet.parseInt(round(textAscent())) - backgroundEdge_pixels -2;
            fill(backgroundColor);
            rect(xbox,ybox,w,h);
        }
        //draw the text itself
        fill(textColor);
        textAlign(alignH,alignV);
        text(string,x,y);
        strokeWeight(1);
    }
};
//////////////////////////////////////////////////////////////////////////
//
//    Hardware Settings Controller
//    - this is the user interface for allowing you to control the hardware settings of the 32bit Board & 16chan Setup (32bit + Daisy)
//
//    Written by: Conor Russomanno (Oct. 2016) ... adapted from ChannelController.pde of GUI V1 ... it's a little bit simpler now :|
//    Based on some original GUI code by: Chip Audette 2013/2014
//
//////////////////////////////////////////////////////////////////////////

public void updateChannelArrays(int _nchan) {
    channelSettingValues = new char [_nchan][numSettingsPerChannel]; // [channel#][Button#-value] ... this will incfluence text of button
    impedanceCheckValues = new char [_nchan][2];
}

//activateChannel: Ichan is [0 nchan-1] (aka zero referenced)
public void activateChannel(int Ichan) {
    println("OpenBCI_GUI: activating channel " + (Ichan+1));
    if (eegDataSource == DATASOURCE_CYTON) {
        if (cyton.isPortOpen()) {
            cyton.changeChannelState(Ichan, true); //activate
        }
    } else if (eegDataSource == DATASOURCE_GANGLION) {
        // println("activating channel on ganglion");
        ganglion.changeChannelState(Ichan, true);
    }
    if (Ichan < nchan) {
        channelSettingValues[Ichan][0] = '0';
        // gui.cc.update();
    }
}
public void deactivateChannel(int Ichan) {
    println("OpenBCI_GUI: deactivating channel " + (Ichan+1));
    if (eegDataSource == DATASOURCE_CYTON) {
        if (cyton.isPortOpen()) {
            verbosePrint("**");
            cyton.changeChannelState(Ichan, false); //de-activate
        }
    } else if (eegDataSource == DATASOURCE_GANGLION) {
        ganglion.changeChannelState(Ichan, false);
    }
    if (Ichan < nchan) {
        channelSettingValues[Ichan][0] = '1';
    }
}

//Ichan is zero referenced (not one referenced)
public boolean isChannelActive(int Ichan) {
    boolean return_val = false;
    if (channelSettingValues[Ichan][0] == '1') {
        return_val = false;
    } else {
        return_val = true;
    }
    return return_val;
}

class HardwareSettingsController{

    boolean isVisible = false;
    int x, y, w, h;

    int spaceBetweenButtons = 5; //space between buttons

    // [Number of Channels] x 6 array of buttons for channel settings
    Button[][] channelSettingButtons = new Button [nchan][numSettingsPerChannel];  // [channel#][Button#]

    // Array for storing SRB2 history settings of channels prior to shutting off .. so you can return to previous state when reactivating channel
    char[] previousSRB2 = new char [nchan];
    // Array for storing SRB2 history settings of channels prior to shutting off .. so you can return to previous state when reactivating channel
    char[] previousBIAS = new char [nchan];

    //maximum different values for the different settings (Power Down, Gain, Input Type, BIAS, SRB2, SRB1) of
    //refer to page 44 of ADS1299 Datasheet: http://www.ti.com/lit/ds/symlink/ads1299.pdf
    char[] maxValuesPerSetting = {
        '1', // Power Down :: (0)ON, (1)OFF
        '6', // Gain :: (0) x1, (1) x2, (2) x4, (3) x6, (4) x8, (5) x12, (6) x24 ... default
        '7', // Channel Input :: (0)Normal Electrode Input, (1)Input Shorted, (2)Used in conjunction with BIAS_MEAS, (3)MVDD for supply measurement, (4)Temperature Sensor, (5)Test Signal, (6)BIAS_DRP ... positive electrode is driver, (7)BIAS_DRN ... negative electrode is driver
        '1', // BIAS :: (0) Yes, (1) No
        '1', // SRB2 :: (0) Open, (1) Closed
        '1'
    }; // SRB1 :: (0) Yes, (1) No ... this setting affects all channels ... either all on or all off

    HardwareSettingsController(int _x, int _y, int _w, int _h, int _channelBarHeight){
        x = _x;
        y = _y;
        w = _w;
        h = _h;

        createChannelSettingButtons(_channelBarHeight);
    }

    public void update(){
        for (int i = 0; i < nchan; i++) { //for every channel
            //update buttons based on channelSettingValues[i][j]
            for (int j = 0; j < numSettingsPerChannel; j++) {
                switch(j) {  //what setting are we looking at
                    case 0: //on/off ??
                        // if (channelSettingValues[i][j] == '0') channelSettingButtons[i][0].setColorNotPressed(channelColors[i%8]);// power down == false, set color to vibrant
                        if (channelSettingValues[i][j] == '0') w_timeSeries.channelBars[i].onOffButton.setColorNotPressed(channelColors[i%8]);// power down == false, set color to vibrant
                        if (channelSettingValues[i][j] == '1') w_timeSeries.channelBars[i].onOffButton.setColorNotPressed(75); // power down == true, set color to dark gray, indicating power down
                        break;
                    case 1: //GAIN ??
                        if (channelSettingValues[i][j] == '0') channelSettingButtons[i][1].setString("x1");
                        if (channelSettingValues[i][j] == '1') channelSettingButtons[i][1].setString("x2");
                        if (channelSettingValues[i][j] == '2') channelSettingButtons[i][1].setString("x4");
                        if (channelSettingValues[i][j] == '3') channelSettingButtons[i][1].setString("x6");
                        if (channelSettingValues[i][j] == '4') channelSettingButtons[i][1].setString("x8");
                        if (channelSettingValues[i][j] == '5') channelSettingButtons[i][1].setString("x12");
                        if (channelSettingValues[i][j] == '6') channelSettingButtons[i][1].setString("x24");
                        break;
                    case 2: //input type ??
                        if (channelSettingValues[i][j] == '0') channelSettingButtons[i][2].setString("Normal");
                        if (channelSettingValues[i][j] == '1') channelSettingButtons[i][2].setString("Shorted");
                        if (channelSettingValues[i][j] == '2') channelSettingButtons[i][2].setString("BIAS_MEAS");
                        if (channelSettingValues[i][j] == '3') channelSettingButtons[i][2].setString("MVDD");
                        if (channelSettingValues[i][j] == '4') channelSettingButtons[i][2].setString("Temp.");
                        if (channelSettingValues[i][j] == '5') channelSettingButtons[i][2].setString("Test");
                        if (channelSettingValues[i][j] == '6') channelSettingButtons[i][2].setString("BIAS_DRP");
                        if (channelSettingValues[i][j] == '7') channelSettingButtons[i][2].setString("BIAS_DRN");
                        break;
                    case 3: //BIAS ??
                        if (channelSettingValues[i][j] == '0') channelSettingButtons[i][3].setString("Don't Include");
                        if (channelSettingValues[i][j] == '1') channelSettingButtons[i][3].setString("Include");
                        break;
                    case 4: // SRB2 ??
                        if (channelSettingValues[i][j] == '0') channelSettingButtons[i][4].setString("Off");
                        if (channelSettingValues[i][j] == '1') channelSettingButtons[i][4].setString("On");
                        break;
                    case 5: // SRB1 ??
                        if (channelSettingValues[i][j] == '0') channelSettingButtons[i][5].setString("No");
                        if (channelSettingValues[i][j] == '1') channelSettingButtons[i][5].setString("Yes");
                        break;
                }
            }
        }
    }

    public void draw(){
        pushStyle();

        if (isVisible) {
            //background
            noStroke();
            fill(0, 0, 0, 100);
            rect(x, y, w, h);

            // [numChan] x 5 ... all channel setting buttons (other than on/off)
            for (int i = 0; i < nchan; i++) {
                for (int j = 1; j < 6; j++) {
                    channelSettingButtons[i][j].draw();
                }
            }

            //draw column headers for channel settings behind EEG graph
            fill(bgColor);
            textFont(p6, 10);
            textAlign(CENTER, TOP);
            text("PGA Gain", x + (w/10)*1, y-1);
            text("Input Type", x + (w/10)*3, y-1);
            text("  Bias ", x + (w/10)*5, y-1);
            text("SRB2", x + (w/10)*7, y-1);
            text("SRB1", x + (w/10)*9, y-1);

            //if mode is not from OpenBCI, draw a dark overlay to indicate that you cannot edit these settings
            if (eegDataSource != DATASOURCE_CYTON) {
                fill(0, 0, 0, 200);
                noStroke();
                rect(x-2, y, w+1, h);
                fill(255);
                textAlign(CENTER,CENTER);
                textFont(h1,18);
                text("DATA SOURCE (LIVE) only", x + (w/2), y + (h/2));
            }
        }
        popStyle();
    }

    public void loadDefaultChannelSettings() {
        for (int i = 0; i < nchan; i++) {
            channelSettingValues[i][0] = '0';
            channelSettingValues[i][1] = '6';
            channelSettingValues[i][2] = '0';
            channelSettingValues[i][3] = '1';
            channelSettingValues[i][4] = '1';
            channelSettingValues[i][5] = '0';

            for (int k = 0; k < 2; k++) { //impedance setting values
                impedanceCheckValues[i][k] = '0';
            }
        }
        update(); //update 1 time to refresh button values based on new loaded settings
    }

    //activateChannel: Ichan is [0 nchan-1] (aka zero referenced)
    public void activateChannel(int Ichan) {
        println("OpenBCI_GUI: activating channel " + (Ichan+1));
        if (eegDataSource == DATASOURCE_CYTON) {
            if (cyton.isPortOpen()) {
                verbosePrint("**");
                cyton.changeChannelState(Ichan, true); //activate
            }
        } else if (eegDataSource == DATASOURCE_GANGLION) {
            ganglion.changeChannelState(Ichan, true);
        }
        if (Ichan < nchan) {
            channelSettingValues[Ichan][0] = '0';
            w_timeSeries.hsc.update(); //previously gui.cc.update();
        }
    }

    public void deactivateChannel(int Ichan) {
        println("OpenBCI_GUI: deactivating channel " + (Ichan+1));
        if (eegDataSource == DATASOURCE_CYTON) {
            if (cyton.isPortOpen()) {
                verbosePrint("**");
                cyton.changeChannelState(Ichan, false); //de-activate
            }
        } else if (eegDataSource == DATASOURCE_GANGLION) {
            // println("deactivating channel on ganglion");
            ganglion.changeChannelState(Ichan, false);
        }
        if (Ichan < nchan) {
            channelSettingValues[Ichan][0] = '1';
            w_timeSeries.hsc.update();
        }
    }

    //Ichan is zero referenced (not one referenced)
    public boolean isChannelActive(int Ichan) {
        boolean return_val = false;
        if (channelSettingValues[Ichan][0] == '1') {
            return_val = false;
        } else {
            return_val = true;
        }
        return return_val;
    }

    public void powerDownChannel(int _numChannel) {
        verbosePrint("Powering down channel " + str(PApplet.parseInt(_numChannel) + PApplet.parseInt(1)));
        //save SRB2 and BIAS settings in 2D history array (to turn back on when channel is reactivated)
        previousBIAS[_numChannel] = channelSettingValues[_numChannel][3];
        previousSRB2[_numChannel] = channelSettingValues[_numChannel][4];
        channelSettingValues[_numChannel][3] = '0'; //make sure to disconnect from BIAS
        channelSettingValues[_numChannel][4] = '0'; //make sure to disconnect from SRB2

        channelSettingValues[_numChannel][0] = '1'; //update powerUp/powerDown value of 2D array
        verbosePrint("Command: " + command_deactivate_channel[_numChannel]);
        cyton.deactivateChannel(_numChannel);  //assumes numChannel counts from zero (not one)...handles regular and daisy channels
    }

    public void powerUpChannel(int _numChannel) {
        verbosePrint("Powering up channel " + str(PApplet.parseInt(_numChannel) + PApplet.parseInt(1)));
        //replace SRB2 and BIAS settings with values from 2D history array
        channelSettingValues[_numChannel][3] = previousBIAS[_numChannel];
        channelSettingValues[_numChannel][4] = previousSRB2[_numChannel];

        channelSettingValues[_numChannel][0] = '0'; //update powerUp/powerDown value of 2D array
        verbosePrint("Command: " + command_activate_channel[_numChannel]);
        cyton.activateChannel(_numChannel);  //assumes numChannel counts from zero (not one)...handles regular and daisy channels//assumes numChannel counts from zero (not one)...handles regular and daisy channels
    }

    public void initImpWrite(int _numChannel, char pORn, char onORoff) {
        verbosePrint("Writing impedance check settings (" + pORn + "," + onORoff +  ") for channel " + str(_numChannel) + " to OpenBCI!");
        if (pORn == 'p') {
            impedanceCheckValues[_numChannel-1][0] = onORoff;
        }
        if (pORn == 'n') {
            impedanceCheckValues[_numChannel-1][1] = onORoff;
        }
        cyton.writeImpedanceSettings(_numChannel, impedanceCheckValues);
    }

    public void createChannelSettingButtons(int _channelBarHeight) {
        //the size and space of these buttons are dependendant on the size of the screen and full ChannelController
        verbosePrint("ChannelController: createChannelSettingButtons: creating channel setting buttons...");
        int buttonW = 0;
        int buttonX = 0;
        int buttonH = 0;
        int buttonY = 0; //variables to be used for button creation below
        String buttonString = "";
        Button tempButton;

        for (int i = 0; i < nchan; i++) {
            for (int j = 1; j < 6; j++) {
                buttonW = PApplet.parseInt((w - (spaceBetweenButtons*6)) / 5);
                buttonX = PApplet.parseInt((x + (spaceBetweenButtons * (j))) + ((j-1) * buttonW));
                buttonH = 18;
                // buttonY = int(y + ((30)*i) + (((30)-buttonH)/2)); //timeSeries_widget.channelBarHeight
                buttonY = PApplet.parseInt(y + ((_channelBarHeight)*i) + (((_channelBarHeight)-buttonH)/2)); //timeSeries_widget.channelBarHeight
                buttonString = "N/A";
                tempButton = new Button (buttonX, buttonY, buttonW, buttonH, buttonString, 14);
                channelSettingButtons[i][j] = tempButton;
            }
        }
    }

    public void mousePressed(){
        if (isVisible) {
            for (int i = 0; i < nchan; i++) { //When [i][j] button is clicked
                for (int j = 1; j < numSettingsPerChannel; j++) {
                    if (channelSettingButtons[i][j].isMouseHere()) {
                        //increment [i][j] channelSettingValue by, until it reaches max values per setting [j],
                        channelSettingButtons[i][j].wasPressed = true;
                        channelSettingButtons[i][j].isActive = true;
                    }
                }
            }
        }
    }

    public void mouseReleased(){
        if (isVisible) {
            for (int i = 0; i < nchan; i++) { //When [i][j] button is clicked
                for (int j = 1; j < numSettingsPerChannel; j++) {
                    if (channelSettingButtons[i][j].isMouseHere() && channelSettingButtons[i][j].wasPressed == true) {
                        if (channelSettingValues[i][j] < maxValuesPerSetting[j]) {
                            channelSettingValues[i][j]++;	//increment [i][j] channelSettingValue by, until it reaches max values per setting [j],
                        } else {
                            channelSettingValues[i][j] = '0';
                        }
                        cyton.writeChannelSettings(i, channelSettingValues);
                    }

                    // if(!channelSettingButtons[i][j].isMouseHere()){
                    channelSettingButtons[i][j].isActive = false;
                    channelSettingButtons[i][j].wasPressed = false;
                    // }
                }
            }
        }
    }

    public void screenResized(int _x, int _y, int _w, int _h, int _channelBarHeight){
        x = _x;
        y = _y;
        w = _w;
        h = _h;

        int buttonW = 0;
        int buttonX = 0;
        int buttonH = 0;
        int buttonY = 0; //variables to be used for button creation below
        String buttonString = "";

        for (int i = 0; i < nchan; i++) {
            for (int j = 1; j < 6; j++) {
                buttonW = PApplet.parseInt((w - (spaceBetweenButtons*6)) / 5);
                buttonX = PApplet.parseInt((x + (spaceBetweenButtons * (j))) + ((j-1) * buttonW));
                buttonH = 18;
                buttonY = PApplet.parseInt(y + ((_channelBarHeight)*i) + (((_channelBarHeight)-buttonH)/2)); //timeSeries_widget.channelBarHeight
                buttonString = "N/A";
                channelSettingButtons[i][j].but_x = buttonX;
                channelSettingButtons[i][j].but_y = buttonY;
                channelSettingButtons[i][j].but_dx = buttonW;
                channelSettingButtons[i][j].but_dy = buttonH;
            }
        }
    }

    public void toggleImpedanceCheck(int _channelNumber){ //Channel Numbers start at 1
        if(channelSettingValues[_channelNumber-1][4] == '1'){     //is N pin being used...
            if (impedanceCheckValues[_channelNumber-1][1] < '1') { //if not checking/drawing impedance
                initImpWrite(_channelNumber, 'n', '1');  // turn on the impedance check for the desired channel
                println("Imp[" + _channelNumber + "] is on.");
            } else {
                initImpWrite(_channelNumber, 'n', '0'); //turn off impedance check for desired channel
                println("Imp[" + _channelNumber + "] is off.");
            }
        }

        if(channelSettingValues[_channelNumber-1][4] == '0'){     //is P pin being used
            if (impedanceCheckValues[_channelNumber-1][0] < '1') {    //is channel on
                initImpWrite(_channelNumber, 'p', '1');
            } else {
                initImpWrite(_channelNumber, 'p', '0');
            }
        }
    }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  This file contains all key commands for interactivity with GUI & OpenBCI
//  Created by Chip Audette, Joel Murphy, & Conor Russomanno
//  - Extracted from OpenBCI_GUI because it was getting too klunky
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//------------------------------------------------------------------------
//                       Global Variables & Instances
//------------------------------------------------------------------------

//------------------------------------------------------------------------
//                       Global Functions
//------------------------------------------------------------------------

//interpret a keypress...the key pressed comes in as "key"
public synchronized void keyPressed() {
    // don't allow key presses until setup is complete and the UI is initialized
    if (!setupComplete) {
        return;
    }

    //note that the Processing variable "key" is the keypress as an ASCII character
    //note that the Processing variable "keyCode" is the keypress as a JAVA keycode.  This differs from ASCII
    //println("OpenBCI_GUI: keyPressed: key = " + key + ", int(key) = " + int(key) + ", keyCode = " + keyCode);

    if(!controlPanel.isOpen && !isNetworkingTextActive()){ //don't parse the key if the control panel is open
        if (settings.expertModeToggle || (PApplet.parseInt(key) == 32)) { //Check if Expert Mode is On or Spacebar has been pressed
            if ((PApplet.parseInt(key) >=32) && (PApplet.parseInt(key) <= 126)) {  //32 through 126 represent all the usual printable ASCII characters
                parseKey(key);
            } else {
                parseKeycode(keyCode);
            }
        }
    }

    if(key==27){
        key=0; //disable 'esc' quitting program
    }
}

public void parseKey(char val) {
    int Ichan; boolean activate; int code_P_N_Both;

    //assumes that val is a usual printable ASCII character (ASCII 32 through 126)
    switch (val) {
        case ' ':
            stopButtonWasPressed();
            break;
        case '.':
            //This keyboard shortcut is not being used!
            break;
        case ',':
            drawContainers = !drawContainers;
            break;
        case '<':
            //w_timeSeries.setUpdating(!w_timeSeries.isUpdating());
            break;
        case '>':
            /*
            if(eegDataSource == DATASOURCE_GANGLION){
                ganglion.enterBootloaderMode();
            }
            */
            break;
        case '{':
            if(colorScheme == COLOR_SCHEME_DEFAULT){
                colorScheme = COLOR_SCHEME_ALTERNATIVE_A;
            } else if(colorScheme == COLOR_SCHEME_ALTERNATIVE_A) {
                colorScheme = COLOR_SCHEME_DEFAULT;
            }
            topNav.updateNavButtonsBasedOnColorScheme();
            println("Changing color scheme.");
            break;
        case '/':
            //Not being used
            break;
        case '\\':
            //Not being used
            break;
        case '1':
            deactivateChannel(1-1);
            break;
        case '2':
            deactivateChannel(2-1);
            break;
        case '3':
            deactivateChannel(3-1);
            break;
        case '4':
            deactivateChannel(4-1);
            break;
        case '5':
            deactivateChannel(5-1);
            break;
        case '6':
            deactivateChannel(6-1);
            break;
        case '7':
            deactivateChannel(7-1);
            break;
        case '8':
            deactivateChannel(8-1);
            break;

        case 'q':
            if(nchan == 16){
                deactivateChannel(9-1);
            }
            break;
        case 'w':
            if(nchan == 16){
                deactivateChannel(10-1);
            }
            break;
        case 'e':
            if(nchan == 16){
                deactivateChannel(11-1);
            }
            break;
        case 'r':
            if(nchan == 16){
                deactivateChannel(12-1);
            }
            break;
        case 't':
            if(nchan == 16){
                deactivateChannel(13-1);
            }
            break;
        case 'y':
            if(nchan == 16){
                deactivateChannel(14-1);
            }
            break;
        case 'u':
            if(nchan == 16){
                deactivateChannel(15-1);
            }
            break;
        case 'i':
            if(nchan == 16){
                deactivateChannel(16-1);
            }
            break;
        case ':':
            println("test..."); //@@@@@
            boolean test = isNetworkingTextActive();
            break;

        //activate channels 1-8
        case '!':
            activateChannel(1-1);
            break;
        case '@':
            activateChannel(2-1);
            break;
        case '#':
            activateChannel(3-1);
            break;
        case '$':
            activateChannel(4-1);
            break;
        case '%':
            activateChannel(5-1);
            break;
        case '^':
            activateChannel(6-1);
            break;
        case '&':
            activateChannel(7-1);
            break;
        case '*':
            activateChannel(8-1);
            break;

        //activate channels 9-16 (DAISY MODE ONLY)
        case 'Q':
            if(nchan == 16){
                activateChannel(9-1);
            }
            break;
        case 'W':
            if(nchan == 16){
                activateChannel(10-1);
            }
            break;
        case 'E':
            if(nchan == 16){
                activateChannel(11-1);
            }
            break;
        case 'R':
            if(nchan == 16){
                activateChannel(12-1);
            }
            break;
        case 'T':
            if(nchan == 16){
                activateChannel(13-1);
            }
            break;
        case 'Y':
            if(nchan == 16){
                activateChannel(14-1);
            }
            break;
        case 'U':
            if(nchan == 16){
                activateChannel(15-1);
            }
            break;
        case 'I':
            if(nchan == 16){
                activateChannel(16-1);
            }
            break;

        //other controls
        case 's':
            println("case s...");
            stopRunning();
            //stopButtonWasPressed();
            break;

        case 'b':
            println("case b...");
            startRunning();
            //stopButtonWasPressed();
            break;

        //Lowercase k sets Bias Don't Include all channels
        case 'k':
            for (int i = 0; i < nchan; i++) { //for every channel
                //BIAS off all channels
                channelSettingValues[i][3] = '0';
                println ("chan " + i + " bias don't include");
            }
            break;
        //Lowercase l sets Bias Include all channels
        case 'l':
            for (int i = 0; i < nchan; i++) { //for every channel
                //buttons are updated in HardwareSettingsController based on channelSettingValues[i][j]
                //BIAS on all channells
                channelSettingValues[i][3] = '1';
                println ("chan " + i + " bias include");
            }
            break;

        ///////////////////// Save User settings lowercase n
        case 'n':
            println("Save key pressed!");
            settings.save(settings.getPath("User", eegDataSource, nchan));
            outputSuccess("Settings Saved! The GUI will now load with these settings. Click \"Default\" to revert to factory settings.");
            break;

        ///////////////////// Load User settings uppercase N
        case 'N':
            println("Load key pressed!");
            settings.loadKeyPressed();
            break;

        case '?':
            cyton.printRegisters();
            break;

        case 'd':
            verbosePrint("Updating GUI's channel settings to default...");
            w_timeSeries.hsc.loadDefaultChannelSettings();
            //cyton.serial_openBCI.write('d');
            cyton.configureAllChannelsToDefault();
            break;

        case 'm':
            String picfname = "OpenBCI-" + getDateString() + ".jpg";
            //println("OpenBCI_GUI: 'm' was pressed...taking screenshot:" + picfname);
            saveFrame(settings.guiDataPath + "Screenshots" + System.getProperty("file.separator") + picfname);    // take a shot of that!
            output("Screenshot captured! Saved to /Documents/OpenBCI_GUI/Screenshots/" + picfname);
            break;
        /*
        //Used for testing marker mode
        case 'M':
            if (eegDataSource == DATASOURCE_CYTON) {
                hub.sendCommand("`9");
                println("Cyton: Setting a Marker +++++");
            }
            break;
        */
        default:
            if (eegDataSource == DATASOURCE_CYTON) {
                println("Interactivity: '" + key + "' Pressed...sending to Cyton...");
                cyton.write(key);
            } else if (eegDataSource == DATASOURCE_GANGLION) {
                println("Interactivity: '" + key + "' Pressed...sending to Ganglion...");
                hub.sendCommand(key);
            }
            break;
    }
}

public void parseKeycode(int val) {
    //assumes that val is Java keyCode
    switch (val) {
        case 8:
            println("OpenBCI_GUI: parseKeycode(" + val + "): received BACKSPACE keypress.  Ignoring...");
            break;
        case 9:
            println("OpenBCI_GUI: parseKeycode(" + val + "): received TAB keypress.  Ignoring...");
            //gui.showImpedanceButtons = !gui.showImpedanceButtons;
            // gui.incrementGUIpage(); //deprecated with new channel controller
            break;
        case 10:
            println("Enter was pressed.");
            drawPresentation = !drawPresentation;
            break;
        case 16:
            println("OpenBCI_GUI: parseKeycode(" + val + "): received SHIFT keypress.  Ignoring...");
            break;
        case 17:
            //println("OpenBCI_GUI: parseKeycode(" + val + "): received CTRL keypress.  Ignoring...");
            break;
        case 18:
            println("OpenBCI_GUI: parseKeycode(" + val + "): received ALT keypress.  Ignoring...");
            break;
        case 20:
            println("OpenBCI_GUI: parseKeycode(" + val + "): received CAPS LOCK keypress.  Ignoring...");
            break;
        case 27:
            println("OpenBCI_GUI: parseKeycode(" + val + "): received ESC keypress.  Stopping OpenBCI...");
            //stopRunning();
            break;
        case 33:
            println("OpenBCI_GUI: parseKeycode(" + val + "): received PAGE UP keypress.  Ignoring...");
            break;
        case 34:
            println("OpenBCI_GUI: parseKeycode(" + val + "): received PAGE DOWN keypress.  Ignoring...");
            break;
        case 35:
            println("OpenBCI_GUI: parseKeycode(" + val + "): received END keypress.  Ignoring...");
            break;
        case 36:
            println("OpenBCI_GUI: parseKeycode(" + val + "): received HOME keypress.  Ignoring...");
            break;
        case 37:
            if (millis() - myPresentation.timeOfLastSlideChange >= 250) {
                if(myPresentation.currentSlide >= 0){
                    myPresentation.slideBack();
                    myPresentation.timeOfLastSlideChange = millis();
                }
            }
            break;
        case 38:
            println("OpenBCI_GUI: parseKeycode(" + val + "): received UP ARROW keypress.  Ignoring...");
            break;
        case 39:
            if (millis() - myPresentation.timeOfLastSlideChange >= 250) {
                if(myPresentation.currentSlide < myPresentation.presentationSlides.length - 1){
                    myPresentation.slideForward();
                    myPresentation.timeOfLastSlideChange = millis();
                }
            }
            break;
        case 40:
            println("OpenBCI_GUI: parseKeycode(" + val + "): received DOWN ARROW keypress.  Ignoring...");
            break;
        case 112:
            println("OpenBCI_GUI: parseKeycode(" + val + "): received F1 keypress.  Ignoring...");
            break;
        case 113:
            println("OpenBCI_GUI: parseKeycode(" + val + "): received F2 keypress.  Ignoring...");
            break;
        case 114:
            println("OpenBCI_GUI: parseKeycode(" + val + "): received F3 keypress.  Ignoring...");
            break;
        case 115:
            println("OpenBCI_GUI: parseKeycode(" + val + "): received F4 keypress.  Ignoring...");
            break;
        case 116:
            println("OpenBCI_GUI: parseKeycode(" + val + "): received F5 keypress.  Ignoring...");
            break;
        case 117:
            println("OpenBCI_GUI: parseKeycode(" + val + "): received F6 keypress.  Ignoring...");
            break;
        case 118:
            println("OpenBCI_GUI: parseKeycode(" + val + "): received F7 keypress.  Ignoring...");
            break;
        case 119:
            println("OpenBCI_GUI: parseKeycode(" + val + "): received F8 keypress.  Ignoring...");
            break;
        case 120:
            println("OpenBCI_GUI: parseKeycode(" + val + "): received F9 keypress.  Ignoring...");
            break;
        case 121:
            println("OpenBCI_GUI: parseKeycode(" + val + "): received F10 keypress.  Ignoring...");
            break;
        case 122:
            println("OpenBCI_GUI: parseKeycode(" + val + "): received F11 keypress.  Ignoring...");
            break;
        case 123:
            println("OpenBCI_GUI: parseKeycode(" + val + "): received F12 keypress.  Ignoring...");
            break;
        case 127:
            println("OpenBCI_GUI: parseKeycode(" + val + "): received DELETE keypress.  Ignoring...");
            break;
        case 155:
            println("OpenBCI_GUI: parseKeycode(" + val + "): received INSERT keypress.  Ignoring...");
            break;
        default:
            println("OpenBCI_GUI: parseKeycode(" + val + "): value is not known.  Ignoring...");
            break;
    }
}

public void mouseDragged() {

    if (systemMode >= SYSTEMMODE_POSTINIT) {

        //calling mouse dragged inly outside of Control Panel
        if (controlPanel.isOpen == false) {
            wm.mouseDragged();
        }
    }
}
//switch yard if a click is detected
public synchronized void mousePressed() {
    // don't allow mouse clicks until setup is complete and the UI is initialized
    if (!setupComplete) {
        return;
    }
    // verbosePrint("OpenBCI_GUI: mousePressed: mouse pressed");
    // println("systemMode" + systemMode);
    // controlPanel.CPmousePressed();

    //if not before "START SESSION" ... i.e. after initial setup
    if (systemMode >= SYSTEMMODE_POSTINIT) {

        //limit interactivity of main GUI if control panel is open
        if (controlPanel.isOpen == false) {
            //was the stopButton pressed?

            wm.mousePressed();

        }
    }

    //topNav is always clickable
    topNav.mousePressed();

    //interacting with control panel
    if (controlPanel.isOpen) {
        //close control panel if you click outside...
        if (systemMode == SYSTEMMODE_POSTINIT) {
            if (mouseX > 0 && mouseX < controlPanel.w && mouseY > 0 && mouseY < controlPanel.initBox.y+controlPanel.initBox.h) {
                println("OpenBCI_GUI: mousePressed: clicked in CP box");
                controlPanel.CPmousePressed();
            }
            //if clicked out of panel
            else {
                println("OpenBCI_GUI: mousePressed: outside of CP clicked");
                controlPanel.isOpen = false;
                topNav.controlPanelCollapser.setIsActive(false);
            }
        }
    }

    redrawScreenNow = true;  //command a redraw of the GUI whenever the mouse is pressed
}

public synchronized void mouseReleased() {
    // don't allow mouse clicks until setup is complete and the UI is initialized
    if (!setupComplete) {
        return;
    }

    //some buttons light up only when being actively pressed.  Now that we've
    //released the mouse button, turn off those buttons.

    //interacting with control panel
    if (controlPanel.isOpen) {
        //if clicked in panel
        controlPanel.CPmouseReleased();
    }

    // gui.mouseReleased();
    topNav.mouseReleased();

    if (systemMode >= SYSTEMMODE_POSTINIT) {

        // GUIWidgets_mouseReleased(); // to replace GUI_Manager version (above) soon... cdr 7/25/16
        wm.mouseReleased();

        redrawScreenNow = true;  //command a redraw of the GUI whenever the mouse is released
    }

    if (settings.screenHasBeenResized) {
        println("OpenBCI_GUI: mouseReleased: screen has been resized...");
        settings.screenHasBeenResized = false;
    }
}

//------------------------------------------------------------------------
//                       Classes
//------------------------------------------------------------------------


////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Formerly Button.pde
// This class creates and manages a button for use on the screen to trigger actions.
//
// Created: Chip Audette, Oct 2013.
// Modified: Conor Russomanno, Oct 2014
//
// Based on Processing's "Button" example code
//
////////////////////////////////////////////////////////////////////////////////////////////////////

class Button {

    int but_x, but_y, but_dx, but_dy;      // Position of square button
    //int rectSize = 90;     // Diameter of rect

    int currentColor;
    int color_hover = color(177, 184, 193);//color(252, 221, 198);
    int color_pressed = color(150,170,200); //bgColor;
    int color_notPressed = colorNotPressed; //color(255);  alt - color(227,118,37);
    int buttonStrokeColor = bgColor;
    int textColorActive = color(255);
    int textColorNotActive = bgColor;
    boolean drawHand = false;
    boolean isCircleButton = false;
    int cornerRoundness = 0;
    boolean buttonHasStroke = true;
    boolean isActive = false;
    boolean isDropdownButton = false;
    boolean wasPressed = false;
    public String but_txt;
    boolean showHelpText;
    boolean helpTimerStarted;
    String helpText= "";
    String myURL= "";
    int mouseOverButtonStart = 0;
    PFont buttonFont;
    int buttonTextSize;
    PImage bgImage;
    boolean hasbgImage = false;
    private boolean ignoreHover = false;

    public Button(int x, int y, int w, int h, String txt) {
        setup(x, y, w, h, txt);
        buttonFont = p5;
        buttonTextSize = 12;
    }

    public Button(int x, int y, int w, int h, String txt, int fontSize) {
        setup(x, y, w, h, txt);
        buttonFont = p5;
        buttonTextSize = 12;
    }

    public void setup(int x, int y, int w, int h, String txt) {
        but_x = x;
        but_y = y;
        but_dx = w;
        but_dy = h;
        setString(txt);
    }

    public boolean getIgnoreHover() {
        return ignoreHover;
    }

    public void setX(int _but_x){
        but_x = _but_x;
    }

    public void setY(int _but_y){
        but_y = _but_y;
    }

    public void setPos(int _but_x, int _but_y){
        but_x = _but_x;
        but_y = _but_y;
    }

    public void setFont(PFont _newFont){
        buttonFont = _newFont;
    }

    public void setFont(PFont _newFont, int _newTextSize){
        buttonFont = _newFont;
        buttonTextSize = _newTextSize;
    }

    public void setFontColorNotActive (int _color) {
        textColorNotActive = _color;
    }

    public void setCircleButton(boolean _isCircleButton){
        isCircleButton = _isCircleButton;
        if(isCircleButton){
            cornerRoundness = 0;
        }
    }

    public void setCornerRoundess(int _cornerRoundness){
        if(!isCircleButton){
            cornerRoundness = _cornerRoundness;
        }
    }

    public void setString(String txt) {
        but_txt = txt;
        //println("Button: setString: string = " + txt);
    }

    public void setHelpText(String _helpText){
        helpText = _helpText;
    }

    public void setIgnoreHover (boolean _ignoreHover) {
        ignoreHover = _ignoreHover;
    }

    public void setURL(String _myURL){
        myURL = _myURL;
    }

    public void goToURL(){
        if(myURL != ""){
            openURLInBrowser(myURL);
        }
    }

    public void setBackgroundImage(PImage _bgImage){
        bgImage = _bgImage;
        hasbgImage = true;
    }

    public boolean isActive() {
        return isActive;
    }

    public void setIsActive(boolean val) {
        isActive = val;
    }

    public void makeDropdownButton(boolean val) {
        isDropdownButton = val;
    }

    public boolean isMouseHere() {
        if (!ignoreHover) {
            if ( overRect(but_x, but_y, but_dx, but_dy) ) {
                // cursor(HAND);
                if(!helpTimerStarted){
                    helpTimerStarted = true;
                    mouseOverButtonStart = millis();
                } else {
                    if(millis()-mouseOverButtonStart >= 1000){
                        showHelpText = true;
                    }
                }
                return true;
            }
            else {
                setIsActive(false);
                if(helpTimerStarted){
                    buttonHelpText.setVisible(false);
                    showHelpText = false;
                    helpTimerStarted = false;
                }
                return false;
            }
        } else {
            return false;
        }
    }

    public int getColor() {
        if (isActive) {
            currentColor = color_pressed;
        } else if (isMouseHere() && !ignoreHover) {
            currentColor = color_hover;
        } else if (ignoreHover) {
            currentColor = color_notPressed;
        } else {
            currentColor = color_notPressed;
        }
        return currentColor;
    }

    public String getButtonText() {
        return but_txt;
    }

    public void setCurrentColor(int _color){
        currentColor = _color;
    }

    public void setColorPressed(int _color) {
        color_pressed = _color;
    }
    public void setColorNotPressed(int _color) {
        color_notPressed = _color;
    }

    public void setStrokeColor(int _color) {
        buttonStrokeColor = _color;
    }

    public void hasStroke(boolean _trueORfalse) {
        buttonHasStroke = _trueORfalse;
    }

    public boolean overRect(int x, int y, int width, int height) {
        if (mouseX >= x && mouseX <= x+width &&
            mouseY >= y && mouseY <= y+height) {
            return true;
        } else {
            return false;
        }
    }

    public void draw(int _x, int _y) {
        but_x = _x;
        but_y = _y;
        draw();
    }

    public void draw() {
        pushStyle();
        // rectMode(CENTER);
        ellipseMode(CORNER);

        //draw the button
        fill(getColor());
        if (buttonHasStroke) {
            stroke(buttonStrokeColor); //button border
        } else {
            noStroke();
        }
        // noStroke();
        if(isCircleButton){
            ellipse(but_x, but_y, but_dx, but_dy); //draw circular button
        } else{
            if(cornerRoundness == 0){
                rect(but_x, but_y, but_dx, but_dy); //draw normal rectangle button
            } else {
                rect(but_x, but_y, but_dx, but_dy, cornerRoundness); //draw button with rounded corners
            }
        }

        //draw the text
        if (isActive) {
            fill(textColorActive);
        } else {
            fill(textColorNotActive);
        }
        stroke(255);
        textFont(buttonFont);  //load f2 ... from control panel
        textSize(buttonTextSize);
        textAlign(CENTER, CENTER);
        textLeading(round(0.9f*(textAscent()+textDescent())));
        //    int x1 = but_x+but_dx/2;
        //    int y1 = but_y+but_dy/2;
        int x1, y1;
        //no auto wrap
        x1 = but_x+but_dx/2;
        y1 = but_y+but_dy/2;

        if(hasbgImage){ //if there is a bg image ... don't draw text
            imageMode(CENTER);
            image(bgImage, but_x + (but_dx/2), but_y + (but_dy/2), but_dx-8, but_dy-8);
        } else{  //otherwise draw text
            if(buttonFont == h1 || buttonFont == h2 || buttonFont == h3 || buttonFont == h4 || buttonFont == h5){
                text(but_txt, x1, y1 - 1); //for some reason y looks better at -1 with montserrat
            } else if(buttonFont == p1 || buttonFont == p2 || buttonFont == p3 || buttonFont == p4 || buttonFont == p5 || buttonFont == p6){
                textLeading(12); //line spacing
                text(but_txt, x1, y1 - 2); //for some reason y looks better at -2 w/ Open Sans
            } else{
                text(but_txt, x1, y1); //as long as font is not Montserrat
            }
        }

        //send some info to the HelpButtonText object to be drawn last in OpenBCI_GUI.pde ... we want to make sure it is render last, and on top of all other GUI stuff
        if(showHelpText && helpText != ""){
            buttonHelpText.setButtonHelpText(helpText, but_x + but_dx/2, but_y + (3*but_dy)/4);
            buttonHelpText.setVisible(true);
        }
        //draw open/close arrow if it's a dropdown button
        if (isDropdownButton) {
            pushStyle();
            fill(255);
            noStroke();
            // smooth();
            // stroke(255);
            // strokeWeight(1);
            if (isActive) {
                float point1x = but_x + (but_dx - ((3f*but_dy)/4f));
                float point1y = but_y + but_dy/3f;
                float point2x = but_x + (but_dx-(but_dy/4f));
                float point2y = but_y + but_dy/3f;
                float point3x = but_x + (but_dx - (but_dy/2f));
                float point3y = but_y + (2f*but_dy)/3f;
                triangle(point1x, point1y, point2x, point2y, point3x, point3y); //downward triangle, indicating open
            } else {
                float point1x = but_x + (but_dx - ((3f*but_dy)/4f));
                float point1y = but_y + (2f*but_dy)/3f;
                float point2x = but_x + (but_dx-(but_dy/4f));
                float point2y = but_y + (2f*but_dy)/3f;
                float point3x = but_x + (but_dx - (but_dy/2f));
                float point3y = but_y + but_dy/3f;
                triangle(point1x, point1y, point2x, point2y, point3x, point3y); //upward triangle, indicating closed
            }
            popStyle();
        }
        popStyle();
    } //end of button draw
};

class ButtonHelpText{
    int x, y, w, h;
    String myText = "";
    boolean isVisible;
    int numLines;
    int lineSpacing = 14;
    int padding = 10;

    ButtonHelpText(){

    }

    public void setVisible(boolean _isVisible){
        isVisible = _isVisible;
    }

    public void setButtonHelpText(String _myText, int _x, int _y){
        myText = _myText;
        x = _x;
        y = _y;
    }

    public void draw(){
        if(isVisible){
            pushStyle();
            textAlign(CENTER, TOP);

            textFont(p5,12);
            textLeading(lineSpacing); //line spacing
            stroke(31,69,110);
            fill(255);
            numLines = (int)((float)myText.length()/30.0f) + 1; //add 1 to round up
            // println("numLines: " + numLines);
            //if on left side of screen, draw box brightness to prevent box off screen
            if(x <= width/2){
                rect(x, y, 200, 2*padding + numLines*lineSpacing + 4);
                fill(31,69,110); //text colof
                text(myText, x + padding, y + padding, 180, (numLines*lineSpacing + 4));
            } else{ //if on right side of screen, draw box left to prevent box off screen
                rect(x - 200, y, 200, 2*padding + numLines*lineSpacing + 4);
                fill(31,69,110); //text colof
                text(myText, x + padding - 200, y + padding, 180, (numLines*lineSpacing + 4));
            }
            popStyle();
        }
    }
};

public void openURLInBrowser(String _url){
    try {
        //Set your page url in this string. For eg, I m using URL for Google Search engine
        java.awt.Desktop.getDesktop().browse(java.net.URI.create(_url));
        output("Attempting to use your default browser to launch: " + _url);
    }
    catch (java.io.IOException e) {
            //println(e.getMessage());
            println("Error launching url in browser: " + _url);
    }
}

public void toggleFrameRate(){
    if(frameRateCounter<3){
        frameRateCounter++;
    } else {
        frameRateCounter = 1; // until we resolve the latency issue with 24hz, only allow 30hz minimum (aka frameRateCounter = 1)
    }
    if(frameRateCounter==0){
        frameRate(24); //refresh rate ... this will slow automatically, if your processor can't handle the specified rate
        topNav.fpsButton.setString("24 fps");
    }
    if(frameRateCounter==1){
        frameRate(30);
        topNav.fpsButton.setString("30 fps");
    }
    if(frameRateCounter==2){
        frameRate(45);
        topNav.fpsButton.setString("45 fps");
    }
    if(frameRateCounter==3){
        frameRate(60);
        topNav.fpsButton.setString("60 fps");
    }
}

//loop through networking textfields and find out if any are active
public boolean isNetworkingTextActive(){
    boolean isAFieldActive = false;
    if (w_networking != null) {
        int numTextFields = w_networking.cp5_networking.getAll(Textfield.class).size();
        for(int i = 0; i < numTextFields; i++){
            if(w_networking.cp5_networking.getAll(Textfield.class).get(i).isFocus()){
                isAFieldActive = true;
            }
        }
    }
    //println("Networking Text Field Active? " + isAFieldActive);
    return isAFieldActive; //if not, return false
}
///////////////////////////////////////////////////////////////////////////////
//
// This class configures and manages the connection to the OpenBCI Ganglion.
// The connection is implemented via a TCP connection to a TCP port.
// The Gagnlion is configured using single letter text commands sent from the
// PC to the TCP server.  The EEG data streams back from the Ganglion, to the
// TCP server and back to the PC continuously (once started).
//
// Created: AJ Keller, August 2016
//
/////////////////////////////////////////////////////////////////////////////

//------------------------------------------------------------------------
//                       Global Functions
//------------------------------------------------------------------------

int numPacketsDroppedHub = 0;
final boolean debugRandomlyDropPackets = false; // SET THIS TO FALSE BEFORE SHIPPING

final static String TCP_JSON_KEY_ACTION = "action";
final static String TCP_JSON_KEY_ACCEL_DATA_COUNTS = "accelDataCounts";
final static String TCP_JSON_KEY_AUX_DATA = "auxData";
final static String TCP_JSON_KEY_BOARD_TYPE = "boardType";
final static String TCP_JSON_KEY_BURST_MODE = "burst";
final static String TCP_JSON_KEY_CHANNEL_DATA_COUNTS = "channelDataCounts";
final static String TCP_JSON_KEY_CHANNEL_NUMBER = "channelNumber";
final static String TCP_JSON_KEY_CHANNEL_SET_CHANNEL_NUMBER = "channelNumber";
final static String TCP_JSON_KEY_CHANNEL_SET_POWER_DOWN = "powerDown";
final static String TCP_JSON_KEY_CHANNEL_SET_GAIN = "gain";
final static String TCP_JSON_KEY_CHANNEL_SET_INPUT_TYPE = "inputType";
final static String TCP_JSON_KEY_CHANNEL_SET_BIAS = "bias";
final static String TCP_JSON_KEY_CHANNEL_SET_SRB2 = "srb2";
final static String TCP_JSON_KEY_CHANNEL_SET_SRB1 = "srb1";
final static String TCP_JSON_KEY_CODE = "code";
final static String TCP_JSON_KEY_COMMAND = "command";
final static String TCP_JSON_KEY_DATA = "data";
final static String TCP_JSON_KEY_FIRMWARE = "firmware";
final static String TCP_JSON_KEY_IMPEDANCE_VALUE = "impedanceValue";
final static String TCP_JSON_KEY_IMPEDANCE_SET_P_INPUT = "pInputApplied";
final static String TCP_JSON_KEY_IMPEDANCE_SET_N_INPUT = "nInputApplied";
final static String TCP_JSON_KEY_LATENCY = "latency";
final static String TCP_JSON_KEY_LOWER = "lower";
final static String TCP_JSON_KEY_MESSAGE = "message";
final static String TCP_JSON_KEY_NAME = "name";
final static String TCP_JSON_KEY_PROTOCOL = "protocol";
final static String TCP_JSON_KEY_SAMPLE_NUMBER = "sampleNumber";
final static String TCP_JSON_KEY_SAMPLE_RATE = "sampleRate";
final static String TCP_JSON_KEY_SHIELD_NAME = "shieldName";
final static String TCP_JSON_KEY_STOP_BYTE = "stopByte";
final static String TCP_JSON_KEY_TIMESTAMP = "timestamp";
final static String TCP_JSON_KEY_TYPE = "type";

final static String TCP_TYPE_ACCEL = "accelerometer";
final static String TCP_TYPE_BOARD_TYPE = "boardType";
final static String TCP_TYPE_CHANNEL_SETTINGS = "channelSettings";
final static String TCP_TYPE_COMMAND = "command";
final static String TCP_TYPE_CONNECT = "connect";
final static String TCP_TYPE_DISCONNECT = "disconnect";
final static String TCP_TYPE_DATA = "data";
final static String TCP_TYPE_ERROR = "error";
final static String TCP_TYPE_EXAMINE = "examine";
final static String TCP_TYPE_IMPEDANCE = "impedance";
final static String TCP_TYPE_LOG = "log";
final static String TCP_TYPE_PROTOCOL = "protocol";
final static String TCP_TYPE_SCAN = "scan";
final static String TCP_TYPE_SD = "sd";
final static String TCP_TYPE_STATUS = "status";
final static String TCP_TYPE_WIFI = "wifi";
final static String TCP_STOP = "\r\n";

final static String TCP_ACTION_SET = "set";
final static String TCP_ACTION_START = "start";
final static String TCP_ACTION_STATUS = "status";
final static String TCP_ACTION_STOP = "stop";


final static String TCP_WIFI_ERASE_CREDENTIALS = "eraseCredentials";
final static String TCP_WIFI_GET_FIRMWARE_VERSION = "getFirmwareVersion";
final static String TCP_WIFI_GET_IP_ADDRESS = "getIpAddress";
final static String TCP_WIFI_GET_MAC_ADDRESS = "getMacAddress";
final static String TCP_WIFI_GET_TYPE_OF_ATTACHED_BOARD = "getTypeOfAttachedBoard";

final static byte BYTE_START = (byte)0xA0;
final static byte BYTE_END = (byte)0xC0;

// States For Syncing with the hardware
enum HubState {
    NOCOM,
    COMINIT,
    SYNCWITHHARDWARE,
    NORMAL,
    STOPPED
}

final static int STATE_STOPPED = 4;
final static int COM_INIT_MSEC = 3000; //you may need to vary this for your computer or your Arduino

final static int NUM_ACCEL_DIMS = 3;

final static int RESP_ERROR_UNKNOWN = 499;
final static int RESP_ERROR_ALREADY_CONNECTED = 408;
final static int RESP_ERROR_BAD_PACKET = 500;
final static int RESP_ERROR_BAD_NOBLE_START = 501;
final static int RESP_ERROR_CHANNEL_SETTINGS = 423;
final static int RESP_ERROR_CHANNEL_SETTINGS_SYNC_IN_PROGRESS = 422;
final static int RESP_ERROR_CHANNEL_SETTINGS_FAILED_TO_SET_CHANNEL = 424;
final static int RESP_ERROR_CHANNEL_SETTINGS_FAILED_TO_PARSE = 425;
final static int RESP_ERROR_COMMAND_NOT_ABLE_TO_BE_SENT = 406;
final static int RESP_ERROR_COMMAND_NOT_RECOGNIZED = 434;
final static int RESP_ERROR_DEVICE_NOT_FOUND = 405;
final static int RESP_ERROR_IMPEDANCE_COULD_NOT_START = 414;
final static int RESP_ERROR_IMPEDANCE_COULD_NOT_STOP = 415;
final static int RESP_ERROR_IMPEDANCE_FAILED_TO_SET_IMPEDANCE = 430;
final static int RESP_ERROR_IMPEDANCE_FAILED_TO_PARSE = 431;
final static int RESP_ERROR_NO_OPEN_BLE_DEVICE = 400;
final static int RESP_ERROR_UNABLE_TO_CONNECT = 402;
final static int RESP_ERROR_UNABLE_TO_DISCONNECT = 401;
final static int RESP_ERROR_PROTOCOL_UNKNOWN = 418;
final static int RESP_ERROR_PROTOCOL_BLE_START = 419;
final static int RESP_ERROR_PROTOCOL_NOT_STARTED = 420;
final static int RESP_ERROR_UNABLE_TO_SET_BOARD_TYPE = 421;
final static int RESP_ERROR_SCAN_ALREADY_SCANNING = 409;
final static int RESP_ERROR_SCAN_NONE_FOUND = 407;
final static int RESP_ERROR_SCAN_NO_SCAN_TO_STOP = 410;
final static int RESP_ERROR_SCAN_COULD_NOT_START = 412;
final static int RESP_ERROR_SCAN_COULD_NOT_STOP = 411;
final static int RESP_ERROR_TIMEOUT_SCAN_STOPPED = 432;
final static int RESP_ERROR_WIFI_ACTION_NOT_RECOGNIZED = 427;
final static int RESP_ERROR_WIFI_COULD_NOT_ERASE_CREDENTIALS = 428;
final static int RESP_ERROR_WIFI_COULD_NOT_SET_LATENCY = 429;
final static int RESP_ERROR_WIFI_NEEDS_UPDATE = 435;
final static int RESP_ERROR_WIFI_NOT_CONNECTED = 426;
final static int RESP_GANGLION_FOUND = 201;
final static int RESP_SUCCESS = 200;
final static int RESP_SUCCESS_DATA_ACCEL = 202;
final static int RESP_SUCCESS_DATA_IMPEDANCE = 203;
final static int RESP_SUCCESS_DATA_SAMPLE = 204;
final static int RESP_WIFI_FOUND = 205;
final static int RESP_SUCCESS_CHANNEL_SETTING = 207;
final static int RESP_STATUS_CONNECTED = 300;
final static int RESP_STATUS_DISCONNECTED = 301;
final static int RESP_STATUS_SCANNING = 302;
final static int RESP_STATUS_NOT_SCANNING = 303;

final static int LATENCY_5_MS = 5000;
final static int LATENCY_10_MS = 10000;
final static int LATENCY_20_MS = 20000;

final static String TCP = "tcp";
final static String UDP = "udp";
final static String UDP_BURST = "udpBurst";

final static String WIFI_DYNAMIC = "dynamic";
final static String WIFI_STATIC = "static";

public void clientEvent(Client someClient) {
    int p;
    char newChar;

    newChar = hub.tcpClient.readChar();
    while(newChar != (char)-1) {
        p = hub.tcpBufferPositon;
        hub.tcpBuffer[p] = newChar;
        hub.tcpBufferPositon++;

        if(p > 2) {
            String posMatch  = new String(hub.tcpBuffer, p - 1, 2);
            if (posMatch.equals(TCP_STOP)) {
                // println("MATCH");
                if (!hub.isHubRunning()) {
                    hub.setHubIsRunning(true);
                    println("Hub: clientEvent: handshake complete");
                }
                // Get a string from the tcp buffer
                String msg = new String(hub.tcpBuffer, 0, p);
                // Send the new string message to be processed

                if (eegDataSource == DATASOURCE_GANGLION) {
                    hub.parseMessage(msg);
                    // Check to see if the ganglion ble list needs to be updated
                    if (hub.deviceListUpdated) {
                        hub.deviceListUpdated = false;
                        if (ganglion.isBLE()) {
                            controlPanel.bleBox.refreshBLEList();
                        } else {
                            controlPanel.wifiBox.refreshWifiList();
                        }
                    }
                } else if (eegDataSource == DATASOURCE_CYTON) {
                    // Do stuff for cyton
                    hub.parseMessage(msg);
                    // Check to see if the ganglion ble list needs to be updated
                    if (hub.deviceListUpdated) {
                        hub.deviceListUpdated = false;
                        controlPanel.wifiBox.refreshWifiList();
                    }
                }

                // Reset the buffer position
                hub.tcpBufferPositon = 0;
            }
        }
        newChar = hub.tcpClient.readChar();
    }
}

class Hub {

    public int curLatency = LATENCY_10_MS;

    public String[] deviceList = new String[0];
    public boolean deviceListUpdated = false;

    private int bleErrorCounter = 0;
    private int prevSampleIndex = 0;

    private int requestedSampleRate = 0;
    private boolean setSampleRate = false;

    private HubState state = HubState.NOCOM;
    int prevState_millis = 0; // Used for calculating connect time out

    private int nEEGValuesPerPacket = 8;
    private int nAuxValuesPerPacket = 3;

    private int tcpHubPort = 10996;
    private String tcpHubIP = "127.0.0.1";

    private String firmwareVersion = "";

    private DataPacket_ADS1299 dataPacket;

    public Client tcpClient;
    private boolean portIsOpen = false;

    public int numberOfDevices = 0;
    private boolean hubRunning = false;
    public char[] tcpBuffer = new char[4096];
    public int tcpBufferPositon = 0;
    private String curProtocol = PROTOCOL_WIFI;
    private String curInternetProtocol = TCP;
    private String curWiFiStyle = WIFI_DYNAMIC;

    private boolean waitingForResponse = false;
    private boolean searching = false;
    private boolean checkingImpedance = false;
    private boolean accelModeActive = false;
    private boolean newAccelData = false;
    public int[] accelArray = new int[NUM_ACCEL_DIMS];
    public int[] validAccelValues = {0, 0, 0};
    public int validLastMarker;
    public int[] impedanceArray = new int[NCHAN_GANGLION + 1];

    // Getters
    public HubState get_state() { return state; }
    public int getLatency() { return curLatency; }
    public String getWifiInternetProtocol() { return curInternetProtocol; }
    public String getWiFiStyle() { return curWiFiStyle; }
    public boolean isPortOpen() { return portIsOpen; }
    public boolean isHubRunning() { return hubRunning; }
    public boolean isSearching() { return searching; }
    public boolean isCheckingImpedance() { return checkingImpedance; }
    public boolean isAccelModeActive() { return accelModeActive; }
    public void setLatency(int latency) {
        curLatency = latency;
        println("Setting Latency to " + latency);
    }
    public void setWifiInternetProtocol(String internetProtocol) {
        curInternetProtocol = internetProtocol;
        println("Setting WiFi Internet Protocol to " + internetProtocol);
    }
    public void setWiFiStyle(String wifiStyle) {
        curWiFiStyle = wifiStyle;
        println("Setting WiFi style to " + wifiStyle);
    }

    private PApplet mainApplet;

    //constructors
    Hub() {};  //only use this if you simply want access to some of the constants
    Hub(PApplet applet) {
        mainApplet = applet;

        /*
        // Able to start tcpClient connection?
        if(!startTCPClient()) {
            outputWarn("Failed to connect to OpenBCIHub background application. LIVE functionality will be disabled.");
            println("InterfaceHub: Hub error");
        }
        */
    }

    public void initDataPackets(int _nEEGValuesPerPacket, int _nAuxValuesPerPacket) {
        nEEGValuesPerPacket = _nEEGValuesPerPacket;
        nAuxValuesPerPacket = _nAuxValuesPerPacket;
        // For storing data into
        dataPacket = new DataPacket_ADS1299(nEEGValuesPerPacket, nAuxValuesPerPacket);  //this should always be 8 channels
        for(int i = 0; i < nEEGValuesPerPacket; i++) {
            dataPacket.values[i] = 0;
        }
        for(int i = 0; i < nAuxValuesPerPacket; i++){
            dataPacket.auxValues[i] = 0;
        }
    }

    /**
      * @description Used to `try` and start the tcpClient
      * @param applet {PApplet} - The main applet.
      * @return {boolean} - True if able to start.
      */
    public boolean startTCPClient() {
        tcpClient = new Client(mainApplet, tcpHubIP, tcpHubPort);
        return tcpClient.active();
    }

    public String getHubIP() { return tcpHubIP; }
    public int getHubPort() { return tcpHubPort; }

    /**
      * Sends a status message to the node process.
      */
    public boolean getStatus() {
        try {
            JSONObject json = new JSONObject();
            json.setString(TCP_JSON_KEY_TYPE, TCP_TYPE_STATUS);
            writeJSON(json);
            waitingForResponse = true;
            return true;
        } catch (NullPointerException E) {
            // The tcp client is not initalized, try now

            return false;
        }
    }

    public void setHubIsRunning(boolean isRunning) {
        hubRunning = isRunning;
    }

    // Return true if the display needs to be updated for the BLE list
    public void parseMessage(String data) {
        JSONObject json = parseJSONObject(data);
        if (json == null) {
            println("JSONObject could not be parsed" + data);
        } else {
            String type = json.getString(TCP_JSON_KEY_TYPE);
            if (type.equals(TCP_TYPE_ACCEL)) {
                processAccel(json);
            } else if (type.equals(TCP_TYPE_BOARD_TYPE)) {
                processBoardType(json);
            } else if (type.equals(TCP_TYPE_CHANNEL_SETTINGS)) {
                processRegisterQuery(json);
            } else if (type.equals(TCP_TYPE_COMMAND)) {
                processCommand(json);
            } else if (type.equals(TCP_TYPE_CONNECT)) {
                processConnect(json);
            } else if (type.equals(TCP_TYPE_DATA)) {
                processData(json);
            } else if (type.equals(TCP_TYPE_DISCONNECT)) {
                processDisconnect(json);
            } else if (type.equals(TCP_TYPE_ERROR)) {
                int code = json.getInt(TCP_JSON_KEY_CODE);
                String errorMessage = json.getString(TCP_JSON_KEY_MESSAGE);
                println("Hub: parseMessage: error: " + errorMessage);
                if (code == RESP_ERROR_COMMAND_NOT_RECOGNIZED) {
                    output("Hub in data folder outdated. Download a new hub for your OS at https://github.com/OpenBCI/OpenBCI_Hub/releases/latest");
                }
            } else if (type.equals(TCP_TYPE_EXAMINE)) {
                processExamine(json);
            } else if (type.equals(TCP_TYPE_IMPEDANCE)) {
                processImpedance(json);
            } else if (type.equals(TCP_TYPE_LOG)) {
                String logMessage = json.getString(TCP_JSON_KEY_MESSAGE);
                println("Hub: Log: " + logMessage);
                if (logMessage.startsWith("no daisy to attach")) cyton.daisyNotAttached = true;
            } else if (type.equals(TCP_TYPE_PROTOCOL)) {
                processProtocol(json);
            } else if (type.equals(TCP_TYPE_SCAN)) {
                processScan(json);
            } else if (type.equals(TCP_TYPE_SD)) {
                processSDCard(json);
            } else if (type.equals(TCP_TYPE_STATUS)) {
                processStatus(json);
            } else if (type.equals(TCP_TYPE_WIFI)) {
                processWifi(json);
            } else {
                println("Hub: parseMessage: default: " + data);
                output("Hub in data folder outdated. Download a new hub for your OS at https://github.com/OpenBCI/OpenBCI_Hub/releases/latest");
            }
        }
    }

    private void writeJSON(JSONObject json) {
        write(json.toString() + TCP_STOP);
    }

    private void handleError(int code, String msg) {
        output("Code " + code + " Error: " + msg);
    }

    public void setBoardType(String boardType) {
        println("Hub: setBoardType(): sending \'" + boardType + " -- " + millis());
        JSONObject json = new JSONObject();
        json.setString(TCP_JSON_KEY_TYPE, TCP_TYPE_BOARD_TYPE);
        json.setString(TCP_JSON_KEY_BOARD_TYPE, boardType);
        writeJSON(json);
    }

    private void processBoardType(JSONObject json) {
        int code = json.getInt(TCP_JSON_KEY_CODE);
        switch (code) {
            case RESP_SUCCESS:
                if (sdSetting > 0) {
                    println("Hub: processBoardType: success, starting SD card now -- " + millis());
                    sdCardStart(sdSetting);
                } else {
                    println("Hub: processBoardType: success -- " + millis());
                    initAndShowGUI();
                }
                break;
            case RESP_ERROR_UNABLE_TO_SET_BOARD_TYPE:
            default:
                String msg = json.getString(TCP_JSON_KEY_MESSAGE);
                killAndShowMsg("Unable to process board type. " + msg);
                break;
        }
    }

    private void processConnect(JSONObject json) {
        int code = json.getInt(TCP_JSON_KEY_CODE);
        println("Hub: processConnect: made it -- " + millis() + " code: " + code);
        switch (code) {
            case RESP_SUCCESS:
            case RESP_ERROR_ALREADY_CONNECTED:
                firmwareVersion = json.getString(TCP_JSON_KEY_FIRMWARE);
                changeState(HubState.SYNCWITHHARDWARE);
                if (eegDataSource == DATASOURCE_CYTON) {
                    if (nchan == 8) {
                        setBoardType("cyton");
                    } else {
                        setBoardType("daisy");
                    }
                } else {
                    println("Hub: parseMessage: connect: success! -- " + millis());
                    initAndShowGUI();
                }
                break;
            case RESP_ERROR_UNABLE_TO_CONNECT:
                println("Error in processConnect: RESP_ERROR_UNABLE_TO_CONNECT");
                String message = json.getString(TCP_JSON_KEY_MESSAGE);
                if (message.equals("Error: Invalid sample rate")) {
                    if (eegDataSource == DATASOURCE_CYTON) {
                        killAndShowMsg("WiFi Shield is connected to a Ganglion. Please select LIVE (from Ganglion) instead of LIVE (from Cyton)");
                    } else {
                        killAndShowMsg("WiFi Shield is connected to a Cyton. Please select LIVE (from Cyton) instead LIVE (from Cyton)");
                    }
                } else {
                    killAndShowMsg("Unable to Connect: " + message);
                }
                break;
            case RESP_ERROR_WIFI_NEEDS_UPDATE:
                println("Error in processConnect: RESP_ERROR_WIFI_NEEDS_UPDATE");
                killAndShowMsg("WiFi Shield Firmware is out of date. Learn to update: https://openbci.github.io/Documentation/docs/05ThirdParty/03-WiFiShield/WiFiProgam");
                break;
            default:
                println("Error in processConnect");
                message = json.getString(TCP_JSON_KEY_MESSAGE, "none");
                handleError(code, message);
                break;
        }
    }

    private void processExamine(JSONObject json) {
        // println(msg);
        int code = json.getInt(TCP_JSON_KEY_CODE);
        switch (code) {
            case RESP_SUCCESS:
                portIsOpen = true;
                output("Connected to WiFi Shield named " + wifi_portName);
                if (wcBox.isShowing) {
                    wcBox.updateMessage("Connected to WiFi Shield named " + wifi_portName);
                }
                break;
            case RESP_ERROR_ALREADY_CONNECTED:
                portIsOpen = true;
                output("WiFi Shield is still connected to " + wifi_portName);
                break;
            case RESP_ERROR_UNABLE_TO_CONNECT:
                output("No WiFi Shield found. Please visit https://openbci.github.io/Documentation/docs/01GettingStarted/01-Boards/WiFiGS");
                break;
            default:
                if (wcBox.isShowing) println("it is showing"); //controlPanel.hideWifiPopoutBox();
                String message = json.getString(TCP_JSON_KEY_MESSAGE, "none");
                handleError(code, message);
                break;
        }
    }

    private void initAndShowGUI() {
        changeState(HubState.NORMAL);
        systemMode = SYSTEMMODE_POSTINIT;
        controlPanel.close();
        topNav.controlPanelCollapser.setIsActive(false);
        String firmwareString = " Cyton firmware ";
        String settingsString = "Settings Loaded! ";
        if (eegDataSource == DATASOURCE_CYTON) {
            firmwareString += firmwareVersion;
            if (settings.loadErrorCytonEvent == true) {
                outputError("Connection Error: Failed to apply channel settings to Cyton.");
            } else {
                outputSuccess("The GUI is done initializing. " + settingsString + "Press \"Start Data Stream\" to start streaming! -- " + firmwareString);
            }
        } else if (eegDataSource == DATASOURCE_GANGLION) {
            firmwareString = ganglion_portName;
            outputSuccess("The GUI is done initializing. " + settingsString + "Press \"Start Data Stream\" to start streaming! -- " + firmwareString);
        } else {
            firmwareString = "";
        }
        
        
        portIsOpen = true;
        controlPanel.hideAllBoxes();
    }

    private void killAndShowMsg(String msg) {
        println("Hub: killAndShowMsg: " + msg);
        abandonInit = true;
        initSystemButton.setString("START SESSION");
        controlPanel.open();
        portIsOpen = false;
        haltSystem();
    }

    /**
      * @description Sends a command to ganglion board
      */
    public void sendCommand(char c) {
        println("Hub: sendCommand(char): sending \'" + c + "\'");
        JSONObject json = new JSONObject();
        json.setString(TCP_JSON_KEY_TYPE, TCP_TYPE_COMMAND);
        json.setString(TCP_JSON_KEY_COMMAND, Character.toString(c));
        writeJSON(json);
    }

    /**
      * @description Sends a command to ganglion board
      */
    public void sendCommand(String s) {
        println("Hub: sendCommand(String): sending \'" + s + "\'");
        JSONObject json = new JSONObject();
        json.setString(TCP_JSON_KEY_TYPE, TCP_TYPE_COMMAND);
        json.setString(TCP_JSON_KEY_COMMAND, s);
        writeJSON(json);
    }

    public void processCommand(JSONObject json) {
        String message = "";
        int code = json.getInt(TCP_JSON_KEY_CODE);
        switch (code) {
            case RESP_SUCCESS:
                println("Hub: processCommand: success -- " + millis());
                break;
            case RESP_ERROR_COMMAND_NOT_ABLE_TO_BE_SENT:
                message = json.getString(TCP_JSON_KEY_MESSAGE, "");
                println("Hub: processCommand: ERROR_COMMAND_NOT_ABLE_TO_BE_SENT -- " + millis() + " " + message);
                break;
            case RESP_ERROR_PROTOCOL_NOT_STARTED:
                message = json.getString(TCP_JSON_KEY_MESSAGE, "");
                println("Hub: processCommand: RESP_ERROR_PROTOCOL_NOT_STARTED -- " + millis() + " " + message);
                break;
            default:
                break;
        }
    }

    public void processAccel(JSONObject json) {
        int code = json.getInt(TCP_JSON_KEY_CODE);
        if (code == RESP_SUCCESS_DATA_ACCEL) {
            JSONArray accelDataCounts = json.getJSONArray(TCP_JSON_KEY_ACCEL_DATA_COUNTS);
            for (int i = 0; i < NUM_ACCEL_DIMS; i++) {
                    accelArray[i] = accelDataCounts.getInt(i);
            }
            newAccelData = true;
            if (accelArray[0] > 0 || accelArray[1] > 0 || accelArray[2] > 0) {
                for (int i = 0; i < NUM_ACCEL_DIMS; i++) {
                    validAccelValues[i] = accelArray[i];
                }
            }
        }
    }

    public int getMaxSampleIndex() {
        if(curProtocol == PROTOCOL_BLE) {
            return 200;
        }

        return 255;
    }

    public void processData(JSONObject json) {
        try {
            int code = json.getInt(TCP_JSON_KEY_CODE);
            int stopByte = 0xC0;
            numPacketsDroppedHub = 0;
            if ((eegDataSource == DATASOURCE_GANGLION || eegDataSource == DATASOURCE_CYTON) && systemMode == 10 && isRunning) {
                if (code == RESP_SUCCESS_DATA_SAMPLE) {
                    // set debugRandomlyDropPackets to true to simulate packet drops
                    if(debugRandomlyDropPackets && random(0, 1000) < 1) {
                        println("WARNING: Randomly dropping packet for debugging purposes");
                        return;
                    }
                    // Sample number stuff
                    dataPacket.sampleIndex = json.getInt(TCP_JSON_KEY_SAMPLE_NUMBER);
                    boolean didWeRollOver = dataPacket.sampleIndex == 0 && prevSampleIndex == getMaxSampleIndex();

                    // if we rolled over, don't count as error
                    if (!didWeRollOver && (dataPacket.sampleIndex - prevSampleIndex) > 1) {
                        bleErrorCounter++;

                        if(dataPacket.sampleIndex < prevSampleIndex){   //handle the situation in which the index jumps from 250s past 255, and back to 0
                            numPacketsDroppedHub = (dataPacket.sampleIndex + getMaxSampleIndex()) - prevSampleIndex - 1; //calculate how many times the last received packet should be duplicated...
                        } else {
                            //calculate how many times the last received packet should be duplicated...
                            //Subtract 1 so this value is accurate (example 50->52, 52-50 = 2-1 = 1)
                            numPacketsDroppedHub = dataPacket.sampleIndex - prevSampleIndex - 1;
                        }
                        println("Hub: apparent sampleIndex jump from Serial data: " + prevSampleIndex + " to  " + dataPacket.sampleIndex + ".  Keeping packet. (" + bleErrorCounter + ")");
                        println("numPacketsDropped = " + numPacketsDroppedHub);
                    }
                    prevSampleIndex = dataPacket.sampleIndex;

                    // Channel data storage
                    JSONArray eegChannelDataCounts = json.getJSONArray(TCP_JSON_KEY_CHANNEL_DATA_COUNTS);
                    for (int i = 0; i < nEEGValuesPerPacket; i++) {
                        dataPacket.values[i] = eegChannelDataCounts.getInt(i);
                    }
                    if (newAccelData) {
                        newAccelData = false;
                        for (int i = 0; i < NUM_ACCEL_DIMS; i++) {
                            dataPacket.auxValues[i] = accelArray[i];
                            dataPacket.rawAuxValues[i][0] = PApplet.parseByte(accelArray[i]);
                        }
                    } else {
                        stopByte = json.getInt(TCP_JSON_KEY_STOP_BYTE);
                        if (stopByte == 0xC0) {
                            JSONArray accelValues = json.getJSONArray(TCP_JSON_KEY_ACCEL_DATA_COUNTS);
                            for (int i = 0; i < accelValues.size(); i++) {
                                accelArray[i] = accelValues.getInt(i);
                                dataPacket.auxValues[i] = accelArray[i];
                                dataPacket.rawAuxValues[i][0] = PApplet.parseByte(accelArray[i]);
                                dataPacket.rawAuxValues[i][1] = PApplet.parseByte(accelArray[i] >> 8);
                            }
                            if (accelArray[0] > 0 || accelArray[1] > 0 || accelArray[2] > 0) {
                                // println(msg);
                                for (int i = 0; i < NUM_ACCEL_DIMS; i++) {
                                    validAccelValues[i] = accelArray[i];
                                }
                            }
                        } else {
                            JSONObject auxData = json.getJSONObject(TCP_JSON_KEY_AUX_DATA);
                            JSONArray auxDataValues;
                            if (nchan == NCHAN_CYTON_DAISY) {
                                JSONObject lowerAuxData = auxData.getJSONObject(TCP_JSON_KEY_LOWER);
                                auxDataValues = lowerAuxData.getJSONArray(TCP_JSON_KEY_DATA);
                            } else {
                                auxDataValues = auxData.getJSONArray(TCP_JSON_KEY_DATA);
                            }
                            int j = 0;
                            for (int i = 0; i < auxDataValues.size(); i+=2) {
                                int val1 = auxDataValues.getInt(i);
                                int val2 = auxDataValues.getInt(i+1);

                                dataPacket.auxValues[j] = (val1 << 8) | val2;
                                validAccelValues[j] = (val1 << 8) | val2;

                                dataPacket.rawAuxValues[j][0] = PApplet.parseByte(val2);
                                dataPacket.rawAuxValues[j][1] = PApplet.parseByte(val1 << 8);
                                j++;
                            }
                        }
                    }
                    getRawValues(dataPacket);

                    // KILL SPIKES!!!
                    if(numPacketsDroppedHub > 0) {
                        println("Interpolating dropped packets...");

                        // the number of separations between the last received packet and the current packet.
                        // for example if we dropped 3 packets, we will have 4 divisions (marked with ---):
                        // 162, 163, 164 --- X --- X --- X --- 168, 169, 170...
                        int numSections = numPacketsDroppedHub + 1;

                        DataPacket_ADS1299 current = dataPacket;                        
                        DataPacket_ADS1299 previous = dataPacketBuff[curDataPacketInd];

                        for (int i = 1; i <= numPacketsDroppedHub; i++){
                            // increment current packet index
                            curDataPacketInd = (curDataPacketInd + 1) % dataPacketBuff.length;

                            // this bias allows us to handle multiple dropped packets in a row
                            // by adjusting the lerp coefficient depending on which packet we are filling in
                            float bias = (float)i / (float)numSections;
                            DataPacket_ADS1299 interpolated = CreateInterpolatedPacket(previous, current, bias);
                            interpolated.copyTo(dataPacketBuff[curDataPacketInd]);
                        }
                    }

                    curDataPacketInd = (curDataPacketInd + 1) % dataPacketBuff.length; // This is also used to let the rest of the code that it may be time to do something
                    copyDataPacketTo(dataPacketBuff[curDataPacketInd]);

                    switch (outputDataSource) {
                        case OUTPUT_SOURCE_ODF:
                            if (eegDataSource == DATASOURCE_GANGLION) {
                                fileoutput_odf.writeRawData_dataPacket(
                                    dataPacketBuff[curDataPacketInd],
                                    ganglion.get_scale_fac_uVolts_per_count(),
                                    ganglion.get_scale_fac_accel_G_per_count(),
                                    stopByte,
                                    json.getLong(TCP_JSON_KEY_TIMESTAMP)
                                );
                            } else {
                                fileoutput_odf.writeRawData_dataPacket(
                                    dataPacketBuff[curDataPacketInd],
                                    cyton.get_scale_fac_uVolts_per_count(),
                                    cyton.get_scale_fac_accel_G_per_count(),
                                    stopByte,
                                    json.getLong(TCP_JSON_KEY_TIMESTAMP)
                                );
                            }
                            break;
                        case OUTPUT_SOURCE_BDF:
                            // curBDFDataPacketInd = curDataPacketInd;
                            // thread("writeRawData_dataPacket_bdf");
                            fileoutput_bdf.writeRawData_dataPacket(dataPacketBuff[curDataPacketInd]);
                            break;
                        case OUTPUT_SOURCE_NONE:
                        default:
                            // Do nothing...
                            break;
                    }
                } else {
                    bleErrorCounter++;
                    println("Hub: parseMessage: data: bad");
                }
            }
        } catch (Exception e) {
            println("\n\n" + json + "\nHub: parseMessage: error: " + e);
        }
    }

    private void processDisconnect(JSONObject json) {
        int code = json.getInt(TCP_JSON_KEY_CODE);
        switch (code) {
            case RESP_SUCCESS:
                if (!waitingForResponse) {
                    if (eegDataSource == DATASOURCE_CYTON) {
                        killAndShowMsg("Dang! Lost connection to Cyton. Please move closer or get a new battery!");
                    } else {
                        killAndShowMsg("Dang! Lost connection to Ganglion. Please move closer or get a new battery!");
                    }
                } else {
                    waitingForResponse = false;
                }
                break;
            case RESP_ERROR_UNABLE_TO_DISCONNECT:
                break;
        }
        portIsOpen = false;
    }

    private void processImpedance(JSONObject json) {
        String action = "";
        String message = "";
        int code = json.getInt(TCP_JSON_KEY_CODE);
        switch (code) {
            case RESP_ERROR_IMPEDANCE_COULD_NOT_START:
                ganglion.overrideCheckingImpedance(false);
            case RESP_ERROR_IMPEDANCE_COULD_NOT_STOP:
            case RESP_ERROR_IMPEDANCE_FAILED_TO_SET_IMPEDANCE:
            case RESP_ERROR_IMPEDANCE_FAILED_TO_PARSE:
                message = json.getString(TCP_JSON_KEY_MESSAGE);
                handleError(code, message);
                break;
            case RESP_SUCCESS_DATA_IMPEDANCE:
                ganglion.processImpedance(json);
                break;
            case RESP_SUCCESS:
                action = json.getString(TCP_JSON_KEY_ACTION);
                output("Success: Impedance " + action + ".");
                if (eegDataSource == DATASOURCE_GANGLION && action.equals("stop")) {
                    //Change the ganglion impedance button text when the user clicks start data stream
                    if (!w_ganglionImpedance.startStopCheck.getButtonText().equals("Start Impedance Check")) {
                        w_ganglionImpedance.startStopCheck.setString("Start Impedance Check");
                    }
                }
                break;
            default:
                message = json.getString(TCP_JSON_KEY_MESSAGE);
                handleError(code, message);
                break;
        }
    }

    private void processProtocol(JSONObject json) {
        String message, protocol;
        int code = json.getInt(TCP_JSON_KEY_CODE);
        switch (code) {
            case RESP_SUCCESS:
                protocol = json.getString(TCP_JSON_KEY_PROTOCOL);
                output("Transfer Protocol set to " + protocol);
                if (eegDataSource == DATASOURCE_GANGLION && ganglion.isBLE()) {
                    // hub.searchDeviceStart();
                    outputInfo("BLE was powered up sucessfully, now searching for BLE devices.");
                }
                break;
            case RESP_ERROR_PROTOCOL_BLE_START:
                outputError("Failed to start Ganglion BLE Driver, please see https://openbci.github.io/Documentation/docs/01GettingStarted/01-Boards/GanglionGS");
                break;
            default:
                message = json.getString(TCP_JSON_KEY_MESSAGE);
                verbosePrint("Hub: ProcessProtocol: Error Code " + code);
                handleError(code, message);
                break;
        }
    }

    private void processStatus(JSONObject json) {
        int code = json.getInt(TCP_JSON_KEY_CODE);
        if (waitingForResponse) {
            waitingForResponse = false;
            println("Node process is up!");
        }
        if (code == RESP_ERROR_BAD_NOBLE_START) {
            println("Hub: processStatus: Problem in the Hub");
            output("Problem starting Ganglion Hub. Please make sure compatible USB is configured, then restart this GUI.");
        } else {
            println("Hub: processStatus: Started Successfully");
        }
    }

    private void processRegisterQuery(JSONObject json) {
        String action = "";
        String message = "";
        int code = json.getInt(TCP_JSON_KEY_CODE);
        switch (code) {
            case RESP_ERROR_CHANNEL_SETTINGS:
                killAndShowMsg("Failed to sync with Cyton, please power cycle your dongle and board.");
                message = json.getString(TCP_JSON_KEY_MESSAGE);
                println("RESP_ERROR_CHANNEL_SETTINGS general error: " + message);
                break;
            case RESP_ERROR_CHANNEL_SETTINGS_SYNC_IN_PROGRESS:
                println("tried to sync channel settings but there was already one in progress");
                break;
            case RESP_ERROR_CHANNEL_SETTINGS_FAILED_TO_SET_CHANNEL:
                message = json.getString(TCP_JSON_KEY_MESSAGE);
                println("an error was thrown trying to set the channels | error: " + message);
                break;
            case RESP_ERROR_CHANNEL_SETTINGS_FAILED_TO_PARSE:
                message = json.getString(TCP_JSON_KEY_MESSAGE);
                println("an error was thrown trying to call the function to set the channels | error: " + message);
                break;
            case RESP_SUCCESS:
                // Sent when either a scan was stopped or started Successfully
                action = json.getString(TCP_JSON_KEY_ACTION);
                if (action.equals(TCP_ACTION_START)) {
                    println("Query registers for cyton channel settings");
                } else if (action.equals(TCP_ACTION_SET)) {
                    settings.checkForSuccessTS = json.getInt(TCP_JSON_KEY_CODE);
                    println("Success writing channel " + json.getInt(TCP_JSON_KEY_CHANNEL_NUMBER));

                }
                break;
            case RESP_SUCCESS_CHANNEL_SETTING:
                int channelNumber = json.getInt(TCP_JSON_KEY_CHANNEL_SET_CHANNEL_NUMBER);
                // power down comes in as either 'true' or 'false', 'true' is a '1' and false is a '0'
                channelSettingValues[channelNumber][0] = json.getBoolean(TCP_JSON_KEY_CHANNEL_SET_POWER_DOWN) ? '1' : '0';
                // gain comes in as an int, either 1, 2, 4, 6, 8, 12, 24 and must get converted to
                //  '0', '1', '2', '3', '4', '5', '6' respectively, of course.
                channelSettingValues[channelNumber][1] = cyton.getCommandForGain(json.getInt(TCP_JSON_KEY_CHANNEL_SET_GAIN));
                // input type comes in as a string version and must get converted to char
                channelSettingValues[channelNumber][2] = cyton.getCommandForInputType(json.getString(TCP_JSON_KEY_CHANNEL_SET_INPUT_TYPE));
                // bias is like power down
                channelSettingValues[channelNumber][3] = json.getBoolean(TCP_JSON_KEY_CHANNEL_SET_BIAS) ? '1' : '0';
                // srb2 is like power down
                channelSettingValues[channelNumber][4] = json.getBoolean(TCP_JSON_KEY_CHANNEL_SET_SRB2) ? '1' : '0';
                // srb1 is like power down
                channelSettingValues[channelNumber][5] = json.getBoolean(TCP_JSON_KEY_CHANNEL_SET_SRB1) ? '1' : '0';
                break;
        }
    }

    private void processScan(JSONObject json) {
        String action = "";
        String message = "";
        String name = "";
        int code = json.getInt(TCP_JSON_KEY_CODE);
        switch (code) {
            case RESP_GANGLION_FOUND:
            case RESP_WIFI_FOUND:
                // Sent every time a new ganglion device is found
                name = json.getString(TCP_JSON_KEY_NAME, "");
                if (searchDeviceAdd(name)) {
                    deviceListUpdated = true;
                }
                break;
            case RESP_ERROR_SCAN_ALREADY_SCANNING:
                // Sent when a start send command is sent and the module is already
                //  scanning.
                // handleError(code, list[2]);
                searching = true;
                break;
            case RESP_SUCCESS:
                // Sent when either a scan was stopped or started Successfully
                action = json.getString(TCP_JSON_KEY_ACTION);
                switch (action) {
                    case TCP_ACTION_START:
                        searching = true;
                        break;
                    case TCP_ACTION_STOP:
                        searching = false;
                        break;
                }
                break;
            case RESP_ERROR_TIMEOUT_SCAN_STOPPED:
                searching = false;
                break;
            case RESP_ERROR_SCAN_COULD_NOT_START:
                // Sent when err on search start
                message = json.getString(TCP_JSON_KEY_MESSAGE, "");
                verbosePrint("Hub: ProcessScan: Error Code: " + code);
                if (code == RESP_ERROR_SCAN_COULD_NOT_START) {
                    outputError("Failed to start dongle. It may not be plugged in.");
                } else {
                    handleError(code, message);
                }
                searching = false;
                break;
            case RESP_ERROR_SCAN_COULD_NOT_STOP:
                // Send when err on search stop
                message = json.getString(TCP_JSON_KEY_MESSAGE, "");
                handleError(code, message);
                searching = false;
                break;
            case RESP_STATUS_SCANNING:
                // Sent when after status action sent to node and module is searching
                searching = true;
                break;
            case RESP_STATUS_NOT_SCANNING:
                // Sent when after status action sent to node and module is NOT searching
                searching = false;
                break;
            case RESP_ERROR_SCAN_NO_SCAN_TO_STOP:
                // Sent when a 'stop' action is sent to node and there is no scan to stop.
                // handleError(code, list[2]);
                searching = false;
                break;
            case RESP_ERROR_UNKNOWN:
            default:
                message = json.getString(TCP_JSON_KEY_MESSAGE, "");
                handleError(code, message);
                break;
        }
    }

    public void sdCardStart(int sdSetting) {
        String sdSettingStr = cyton.getSDSettingForSetting(sdSetting);
        println("Hub: sdCardStart(): sending \'" + sdSettingStr + "\' with value " + sdSetting);
        JSONObject json = new JSONObject();
        json.setString(TCP_JSON_KEY_ACTION, TCP_ACTION_START);
        json.setString(TCP_JSON_KEY_COMMAND, sdSettingStr);
        json.setString(TCP_JSON_KEY_TYPE, TCP_TYPE_SD);
        writeJSON(json);
    }

    private void processSDCard(JSONObject json) {
        String action, message;
        int code = json.getInt(TCP_JSON_KEY_CODE);
        action = json.getString(TCP_JSON_KEY_ACTION);

        switch(code) {
            case RESP_SUCCESS:
                // Sent when either a scan was stopped or started Successfully
                switch (action) {
                    case TCP_ACTION_START:
                        println("sd card setting set so now attempting to sync channel settings");
                        // cyton.syncChannelSettings();
                        initAndShowGUI();
                        break;
                    case TCP_ACTION_STOP:
                        message = json.getString(TCP_JSON_KEY_MESSAGE);
                        println("ProcessSDcard::Success:Stop: " + message);
                        break;
                }
                break;
            case RESP_ERROR_UNKNOWN:
                switch (action) {
                    case TCP_ACTION_START:
                        message = json.getString(TCP_JSON_KEY_MESSAGE);
                        killAndShowMsg("ProcessSDCard: " + message);
                        break;
                    case TCP_ACTION_STOP:
                        message = json.getString(TCP_JSON_KEY_MESSAGE);
                        println("ProcessSDcard::Unknown:Stop: " + message);
                        break;
                }
                break;
            default:
                message = json.getString(TCP_JSON_KEY_MESSAGE);
                handleError(code, message);
                break;
        }
    }

    public void writeRawData_dataPacket_bdf() {
        fileoutput_bdf.writeRawData_dataPacket(dataPacketBuff[curBDFDataPacketInd]);
    }

    public int copyDataPacketTo(DataPacket_ADS1299 target) {
        return dataPacket.copyTo(target);
    }

    public String getFirmwareVersion() {
        return firmwareVersion;
    }

    private void getRawValues(DataPacket_ADS1299 packet) {
        for (int i=0; i < nchan; i++) {
            int val = packet.values[i];
            //println(binary(val, 24));
            byte rawValue[] = new byte[3];
            // Breakdown values into
            rawValue[2] = PApplet.parseByte(val & 0xFF);
            //println("rawValue[2] " + binary(rawValue[2], 8));
            rawValue[1] = PApplet.parseByte((val & (0xFF << 8)) >> 8);
            //println("rawValue[1] " + binary(rawValue[1], 8));
            rawValue[0] = PApplet.parseByte((val & (0xFF << 16)) >> 16);
            //println("rawValue[0] " + binary(rawValue[0], 8));
            // Store to the target raw values
            packet.rawValues[i] = rawValue;
        }
    }

    public boolean isSuccessCode(int c) {
        return c == RESP_SUCCESS;
    }

    public void updateSyncState(int sdSetting) {
        //has it been 3000 milliseconds since we initiated the serial port? We want to make sure we wait for the OpenBCI board to finish its setup()
        if ( (millis() - prevState_millis > COM_INIT_MSEC) && (prevState_millis != 0) && (state == HubState.COMINIT) ) {
            state = HubState.SYNCWITHHARDWARE;
            println("InterfaceHub: systemUpdate: [0] Sending 'v' to OpenBCI to reset hardware in case of 32bit board...");
        }
    }

    public void closePort() {
        switch (curProtocol) {
            case PROTOCOL_BLE:
                disconnectBLE();
                break;
            case PROTOCOL_WIFI:
                disconnectWifi();
                break;
            case PROTOCOL_SERIAL:
                disconnectSerial();
                break;
            default:
                break;
        }
        changeState(HubState.NOCOM);
    }

    // CONNECTION
    public void connectBLE(String id) {
        JSONObject json = new JSONObject();
        json.setString(TCP_JSON_KEY_NAME, id);
        json.setString(TCP_JSON_KEY_TYPE, TCP_TYPE_CONNECT);
        writeJSON(json);
        verbosePrint("OpenBCI_GUI: hub : Sent connect to Hub - Id: " + id);

    }
    public void disconnectBLE() {
        waitingForResponse = true;
        JSONObject json = new JSONObject();
        json.setString(TCP_JSON_KEY_PROTOCOL, PROTOCOL_BLE);
        json.setString(TCP_JSON_KEY_TYPE, TCP_TYPE_DISCONNECT);
        writeJSON(json);
    }

    public void connectWifi(String id) {
        JSONObject json = new JSONObject();
        json.setInt(TCP_JSON_KEY_LATENCY, curLatency);
        if (curInternetProtocol == UDP_BURST) {
            json.setString(TCP_JSON_KEY_PROTOCOL, UDP);
            json.setBoolean(TCP_JSON_KEY_BURST_MODE, true);
        } else {
            json.setString(TCP_JSON_KEY_PROTOCOL, curInternetProtocol);
            json.setBoolean(TCP_JSON_KEY_BURST_MODE, false);
        }
        json.setInt(TCP_JSON_KEY_SAMPLE_RATE, requestedSampleRate);
        json.setString(TCP_JSON_KEY_NAME, id);
        json.setString(TCP_JSON_KEY_TYPE, TCP_TYPE_CONNECT);
        writeJSON(json);
        println("OpenBCI_GUI: hub : Sent connect to Hub - Id: " + id + " SampleRate: " + requestedSampleRate + "Hz Latency: " + curLatency + "ms");
    }

    public void examineWifi(String id) {
        JSONObject json = new JSONObject();
        json.setString(TCP_JSON_KEY_NAME, id);
        json.setString(TCP_JSON_KEY_TYPE, TCP_TYPE_EXAMINE);
        writeJSON(json);
    }

    public int disconnectWifi() {
        waitingForResponse = true;
        JSONObject json = new JSONObject();
        json.setString(TCP_JSON_KEY_PROTOCOL, PROTOCOL_WIFI);
        json.setString(TCP_JSON_KEY_TYPE, TCP_TYPE_DISCONNECT);
        writeJSON(json);
        return 0;
    }

    public void connectSerial(String id) {
        waitingForResponse = true;
        JSONObject json = new JSONObject();
        json.setString(TCP_JSON_KEY_PROTOCOL, PROTOCOL_SERIAL);
        json.setString(TCP_JSON_KEY_TYPE, TCP_TYPE_CONNECT);
        json.setString(TCP_JSON_KEY_NAME, id);
        writeJSON(json);
        verbosePrint("OpenBCI_GUI: hub : Sent connect to Hub - Id: " + id);
        delay(1000);

    }
    public int disconnectSerial() {
        println("Disconnecting serial...");
        waitingForResponse = true;
        JSONObject json = new JSONObject();
        json.setString(TCP_JSON_KEY_PROTOCOL, PROTOCOL_SERIAL);
        json.setString(TCP_JSON_KEY_TYPE, TCP_TYPE_DISCONNECT);
        writeJSON(json);
        return 0;
    }

    public void setProtocol(String _protocol) {
        curProtocol = _protocol;
        JSONObject json = new JSONObject();
        json.setString(TCP_JSON_KEY_ACTION, TCP_ACTION_START);
        json.setString(TCP_JSON_KEY_PROTOCOL, curProtocol);
        json.setString(TCP_JSON_KEY_TYPE, TCP_TYPE_PROTOCOL);
        writeJSON(json);
    }

    public String getProtocol() {
        return curProtocol;
    }

    public int getSampleRate() {
        return requestedSampleRate;
    }

    public void setSampleRate(int _sampleRate) {
        requestedSampleRate = _sampleRate;
        setSampleRate = true;
        println("\n\nsample rate set to: " + _sampleRate);
    }

    public void getWifiInfo(String info) {
        JSONObject json = new JSONObject();
        json.setString(TCP_JSON_KEY_ACTION, info);
        json.setString(TCP_JSON_KEY_TYPE, TCP_TYPE_WIFI);
        writeJSON(json);
    }

    private void processWifi(JSONObject json) {
        String action = "";
        String message = "";
        int code = json.getInt(TCP_JSON_KEY_CODE);
        switch (code) {
            case RESP_ERROR_WIFI_ACTION_NOT_RECOGNIZED:
                output("Sent an action to hub for wifi info but the command was unrecognized");
                break;
            case RESP_ERROR_WIFI_NOT_CONNECTED:
                output("Tried to get wifi info but no WiFi Shield was connected.");
                break;
            case RESP_ERROR_CHANNEL_SETTINGS_FAILED_TO_SET_CHANNEL:
                message = json.getString(TCP_JSON_KEY_MESSAGE);
                println("an error was thrown trying to set the channels | error: " + message);
                break;
            case RESP_ERROR_CHANNEL_SETTINGS_FAILED_TO_PARSE:
                message = json.getString(TCP_JSON_KEY_MESSAGE);
                println("an error was thrown trying to call the function to set the channels | error: " + message);
                break;
            case RESP_SUCCESS:
                // Sent when either a scan was stopped or started Successfully
                if (wcBox.isShowing) {
                    String msgForWcBox = json.getString(TCP_JSON_KEY_MESSAGE);
                    String command = json.getString(TCP_JSON_KEY_COMMAND);
                    switch (command) {
                        case TCP_WIFI_GET_TYPE_OF_ATTACHED_BOARD:
                            switch(message) {
                                case "none":
                                    msgForWcBox = "No OpenBCI Board attached to WiFi Shield";
                                    break;
                                case "ganglion":
                                    msgForWcBox = "4-channel Ganglion attached to WiFi Shield";
                                    break;
                                case "cyton":
                                    msgForWcBox = "8-channel Cyton attached to WiFi Shield";
                                    break;
                                case "daisy":
                                    msgForWcBox = "16-channel Cyton with Daisy attached to WiFi Shield";
                                    break;
                            }
                            break;
                        case TCP_WIFI_ERASE_CREDENTIALS:
                            output("WiFi credentials have been erased and WiFi Shield is in hotspot mode. If erase fails, remove WiFi Shield from OpenBCI Board.");
                            msgForWcBox = "";
                            controlPanel.hideWifiPopoutBox();
                            wifi_portName = "N/A";
                            clearDeviceList();
                            controlPanel.wifiBox.refreshWifiList();
                            break;
                    }
                    println("Success for wifi " + command + ": " + msgForWcBox);
                    wcBox.updateMessage(msgForWcBox);
                }
                break;
        }
    }

    /**
      * @description Write to TCP server
      * @params out {String} - The string message to write to the server.
      * @returns {boolean} - True if able to write, false otherwise.
      */
    public boolean write(String out) {
        try {
            // println("out " + out);
            tcpClient.write(out);
            return true;
        } catch (Exception e) {
            if (isWindows()) {
                killAndShowMsg("Please start OpenBCIHub before launching this application.");
            } else {
                killAndShowMsg("Hub has crashed, please restart your application.");
            }
            println("Error: Attempted to TCP write with no server connection initialized");
            return false;
        }
    }
    public boolean write(char val) {
        return write(String.valueOf(val));
    }

    public int changeState(HubState newState) {
        state = newState;
        prevState_millis = millis();
        return 0;
    }

    public void clearDeviceList() {
        deviceList = null;
        numberOfDevices = 0;
    }

    public void searchDeviceStart() {
        clearDeviceList();
        JSONObject json = new JSONObject();
        json.setString(TCP_JSON_KEY_ACTION, TCP_ACTION_START);
        json.setString(TCP_JSON_KEY_TYPE, TCP_TYPE_SCAN);
        writeJSON(json);
    }

    public void searchDeviceStop() {
        JSONObject json = new JSONObject();
        json.setString(TCP_JSON_KEY_ACTION, TCP_ACTION_STOP);
        json.setString(TCP_JSON_KEY_TYPE, TCP_TYPE_SCAN);
        writeJSON(json);
    }

    public boolean searchDeviceAdd(String localName) {
        if (numberOfDevices == 0) {
            numberOfDevices++;
            deviceList = new String[numberOfDevices];
            deviceList[0] = localName;
            return true;
        } else {
            boolean willAddToDeviceList = true;
            for (int i = 0; i < numberOfDevices; i++) {
                if (localName.equals(deviceList[i])) {
                    willAddToDeviceList = false;
                    break;
                }
            }
            if (willAddToDeviceList) {
                numberOfDevices++;
                String[] tempList = new String[numberOfDevices];
                arrayCopy(deviceList, tempList);
                tempList[numberOfDevices - 1] = localName;
                deviceList = tempList;
                return true;
            }
        }
        return false;
    }

};

class CheckHubInit extends TimerTask {
    public void run() {
        //Every hubTimerInterval seconds until hubTimerLimit is reached
        //try to open a new socket. If successful, close the socket and try to startTCPClient.
        try {
            Socket socket = new Socket(hub.getHubIP(), hub.getHubPort());
            if (socket != null) {
                socket.close();
                socket = null;
                if (hub.startTCPClient()) {
                    if (hubTimerCounter > 0) {
                        outputSuccess("The GUI is connected to the Hub!");
                    } else {
                        println("Hub: CheckHubInit: The GUI is connected to the Hub!");
                    }
                    hub.setHubIsRunning(true);
                    this.cancel();
                } else {
                    outputError("Hub: CheckHubInit: Unable to startTCPClient even though a socket was opened...");
                }
            }
        } catch (IOException e) {
            outputWarn("Unable to establish link with the OpenBCI Hub, trying again...");
        }

        hubTimerCounter++;
    }
}
///////////////////////////////////////////////////////////////////////////////
//
// This class configures and manages the connection to the Serial port for
// the Arduino.
//
// Created: Chip Audette, Oct 2013
// Modified: through April 2014
// Modified again: Conor Russomanno Sept-Oct 2014
// Modified for Daisy (16-chan) OpenBCI V3: Conor Russomanno Nov 2014
// Modified Daisy Behaviors: Chip Audette Dec 2014
// Modified For Wifi Addition: AJ Keller July 2017
//
// Note: this class now expects the data format produced by OpenBCI V3.
//
// Update July 2019:
//      - Portions of this are DEPRECATED
//      - serialEvent() is still used when checking Cyton status from Control Panel
//
/////////////////////////////////////////////////////////////////////////////

//------------------------------------------------------------------------
//                       Global Variables & Instances
//------------------------------------------------------------------------

int _myCounter;
int newPacketCounter = 0;
boolean no_start_connection = false;
byte inByte = -1;    // Incoming serial data
boolean isOpenBCI;
boolean isGettingPoll = false;
boolean spaceFound = false;
int hexToInt = 0;
boolean currentlySyncing = false;
long timeSinceStopRunning = 1000;

//these variables are used for "Kill Spikes" ... duplicating the last received data packet if packets were droppeds
boolean werePacketsDroppedSerial = false;
int numPacketsDroppedSerial = 0;


//everything below is now deprecated...
// final String[] command_activate_leadoffP_channel = {"!", "@", "#", "$", "%", "^", "&", "*"};  //shift + 1-8
// final String[] command_deactivate_leadoffP_channel = {"Q", "W", "E", "R", "T", "Y", "U", "I"};   //letters (plus shift) right below 1-8
// final String[] command_activate_leadoffN_channel = {"A", "S", "D", "F", "G", "H", "J", "K"}; //letters (plus shift) below the letters below 1-8
// final String[] command_deactivate_leadoffN_channel = {"Z", "X", "C", "V", "B", "N", "M", "<"};   //letters (plus shift) below the letters below the letters below 1-8
// final String command_biasAuto = "`";
// final String command_biasFixed = "~";

// ArrayList defaultChannelSettings;

//here is the routine that listens to the serial port.
//if any data is waiting, get it, parse it, and stuff it into our vector of
//pre-allocated dataPacketBuff

//------------------------------------------------------------------------
//                       Global Functions
//------------------------------------------------------------------------

public void serialEvent(Serial port){
    //check to see which serial port it is
    if (iSerial.isOpenBCISerial(port)) {

        // boolean echoBytes = !cyton.isStateNormal();
        boolean echoBytes;

        if (iSerial.isStateNormal() != true) {  // || printingRegisters == true){
            echoBytes = true;
        } else {
            echoBytes = false;
        }
        iSerial.read(echoBytes);
        openBCI_byteCount++;
        if (iSerial.get_isNewDataPacketAvailable()) {
            println("woo got a new packet");
            //copy packet into buffer of data packets
            curDataPacketInd = (curDataPacketInd+1) % dataPacketBuff.length; //this is also used to let the rest of the code that it may be time to do something

            cyton.copyDataPacketTo(dataPacketBuff[curDataPacketInd]);
            iSerial.set_isNewDataPacketAvailable(false); //resets isNewDataPacketAvailable to false

            // KILL SPIKES!!!
            if(werePacketsDroppedSerial){
                for(int i = numPacketsDroppedSerial; i > 0; i--){
                    int tempDataPacketInd = curDataPacketInd - i; //
                    if(tempDataPacketInd >= 0 && tempDataPacketInd < dataPacketBuff.length){
                        cyton.copyDataPacketTo(dataPacketBuff[tempDataPacketInd]);
                    } else {
                        cyton.copyDataPacketTo(dataPacketBuff[tempDataPacketInd+255]);
                    }
                    //put the last stored packet in # of packets dropped after that packet
                }

                //reset werePacketsDroppedSerial & numPacketsDroppedSerial
                werePacketsDroppedSerial = false;
                numPacketsDroppedSerial = 0;
            }

            switch (outputDataSource) {
            case OUTPUT_SOURCE_ODF:
                fileoutput_odf.writeRawData_dataPacket(dataPacketBuff[curDataPacketInd], cyton.get_scale_fac_uVolts_per_count(), cyton.get_scale_fac_accel_G_per_count(), PApplet.parseByte(0xC0), (new Date()).getTime());
                break;
            case OUTPUT_SOURCE_BDF:
                curBDFDataPacketInd = curDataPacketInd;
                thread("writeRawData_dataPacket_bdf");
                // fileoutput_bdf.writeRawData_dataPacket(dataPacketBuff[curDataPacketInd]);
                break;
            case OUTPUT_SOURCE_NONE:
            default:
                // Do nothing...
                break;
            }

            newPacketCounter++;
        }
    } else {

        //Used for serial communications, primarily everything in no_start_connection
        if (no_start_connection) {


            if (board_message == null || _myCounter>2) {
                board_message = new StringBuilder();
                _myCounter = 0;
            }

            inByte = PApplet.parseByte(port.read());
            print(inByte);
            if (PApplet.parseChar(inByte) == 'S' || PApplet.parseChar(inByte) == 'F') isOpenBCI = true;

            // print(char(inByte));
            if (inByte != -1) {
                if (isGettingPoll) {
                    if (inByte != '$') {
                        if (!spaceFound) board_message.append(PApplet.parseChar(inByte));
                        else hexToInt = Integer.parseInt(String.format("%02X", inByte), 16);

                        if (PApplet.parseChar(inByte) == ' ') spaceFound = true;
                    } else _myCounter++;
                } else {
                    if (inByte != '$') board_message.append(PApplet.parseChar(inByte));
                    else _myCounter++;
                }
            }
        } else {
            //println("Recieved serial data not from OpenBCI"); //this is a bit of a lie
            inByte = PApplet.parseByte(port.read());
            if (isOpenBCI) {

                if (board_message == null || _myCounter >2) {
                    board_message = new StringBuilder();
                    _myCounter=0;
                }
                if(inByte != '$'){
                    board_message.append(PApplet.parseChar(inByte));
                } else { _myCounter++; }
            } else if(PApplet.parseChar(inByte) == 'S' || PApplet.parseChar(inByte) == 'F'){
                isOpenBCI = true;
                if(board_message == null){
                    board_message = new StringBuilder();
                    board_message.append(PApplet.parseChar(inByte));
                }
            }
        }
    }
}

//------------------------------------------------------------------------
//                       Classes
//------------------------------------------------------------------------

class InterfaceSerial {

    //here is the serial port for this OpenBCI board
    private Serial serial_openBCI = null;
    private boolean portIsOpen = false;

    //final static int DATAMODE_TXT = 0;
    final static int DATAMODE_BIN = 2;
    final static int DATAMODE_BIN_WAUX = 1;  //switched to this value so that receiving Accel data is now the default
    //final static int DATAMODE_BIN_4CHAN = 4;

    final static int STATE_NOCOM = 0;
    final static int STATE_COMINIT = 1;
    final static int STATE_SYNCWITHHARDWARE = 2;
    final static int STATE_NORMAL = 3;
    final static int STATE_STOPPED = 4;
    final static int COM_INIT_MSEC = 3000; //you may need to vary this for your computer or your Arduino

    //int[] measured_packet_length = {0,0,0,0,0};
    //int measured_packet_length_ind = 0;
    //int known_packet_length_bytes = 0;

    final static byte BYTE_START = (byte)0xA0;
    final static byte BYTE_END = (byte)0xC0;

    int prefered_datamode = DATAMODE_BIN_WAUX;

    private int state = STATE_NOCOM;
    int dataMode = -1;
    int prevState_millis = 0;

    private int nEEGValuesPerPacket = 8; //defined by the data format sent by cyton boards
    private int nAuxValuesPerPacket = 3; //defined by the data format sent by cyton boards
    private DataPacket_ADS1299 rawReceivedDataPacket;
    private DataPacket_ADS1299 missedDataPacket;
    private DataPacket_ADS1299 dataPacket;
    public int [] validAuxValues = {0, 0, 0};
    public boolean[] freshAuxValuesAvailable = {false, false, false};
    public boolean freshAuxValues = false;
    //DataPacket_ADS1299 prevDataPacket;

    private int nAuxValues;
    private boolean isNewDataPacketAvailable = false;
    private OutputStream output; //for debugging  WEA 2014-01-26
    private int prevSampleIndex = 0;
    private int serialErrorCounter = 0;

    private final float fs_Hz = 250.0f;  //sample rate used by OpenBCI board...set by its Arduino code
    private final float ADS1299_Vref = 4.5f;  //reference voltage for ADC in ADS1299.  set by its hardware
    private float ADS1299_gain = 24.0f;  //assumed gain setting for ADS1299.  set by its Arduino code
    private float openBCI_series_resistor_ohms = 2200; // Ohms. There is a series resistor on the 32 bit board.
    private float scale_fac_uVolts_per_count = ADS1299_Vref / ((float)(pow(2, 23)-1)) / ADS1299_gain  * 1000000.f; //ADS1299 datasheet Table 7, confirmed through experiment
    //float LIS3DH_full_scale_G = 4;  // +/- 4G, assumed full scale setting for the accelerometer
    private final float scale_fac_accel_G_per_count = 0.002f / ((float)pow(2, 4));  //assume set to +/4G, so 2 mG per digit (datasheet). Account for 4 bits unused
    //final float scale_fac_accel_G_per_count = 1.0;
    private final float leadOffDrive_amps = 6.0e-9f;  //6 nA, set by its Arduino code
    private final String failureMessage = "Failure: Communications timeout - Device failed to poll Host";

    boolean isBiasAuto = true; //not being used?

    //data related to Conor's setup for V3 boards
    final char[] EOT = {'$', '$', '$'};
    char[] prev3chars = {'#', '#', '#'};
    private boolean readyToSend = false; //system waits for $$$ after requesting information from OpenBCI board
    private long timeOfLastCommand = 0; //used when sync'ing to hardware

    //wait for $$$ to iterate... applies to commands expecting a response
    public boolean isReadyToSend() {
        return readyToSend;
    }
    public void setReadyToSend(boolean _readyToSend) {
        readyToSend = _readyToSend;
    }
    public int get_state() {
        return state;
    };
    public boolean get_isNewDataPacketAvailable() {
        return isNewDataPacketAvailable;
    }
    public void set_isNewDataPacketAvailable(boolean _isNewDataPacketAvailable) {
        isNewDataPacketAvailable = _isNewDataPacketAvailable;
    }

    //constructors
    InterfaceSerial() {
    };  //only use this if you simply want access to some of the constants
    InterfaceSerial(PApplet applet, String comPort, int baud, int nEEGValuesPerOpenBCI, boolean useAux, int nAuxValuesPerOpenBCI) {
        //choose data mode
        println("InterfaceSerial: prefered_datamode = " + prefered_datamode + ", nValuesPerPacket = " + nEEGValuesPerPacket);
        if (prefered_datamode == DATAMODE_BIN_WAUX) {
            if (!useAux) {
                //must be requesting the aux data, so change the referred data mode
                prefered_datamode = DATAMODE_BIN;
                nAuxValues = 0;
                //println("InterfaceSerial: nAuxValuesPerPacket = " + nAuxValuesPerPacket + " so setting prefered_datamode to " + prefered_datamode);
            }
        }

        dataMode = prefered_datamode;

        initDataPackets(nEEGValuesPerOpenBCI, nAuxValuesPerOpenBCI);

    }

    public void initDataPackets(int numEEG, int numAux) {
        nEEGValuesPerPacket = numEEG;
        nAuxValuesPerPacket = numAux;
        //allocate space for data packet
        rawReceivedDataPacket = new DataPacket_ADS1299(nEEGValuesPerPacket, nAuxValuesPerPacket);  //this should always be 8 channels
        missedDataPacket = new DataPacket_ADS1299(nEEGValuesPerPacket, nAuxValuesPerPacket);  //this should always be 8 channels
        dataPacket = new DataPacket_ADS1299(nEEGValuesPerPacket, nAuxValuesPerPacket);            //this could be 8 or 16 channels

        for (int i = 0; i < nEEGValuesPerPacket; i++) {
            rawReceivedDataPacket.values[i] = 0;
            //prevDataPacket.values[i] = 0;
        }
        for (int i=0; i < nEEGValuesPerPacket; i++) {
            // println("i = " + i);
            dataPacket.values[i] = 0;
            missedDataPacket.values[i] = 0;
        }
        for (int i = 0; i < nAuxValuesPerPacket; i++) {
            rawReceivedDataPacket.auxValues[i] = 0;
            dataPacket.auxValues[i] = 0;
            missedDataPacket.auxValues[i] = 0;
            //prevDataPacket.auxValues[i] = 0;
        }
    }

    // //manage the serial port
    public int openSerialPort(PApplet applet, String comPort, int baud) {

        output("Attempting to open Serial/COM port: " + openBCI_portName);
        try {
            println("InterfaceSerial: openSerialPort: attempting to open serial port: " + openBCI_portName);
            serial_openBCI = new Serial(applet, comPort, baud); //open the com port
            serial_openBCI.clear(); // clear anything in the com port's buffer
            portIsOpen = true;
            println("InterfaceSerial: openSerialPort: port is open (t)? ... " + portIsOpen);
            changeState(STATE_COMINIT);
            return 0;
        }
        catch (RuntimeException e) {
            if (e.getMessage().contains("<init>")) {
                serial_openBCI = null;
                System.out.println("InterfaceSerial: openSerialPort: port in use, trying again later...");
                portIsOpen = false;
            } else {
                println("RunttimeException: " + e);
                output("Error connecting to selected Serial/COM port. Make sure your board is powered up and your dongle is plugged in.");
                abandonInit = true; //global variable in OpenBCI_GUI.pde
            }
            return 0;
        }
    }

    public int changeState(int newState) {
        state = newState;
        prevState_millis = millis();
        return 0;
    }

    public int finalizeCOMINIT() {
        changeState(STATE_NORMAL);
        return 0;
    }

    public int closeSDandSerialPort() {
        int returnVal=0;

        cyton.closeSDFile();

        readyToSend = false;
        returnVal = closeSerialPort();
        prevState_millis = 0;  //reset Serial state clock to use as a conditional for timing at the beginnign of systemUpdate()
        cyton.hardwareSyncStep = 0; //reset Hardware Sync step to be ready to go again...

        return returnVal;
    }

    public int closeSerialPort() {
        portIsOpen = false;
        if (serial_openBCI != null) {
            serial_openBCI.stop();
        }
        serial_openBCI = null;
        state = STATE_NOCOM;
        println("InterfaceSerial: closeSerialPort: closed");
        return 0;
    }

    public void updateSyncState(int sdSetting) {
        //Has it been 3000 milliseconds since we initiated the serial port?
        //We want to make sure we wait for the OpenBCI board to finish its setup()

        if ( (millis() - prevState_millis > COM_INIT_MSEC) && (prevState_millis != 0) && (state == STATE_COMINIT) ) {
            state = STATE_SYNCWITHHARDWARE;
            timeOfLastCommand = millis();
            serial_openBCI.clear();
            cyton.potentialFailureMessage = "";
            cyton.defaultChannelSettings = ""; //clear channel setting string to be reset upon a new Init System
            cyton.daisyOrNot = ""; //clear daisyOrNot string to be reset upon a new Init System
            println("InterfaceSerial: systemUpdate: [0] Sending 'v' to OpenBCI to reset hardware in case of 32bit board...");
            serial_openBCI.write('v');
        }

        //if we are in SYNC WITH HARDWARE state ... trigger a command
        if ( (state == STATE_SYNCWITHHARDWARE) && (currentlySyncing == false) ) {
            if (millis() - timeOfLastCommand > 200 && readyToSend == true) {
                println("sdSetting: " + sdSetting);
                timeOfLastCommand = millis();
                cyton.hardwareSyncStep++;
                cyton.syncWithHardware(sdSetting);
            }
        }
    }

    public void sendChar(char val) {
        if (isSerialPortOpen()) {
            println("sending out: " + val);
            serial_openBCI.write(val);//send the value as ascii (with a newline character?)
        } else {
            println("nope no out: " + val);

        }
    }

    public void write(String msg) {
        if (isSerialPortOpen()) {
            serial_openBCI.write(msg);
        }
    }

    public boolean isSerialPortOpen() {
        if (portIsOpen & (serial_openBCI != null)) {
            return true;
        } else {
            return false;
        }
    }
    public boolean isOpenBCISerial(Serial port) {
        if (serial_openBCI == port) {
            return true;
        } else {
            return false;
        }
    }

    public void clear() {
        if (serial_openBCI != null) {
            serial_openBCI.clear();
        }
    }

    //read from the serial port
    public int read() {
        return read(false);
    }
    public int read(boolean echoChar) {
        //println("InterfaceSerial: read(): State: " + state);
        //get the byte
        byte inByte;
        if (isSerialPortOpen()) {
            inByte = PApplet.parseByte(serial_openBCI.read());
        } else {
            println("InterfaceSerial port not open aborting.");
            return 0;
        }
        print(inByte);
        //write the most recent char to the console
        // If the GUI is in streaming mode then echoChar will be false
        if (echoChar) {  //if not in interpret binary (NORMAL) mode
            // print("hardwareSyncStep: "); println(hardwareSyncStep);
            // print(".");
            char inASCII = PApplet.parseChar(inByte);
            if (isRunning == false && (millis() - timeSinceStopRunning) > 500) {
                print(PApplet.parseChar(inByte));
            }

            //keep track of previous three chars coming from OpenBCI
            prev3chars[0] = prev3chars[1];
            prev3chars[1] = prev3chars[2];
            prev3chars[2] = inASCII;

            if (cyton.hardwareSyncStep == 0 && inASCII != '$') {
                cyton.potentialFailureMessage+=inASCII;
            }

            if (cyton.hardwareSyncStep == 1 && inASCII != '$') {
                cyton.daisyOrNot+=inASCII;
                //if hardware returns 8 because daisy is not attached, switch the GUI mode back to 8 channels
                // if(nchan == 16 && char(daisyOrNot.substring(daisyOrNot.length() - 1)) == '8'){
                if (nchan == 16 && cyton.daisyOrNot.charAt(cyton.daisyOrNot.length() - 1) == '8') {
                    // verbosePrint(" received from OpenBCI... Switching to nchan = 8 bc daisy is not present...");
                    verbosePrint(" received from OpenBCI... Abandoning hardware initiation.");
                    abandonInit = true;
                    // haltSystem();

                    // updateToNChan(8);
                    //
                    // //initialize the FFT objects
                    // for (int Ichan=0; Ichan < nchan; Ichan++) {
                    //   verbosePrint("Init FFT Buff – "+Ichan);
                    //   fftBuff[Ichan] = new FFT(Nfft, getSampleRateSafe());
                    // }  //make the FFT objects
                    //
                    // initializeFFTObjects(fftBuff, dataBuffY_uV, Nfft, getSampleRateSafe());
                    // setupWidgetManager();
                }
            }

            if (cyton.hardwareSyncStep == 3 && inASCII != '$') { //if we're retrieving channel settings from OpenBCI
                cyton.defaultChannelSettings+=inASCII;
            }

            //if the last three chars are $$$, it means we are moving on to the next stage of initialization
            if (prev3chars[0] == EOT[0] && prev3chars[1] == EOT[1] && prev3chars[2] == EOT[2]) {
                verbosePrint(" > EOT detected...");
                // Added for V2 system down rejection line
                if (cyton.hardwareSyncStep == 0) {
                    // Failure: Communications timeout - Device failed to poll Host$$$
                    if (cyton.potentialFailureMessage.equals(failureMessage)) {
                        closeLogFile();
                        return 0;
                    }
                }
                // hardwareSyncStep++;
                prev3chars[2] = '#';
                if (cyton.hardwareSyncStep == 3) {
                    println("InterfaceSerial: read(): x");
                    println("InterfaceSerial: defaultChanSettings: " + cyton.defaultChannelSettings);
                    println("InterfaceSerial: read(): y");
                    w_timeSeries.hsc.loadDefaultChannelSettings();
                    println("InterfaceSerial: read(): z");
                }
                readyToSend = true;
                // println(hardwareSyncStep);
            }
        }

        //write raw unprocessed bytes to a binary data dump file
        if (output != null) {
            try {
                output.write(inByte);   //for debugging  WEA 2014-01-26
            }
            catch (IOException e) {
                println("InterfaceSerial: read(): Caught IOException: " + e.getMessage());
                //do nothing
            }
        }

        interpretBinaryStream(inByte);  //new 2014-02-02 WEA
        return PApplet.parseInt(inByte);
    }

    /* **** Borrowed from Chris Viegl from his OpenBCI parser for BrainBay
    Modified by Joel Murphy and Conor Russomanno to read OpenBCI data
    Packet Parser for OpenBCI (1-N channel binary format):
    3-byte data values are stored in 'little endian' formant in AVRs
    so this protocol parser expects the lower bytes first.
    Start Indicator: 0xA0
    EXPECTING STANDARD PACKET LENGTH DON'T NEED: Packet_length  : 1 byte  (length = 4 bytes framenumber + 4 bytes per active channel + (optional) 4 bytes for 1 Aux value)
    Framenumber     : 1 byte (Sequential counter of packets)
    Channel 1 data  : 3 bytes
    ...
    Channel 8 data  : 3 bytes
    Aux Values      : UP TO 6 bytes
    End Indcator    : 0xC0
    TOTAL OF 33 bytes ALL DAY
    ********************************************************************* */
    private int nDataValuesInPacket = 0;
    private int localByteCounter=0;
    private int localChannelCounter=0;
    private int PACKET_readstate = 0;
    // byte[] localByteBuffer = {0,0,0,0};
    private byte[] localAdsByteBuffer = {0, 0, 0};
    private byte[] localAccelByteBuffer = {0, 0};

    public void interpretBinaryStream(byte actbyte) {
        boolean flag_copyRawDataToFullData = false;

        //println("InterfaceSerial: interpretBinaryStream: PACKET_readstate " + PACKET_readstate);
        switch (PACKET_readstate) {
        case 0:
            //look for header byte
            if (actbyte == PApplet.parseByte(0xA0)) {          // look for start indicator
                // println("InterfaceSerial: interpretBinaryStream: found 0xA0");
                PACKET_readstate++;
            }
            break;
        case 1:
            //check the packet counter
            // println("case 1");
            byte inByte = actbyte;
            rawReceivedDataPacket.sampleIndex = PApplet.parseInt(inByte); //changed by JAM
            if ((rawReceivedDataPacket.sampleIndex-prevSampleIndex) != 1) {
                if (rawReceivedDataPacket.sampleIndex != 0) {  // if we rolled over, don't count as error
                    serialErrorCounter++;
                    werePacketsDroppedSerial = true; //set this true to activate packet duplication in serialEvent

                    if(rawReceivedDataPacket.sampleIndex < prevSampleIndex){   //handle the situation in which the index jumps from 250s past 255, and back to 0
                        numPacketsDroppedSerial = (rawReceivedDataPacket.sampleIndex+255) - prevSampleIndex; //calculate how many times the last received packet should be duplicated...
                    } else {
                        numPacketsDroppedSerial = rawReceivedDataPacket.sampleIndex - prevSampleIndex; //calculate how many times the last received packet should be duplicated...
                    }

                    println("InterfaceSerial: apparent sampleIndex jump from Serial data: " + prevSampleIndex + " to  " + rawReceivedDataPacket.sampleIndex + ".  Keeping packet. (" + serialErrorCounter + ")");
                    if (outputDataSource == OUTPUT_SOURCE_BDF) {
                        int fakePacketsToWrite = (rawReceivedDataPacket.sampleIndex - prevSampleIndex) - 1;
                        for (int i = 0; i < fakePacketsToWrite; i++) {
                            fileoutput_bdf.writeRawData_dataPacket(missedDataPacket);
                        }
                        println("InterfaceSerial: because BDF, wrote " + fakePacketsToWrite + " empty data packet(s)");
                    }
                }
            }
            prevSampleIndex = rawReceivedDataPacket.sampleIndex;
            localByteCounter=0;//prepare for next usage of localByteCounter
            localChannelCounter=0; //prepare for next usage of localChannelCounter
            PACKET_readstate++;
            break;
        case 2:
            // get ADS channel values
            // println("case 2");
            localAdsByteBuffer[localByteCounter] = actbyte;
            localByteCounter++;
            if (localByteCounter==3) {
                rawReceivedDataPacket.values[localChannelCounter] = interpret24bitAsInt32(localAdsByteBuffer);
                arrayCopy(localAdsByteBuffer, rawReceivedDataPacket.rawValues[localChannelCounter]);
                localChannelCounter++;
                if (localChannelCounter==8) { //nDataValuesInPacket) {
                    // all ADS channels arrived !
                    // println("InterfaceSerial: interpretBinaryStream: localChannelCounter = " + localChannelCounter);
                    PACKET_readstate++;
                    if (prefered_datamode != DATAMODE_BIN_WAUX) PACKET_readstate++;  //if not using AUX, skip over the next readstate
                    localByteCounter = 0;
                    localChannelCounter = 0;
                    //isNewDataPacketAvailable = true;  //tell the rest of the code that the data packet is complete
                } else {
                    //prepare for next data channel
                    localByteCounter=0; //prepare for next usage of localByteCounter
                }
            }
            break;
        case 3:
            // get LIS3DH channel values 2 bytes times 3 axes
            // println("case 3");
            localAccelByteBuffer[localByteCounter] = actbyte;
            localByteCounter++;
            if (localByteCounter==2) {
                rawReceivedDataPacket.auxValues[localChannelCounter]  = interpret16bitAsInt32(localAccelByteBuffer);
                arrayCopy(localAccelByteBuffer, rawReceivedDataPacket.rawAuxValues[localChannelCounter]);
                if (rawReceivedDataPacket.auxValues[localChannelCounter] != 0) {
                    validAuxValues[localChannelCounter] = rawReceivedDataPacket.auxValues[localChannelCounter];
                    freshAuxValuesAvailable[localChannelCounter] = true;
                    freshAuxValues = true;
                } else freshAuxValues = false;
                localChannelCounter++;
                if (localChannelCounter==nAuxValues) { //number of accelerometer axis) {
                    // all Accelerometer channels arrived !
                    // println("InterfaceSerial: interpretBinaryStream: Accel Data: " + rawReceivedDataPacket.auxValues[0] + ", " + rawReceivedDataPacket.auxValues[1] + ", " + rawReceivedDataPacket.auxValues[2]);
                    PACKET_readstate++;
                    localByteCounter = 0;
                    //isNewDataPacketAvailable = true;  //tell the rest of the code that the data packet is complete
                } else {
                    //prepare for next data channel
                    localByteCounter=0; //prepare for next usage of localByteCounter
                }
            }
            break;
        case 4:
            //look for end byte
            // println("case 4");
            if (actbyte == PApplet.parseByte(0xC0) || actbyte == PApplet.parseByte(0xC1)) {    // if correct end delimiter found:
                // println("... 0xCx found");
                // println("InterfaceSerial: interpretBinaryStream: found end byte. Setting isNewDataPacketAvailable to TRUE");
                isNewDataPacketAvailable = true; //original place for this.  but why not put it in the previous case block
                flag_copyRawDataToFullData = true;  //time to copy the raw data packet into the full data packet (mainly relevant for 16-chan OpenBCI)
            } else {
                serialErrorCounter++;
                println("InterfaceSerial: interpretBinaryStream: Actbyte = " + actbyte);
                println("InterfaceSerial: interpretBinaryStream: expecteding end-of-packet byte is missing.  Discarding packet. (" + serialErrorCounter + ")");
            }
            PACKET_readstate=0;  // either way, look for next packet
            break;
        default:
            println("InterfaceSerial: interpretBinaryStream: Unknown byte: " + actbyte + " .  Continuing...");
            PACKET_readstate=0;  // look for next packet
        }

        if (flag_copyRawDataToFullData) {
            copyRawDataToFullData();
        }
    } // end of interpretBinaryStream



    //return the state
    public boolean isStateNormal() {
        if (state == STATE_NORMAL) {
            return true;
        } else {
            return false;
        }
    }

    private int interpret24bitAsInt32(byte[] byteArray) {
        //little endian
        int newInt = (
            ((0xFF & byteArray[0]) << 16) |
            ((0xFF & byteArray[1]) << 8) |
            (0xFF & byteArray[2])
            );
        if ((newInt & 0x00800000) > 0) {
            newInt |= 0xFF000000;
        } else {
            newInt &= 0x00FFFFFF;
        }
        return newInt;
    }

    private int interpret16bitAsInt32(byte[] byteArray) {
        int newInt = (
            ((0xFF & byteArray[0]) << 8) |
            (0xFF & byteArray[1])
            );
        if ((newInt & 0x00008000) > 0) {
            newInt |= 0xFFFF0000;
        } else {
            newInt &= 0x0000FFFF;
        }
        return newInt;
    }


    private int copyRawDataToFullData() {
        //Prior to the 16-chan OpenBCI, we did NOT have rawReceivedDataPacket along with dataPacket...we just had dataPacket.
        //With the 16-chan OpenBCI, where the first 8 channels are sent and then the second 8 channels are sent, we introduced
        //this extra structure so that we could alternate between them.
        //
        //This function here decides how to join the latest data (rawReceivedDataPacket) into the full dataPacket

        if (dataPacket.values.length < 2*rawReceivedDataPacket.values.length) {
            //this is an 8 channel board, so simply copy the data
            return rawReceivedDataPacket.copyTo(dataPacket);
        } else {
            //this is 16-channels, so copy the raw data into the correct channels of the new data
            int offsetInd_values = 0;  //this is correct assuming we just recevied a  "board" packet (ie, channels 1-8)
            int offsetInd_aux = 0;     //this is correct assuming we just recevied a  "board" packet (ie, channels 1-8)
            if (rawReceivedDataPacket.sampleIndex % 2 == 0) { // even data packets are from the daisy board
                offsetInd_values = rawReceivedDataPacket.values.length;  //start copying to the 8th slot
                //offsetInd_aux = rawReceivedDataPacket.auxValues.length;  //start copying to the 3rd slot
                offsetInd_aux = 0;
            }
            return rawReceivedDataPacket.copyTo(dataPacket, offsetInd_values, offsetInd_aux);
        }
    }

    public int copyDataPacketTo(DataPacket_ADS1299 target) {
        isNewDataPacketAvailable = false;
        return dataPacket.copyTo(target);
    }

};


///////////////////////////////////////////////////////////////////////////
//
//     Created: 2/19/16
//     by Conor Russomanno for BodyHacking Con DIY Cyborgia Presentation
//     This code is used to organize a neuro-powered presentation... refer to triggers in the EEG_Processing_User class of the EEG_Processing.pde file
//
///////////////////////////////////////////////////////////////////////////

//------------------------------------------------------------------------
//                       Global Variables & Instances
//------------------------------------------------------------------------

Presentation myPresentation;
boolean drawPresentation = false;

//------------------------------------------------------------------------
//                       Global Functions
//------------------------------------------------------------------------

//------------------------------------------------------------------------
//                       Classes
//------------------------------------------------------------------------

class Presentation {
    //presentation images
    int slideCount = 4;
    PImage presentationSlides[] = new PImage[slideCount];
    float timeOfLastSlideChange = 0;
    int currentSlide = 0;
    boolean lockSlides = false;

    Presentation (){
        //loading presentation images
        //println("attempting to load images for presentation...");
        presentationSlides[0] = loadImage("prez-images/Presentation.000.jpg");
        presentationSlides[1] = loadImage("prez-images/Presentation.001.jpg");
        presentationSlides[2] = loadImage("prez-images/Presentation.002.jpg");
        presentationSlides[3] = loadImage("prez-images/Presentation.003.jpg");
        // presentationSlides[4] = loadImage("prez-images/Presentation.004.jpg");
        // presentationSlides[5] = loadImage("prez-images/Presentation.005.jpg");
        // presentationSlides[6] = loadImage("prez-images/Presentation.006.jpg");
        // presentationSlides[7] = loadImage("prez-images/Presentation.007.jpg");
        // presentationSlides[8] = loadImage("prez-images/Presentation.008.jpg");
        // presentationSlides[9] = loadImage("prez-images/Presentation.009.jpg");
        // presentationSlides[10] = loadImage("prez-images/Presentation.010.jpg");
        // presentationSlides[11] = loadImage("prez-images/Presentation.011.jpg");
        // presentationSlides[12] = loadImage("prez-images/Presentation.012.jpg");
        // presentationSlides[13] = loadImage("prez-images/Presentation.013.jpg");
        // presentationSlides[14] = loadImage("prez-images/Presentation.014.jpg");
        // presentationSlides[15] = loadImage("prez-images/Presentation.015.jpg");
        // slideCount = 4;
        //println("DONE loading images!");
    }

    public void slideForward() {
        if(currentSlide < slideCount - 1 && drawPresentation && !lockSlides){
            println("Slide Forward!");
            currentSlide++;
        } else{
            println("No more slides. Can't go forward...");
        }
    }

    public void slideBack() {
        if(currentSlide > 0 && drawPresentation && !lockSlides){
            println("Slide Back!");
            currentSlide--;
        } else {
            println("On the first slide. Can't go back...");
        }
    }

    public void draw() {
            // ----- Drawing Presentation -------
        pushStyle();

        image(presentationSlides[currentSlide], 0, 0, width, height);


        if(lockSlides){
            //draw red rectangle to indicate that slides are locked
            pushStyle();
            fill(255,0,0);
            rect(width - 50, 25, 25, 25);
            popStyle();
        }

        textFont(p3, 16);
        fill(openbciBlue);
        textAlign(CENTER);
        text("Press [Enter] to exit presentation mode.", width/2, 31*(height/32));

        popStyle();
    }
}
/////////////////////////////////////////////////////////////////////////////////
//
//  Radios_Config will be used for radio configuration
//  integration. Also handles functions such as the "autconnect"
//  feature.
//
//  Created: Colin Fausnaught, July 2016
//
//  Handles interactions between the radio system and OpenBCI systems.
//  It is important to note that this is using Serial communication directly
//  rather than the Cyton class. I just found this easier to work
//  with.
//
//  Modified by Joel Murphy, January 2017
//
////////////////////////////////////////////////////////////////////////////////

String rcStringReceived = "";

public void autoconnect(){
    //Serial locBoard; //local serial instance just to make sure it's openbci, then connect to it if it is
    String[] serialPorts = new String[Serial.list().length];
    String serialPort  = "";
    serialPorts = Serial.list();


    for(int i = 0; i < serialPorts.length; i++){
        try{
            serialPort = serialPorts[i];
            board = new Serial(this,serialPort,115200);
            println("try " + i + " " + serialPort + " at 115200 baud");
            output("Attempting to connect at 115200 baud to " + serialPort);  // not working
            delay(5000);

            board.write('v'); //modified by JAM 1/17
            delay(2000);
            if(confirm_openbci()) {
                println("Board connected on port " +serialPorts[i] + " with BAUD 115200");
                output("Connected to " + serialPort + "!");
                openBCI_portName = serialPorts[i];
                openBCI_baud = 115200;
                board.stop();
                return;
            } else {
                println("Board not on port " + serialPorts[i] +" with BAUD 115200");
                board.stop();
            }
        }
        catch (Exception e){
            println("Exception " + serialPorts[i] + " " + e);
        }

        try{
            board = new Serial(this,serialPort,230400);
            println("try " + i + " " + serialPort + " at 230400 baud");
            output("Attempting to connect at 230400 baud to " + serialPort);  // not working
            delay(5000);

            board.write('v'); //modified by JAM 1/17
            delay(2000);
            if(confirm_openbci()) {  // was just confrim_openbci  JAM 1/2017
                println("Board connected on port " +serialPorts[i] + " with BAUD 230400");
                output("Connected to " + serialPort + "!"); // not working
                openBCI_baud = 230400;
                openBCI_portName = serialPorts[i];
                board.stop();
                return;
            } else {
                println("Board not on port " + serialPorts[i] +" with BAUD 230400");
                board.stop();
            }

        }
        catch (Exception e){
            println("Exception " + serialPorts[i] + " " + e);
        }
    }
}

/**** Helper function for connection of boards ****/
public boolean confirm_openbci(){
    //println(board_message.toString());
    // if(board_message.toString().toLowerCase().contains("registers")) return true;
    // print("board "); print(board_message.toString()); println("message");
    if(board_message != null){
        if(board_message.toString().toLowerCase().contains("ads")){
            return true;
        }
    }
    return false;
}

public boolean confirm_openbci_v2(){
    //println(board_message.toString());
    if(board_message.toString().toLowerCase().contains("success"))  return true;
    // if(board_message.toString().contains("v2."))  return true;
    else return false;
}
/**** Helper function for autoscan ****/
public boolean confirm_connected(){
    if( board_message != null && board_message.toString().toLowerCase().contains("success")) return true; // JAM added .containes("success")
    else return false;
}

/**** Helper function to read from the serial easily ****/
public boolean print_bytes(RadioConfigBox rc){
    if(board_message != null){
        println("Radios_Config: " + board_message.toString());
        rcStringReceived = board_message.toString();
        if(rcStringReceived.equals("Failure: System is Down")) {
            rcStringReceived = "Cyton dongle could not connect to the board. Perhaps they are on different channels? Try pressing AUTOSCAN.";
        }
        rc.print_onscreen(rcStringReceived);
        return true;
    } else {
        return false;
    }
}

public void print_bytes_error(RadioConfigBox rcConfig){
    println("Radios_Config: Error reading from Serial/COM port");
    rcConfig.print_onscreen("Error reading from Serial port.\n\nTry a different port?");
    board = null;
}

/**** Function to connect to a selected port ****/  // JAM 1/2017
//    Needs to be connected to something to perform the Radio_Config tasks
public boolean connect_to_portName(RadioConfigBox rcConfig){
    if(openBCI_portName != "N/A"){
        output("Attempting to open Serial/COM port: " + openBCI_portName);
        try {
            println("Radios_Config: connect_to_portName: Attempting to open serial port: " + openBCI_portName);
            serial_output = new Serial(this, openBCI_portName, openBCI_baud); //open the com port
            serial_output.clear(); // clear anything in the com port's buffer
            // portIsOpen = true;
            println("Radios_Config: connect_to_portName: Port is open!");
            // changeState(HubState.COMINIT);
            board = serial_output;
            return true;
        }
        catch (RuntimeException e){
            if (e.getMessage().contains("<init>")) {
                serial_output = null;
                println("Radios_Config: connect_to_portName: Port in use, trying again later...");
                // portIsOpen = false;
            } else {
                println("Error connecting to selected Serial/COM port. Make sure your board is powered up and your dongle is plugged in.");
                rcConfig.print_onscreen("Error connecting to Serial port.\n\nTry a different port?");
            }
            board = null;
            println("Failed to connect using " + openBCI_portName);
            return false;
        }
    } else {
        output("No Serial/COM port selected. Please select your Serial/COM port and retry");
        rcConfig.print_onscreen("Select a Serial/COM port, then try again.");
        return false;
    }
}



//=========== GET SYSTEM STATUS ============
//= Get's the current status of the system
//=
//= First writes 0xF0 to let the board know
//= a command is coming, then writes the
//= command (0x07).
//=
//= After a short delay it then prints bytes
//= from the board.
//==========================================

public void system_status(RadioConfigBox rcConfig){
    println("Radios_Config: system_status");

    if(board == null){
        if(!connect_to_portName(rcConfig)){
            return;
        }
    }
    if(board != null){
        board.write(0xF0);
        board.write(0x07);
        delay(100);
        if(!print_bytes(rcConfig)){
            print_bytes_error(rcConfig);
        } else {
            String[] s = split(rcStringReceived, ':');
            if (s[0].equals("Success")) {
                outputSuccess("Successfully connected to Cyton using " + openBCI_portName);
            } else {
                outputError("Failed to connect using " + openBCI_portName + ". Check hardware or try pressing 'Autoscan'.");
            }
        }
    } else {
        println("Error, no board connected");
        rcConfig.print_onscreen("No board connected!");
    }
}

//Scans through channels until a success message has been found
public void scan_channels(RadioConfigBox rcConfig){
    println("Radios_Config: scan_channels");
    if(board == null){
        if(!connect_to_portName(rcConfig)){
            return;
        }
    }
    for(int i = 1; i < 26; i++){

        set_channel_over(rcConfig,i);
        system_status(rcConfig);
        if(confirm_connected()) return; // break;
    }
}



//============== GET CHANNEL ===============
//= Gets channel information from the radio.
//=
//= First writes 0xF0 to let the board know
//= a command is coming, then writes the
//= command (0x00).
//=
//= After a short delay it then prints bytes
//= from the board.
//==========================================

public void get_channel(RadioConfigBox rcConfig){
    println("Radios_Config: get_channel");
    if(board == null){
        if(!connect_to_portName(rcConfig)){
            return;
        }
    }

    if(board != null){
        board.write(0xF0);
        board.write(0x00);
        delay(100);
        if(!print_bytes(rcConfig)){
            print_bytes_error(rcConfig);
        }
    }
    else {
        println("Error, no board connected");
        rcConfig.print_onscreen("No board connected!");
    }
    }

//============== SET CHANNEL ===============
//= Sets the radio and board channel.
//=
//= First writes 0xF0 to let the board know
//= a command is coming, then writes the
//= command (0x01) followed by the number to
//= set the board and radio to. Channels can
//= only be 1-25.
//=
//= After a short delay it then prints bytes
//= from the board.
//==========================================

public void set_channel(RadioConfigBox rcConfig, int channel_number){
    println("Radios_Config: set_channel");
    if(board == null){
        if(!connect_to_portName(rcConfig)){
            return;
        }
    }
    if(board != null){
        if(channel_number > 0){
            board.write(0xF0);
            board.write(0x01);
            board.write(PApplet.parseByte(channel_number));
            delay(1000);
            if(!print_bytes(rcConfig)){
                print_bytes_error(rcConfig);
            }
        }
        else rcConfig.print_onscreen("Please Select a Channel.");
    }
    else {
        println("Error, no board connected");
        rcConfig.print_onscreen("No board connected!");
    }
}

//========== SET CHANNEL OVERRIDE ===========
//= Sets the radio channel only
//=
//= First writes 0xF0 to let the board know
//= a command is coming, then writes the
//= command (0x02) followed by the number to
//= set the board and radio to. Channels can
//= only be 1-25.
//=
//= After a short delay it then prints bytes
//= from the board.
//==========================================

public void set_channel_over(RadioConfigBox rcConfig, int channel_number){
    println("Radios_Config: set_ovr_channel");
    if(board == null){
        if(!connect_to_portName(rcConfig)){
            return;
        }
    }
    if(board != null){
        if(channel_number > 0){
            board.write(0xF0);
            board.write(0x02);
            board.write(PApplet.parseByte(channel_number));
            delay(100);
            if(!print_bytes(rcConfig)){
                print_bytes_error(rcConfig);
            }
        }

        else rcConfig.print_onscreen("Please Select a Channel.");
    }

    else {
        println("Error, no board connected");
        rcConfig.print_onscreen("No board connected!");
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
//                       This sketch saves and loads the following User Settings:
//                       -- All Time Series widget settings in Live, Playback, and Synthetic modes
//                       -- All FFT widget settings
//                       -- Default Layout, Notch, Bandpass Filter, Framerate, Board Mode, and other Global Settings
//                       -- Networking Mode and All settings for active networking protocol
//                       -- Accelerometer, Analog Read, Head Plot, EMG, Focus, Band Power, and SSVEP
//                       -- Widget/Container Pairs
//                       -- OpenBCI Data Format Settings (.txt and .csv)
//                       Created: Richard Waltman - May/June 2018
//
//    -- Start System first!
//    -- Lowercase 'n' to Save
//    -- Capital 'N' to Load
//    -- Functions saveGUIsettings() and loadGUISettings() are called:
//        - during system initialization between checkpoints 4 and 5
//        - in Interactivty.pde with the rest of the keyboard shortcuts
//        - in TopNav.pde when "Config" --> "Save Settings" || "Load Settings" is clicked
//    -- This allows User to store snapshots of most GUI settings in Users/.../Documents/OpenBCI_GUI/Settings/
//    -- After loading, only a few actions are required: start/stop the data stream and networking streams, open/close serial port,  turn on/off Analog Read
//
//      Tips on adding a new setting:
//      -- figure out if the setting is Global, in an existing widget, or in a new class or widget
//      -- read the comments
//      -- once you find the right place to add your setting, you can copy the surrounding style
//      -- uses JSON keys
//      -- Example: Expert Mode is a global boolean, so we include it under kJSONKeySettings
//      -- We use one variable to load from JSON: loadExpertModeToggle
//      -- And another variable to use in the GUI and with saving to JSON: expertModeToggle
//      -- Example2: GUI version and settings version
//      -- Requires new JSON key 'version` and settingsVersion
//
*/
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////
//   SoftwareSettings Class    //
/////////////////////////////////
class SoftwareSettings {
    //Current version to save to JSON
    String settingsVersion = "1.0.5";
    //impose minimum gui width and height in openBCI_GUI.pde
    int minGUIWidth = 705;
    int minGUIHeight = 400;
    //for screen resizing
    boolean screenHasBeenResized = false;
    float timeOfLastScreenResize = 0;
    float timeOfGUIreinitialize = 0;
    int reinitializeGUIdelay = 125;
    int widthOfLastScreen = 0;
    int heightOfLastScreen = 0;
    //default layout variables
    int currentLayout;
    //Used to time the GUI intro animation
    int introAnimationInit = 0;
    final int introAnimationDuration = 2500;
    //Max File Size #461, default option 4 -> 60 minutes
    public final String[] fileDurations = {"5 Minutes", "15 minutes", "30 Minutes", "60 Minutes", "120 Minutes", "No Limit"};
    public final int[] fileDurationInts = {5, 15, 30, 60, 120, -1};
    public final int defaultOBCIMaxFileSize = 3; //4th option from the above list
    public int cytonOBCIMaxFileSize = defaultOBCIMaxFileSize;
    public int ganglionOBCIMaxFileSize = defaultOBCIMaxFileSize;
    private boolean logFileIsOpen = false;
    private long logFileStartTime;
    private long logFileMaxDuration;
    //this is a global CColor that determines the style of all widget dropdowns ... this should go in WidgetManager.pde
    CColor dropdownColors = new CColor();
    ///These `Save` vars are set to default when each widget instantiates
    ///and updated every time user selects from dropdown
    //Notch and Bandpass filter variables for save
    int dataProcessingNotchSave = 0;
    int dataProcessingBandpassSave = 3;
    //Time Series settings
    int tsVertScaleSave;
    int tsHorizScaleSave;
    int checkForSuccessTS = 0;
    //Accelerometer settings
    int accVertScaleSave;
    int accHorizScaleSave;
    //FFT plot settings,
    int fftMaxFrqSave;
    int fftMaxuVSave;
    int fftLogLinSave;
    int fftSmoothingSave;
    int fftFilterSave;
    //Analog Read settings
    int arVertScaleSave; //updates in VertScale_AR()
    int arHorizScaleSave; //updates in Duration_AR()
    //Headplot settings
    int hpIntensitySave;
    int hpPolaritySave;
    int hpContoursSave;
    int hpSmoothingSave;
    //EMG settings
    int emgSmoothingSave;
    int emguVLimSave;
    int emgCreepSave;
    int emgMinDeltauVSave;
    //Focus widget settings
    int focusThemeSave;
    int focusKeySave;
    //default data types for streams 1-4 in Networking widget
    int nwDataType1;
    int nwDataType2;
    int nwDataType3;
    int nwDataType4;
    String nwSerialPort;
    int nwProtocolSave;
    //SSVEP Widget settings
    int[] freqsSave;
    boolean[] channelActivitySave;
    int numSSVEPs;
    //Used to check if a playback file has data
    int minNumRowsPlaybackFile = PApplet.parseInt(getSampleRateSafe());

    //default configuration settings file location and file name variables
    public final String guiDataPath = System.getProperty("user.home")+File.separator+"Documents"+File.separator+"OpenBCI_GUI"+File.separator;
    public final String recordingsPath = guiDataPath+"Recordings"+File.separator;
    public final String settingsPath = guiDataPath+"Settings"+File.separator;
    public final String consoleDataPath = guiDataPath+"Console_Data"+File.separator;
    private String sessionPath = "";
    final String[] userSettingsFiles = {
        "CytonUserSettings.json",
        "DaisyUserSettings.json",
        "GanglionUserSettings.json",
        "PlaybackUserSettings.json",
        "SynthFourUserSettings.json",
        "SynthEightUserSettings.json",
        "SynthSixteenUserSettings.json"
        };
    final String[] defaultSettingsFiles = {
        "CytonDefaultSettings.json",
        "DaisyDefaultSettings.json",
        "GanglionDefaultSettings.json",
        "PlaybackDefaultSettings.json",
        "SynthFourDefaultSettings.json",
        "SynthEightDefaultSettings.json",
        "SynthSixteenDefaultSettings.json"
        };

    //Used to set text for Notch and BP filter settings
    String [] dataProcessingNotchArray = {"60Hz", "50Hz", "None"};
    String [] dataProcessingBPArray = {"1-50 Hz", "7-13 Hz", "15-50 Hz", "5-50 Hz", "No Filter"};

    // Used to set text in Time Series dropdown settings
    String[] tsVertScaleArray = {"Auto", "50 uV", "100 uV", "200 uV", "400 uV", "1000 uV", "10000 uV"};
    String[] tsHorizScaleArray = {"1 sec", "3 sec", "5 sec", "10 sec", "20 sec"};

    //Used to print the status of each channel in the console when loading settings
    String[] channelsActiveArray = {"Active", "Not Active"};
    String[] gainSettingsArray = { "x1", "x2", "x4", "x6", "x8", "x12", "x24"};
    String[] inputTypeArray = { "Normal", "Shorted", "BIAS_MEAS", "MVDD", "Temp.", "Test", "BIAS_DRP", "BIAS_DRN"};
    String[] biasIncludeArray = {"Don't Include", "Include"};
    String[] srb2SettingArray = {"Off", "On"};
    String[] srb1SettingArray = {"Off", "On"};

    //Used to set text in dropdown menus when loading FFT settings
    String[] fftMaxFrqArray = {"20 Hz", "40 Hz", "60 Hz", "100 Hz", "120 Hz", "250 Hz", "500 Hz", "800 Hz"};
    String[] fftVertScaleArray = {"10 uV", "50 uV", "100 uV", "1000 uV"};
    String[] fftLogLinArray = {"Log", "Linear"};
    String[] fftSmoothingArray = {"0.0", "0.5", "0.75", "0.9", "0.95", "0.98"};
    String[] fftFilterArray = {"Filtered", "Unfilt."};

    //Used to set text in dropdown menus when loading Accelerometer settings
    String[] accVertScaleArray = {"Auto","1 g", "2 g", "4 g"};
    String[] accHorizScaleArray = {"Sync", "1 sec", "3 sec", "5 sec", "10 sec", "20 sec"};

    //Used to set text in dropdown menus when loading Networking settings
    String[] nwProtocolArray = {"Serial", "LSL", "UDP", "OSC"};
    String[] nwDataTypesArray = {"None", "TimeSeries", "FFT", "EMG", "BandPower", "Accel/Aux", "Focus", "Pulse", "SSVEP"};
    String[] nwBaudRatesArray = {"57600", "115200", "250000", "500000"};

    //Used to set text in dropdown menus when loading Analog Read settings
    String[] arVertScaleArray = {"Auto", "50", "100", "200", "400", "1000", "10000"};
    String[] arHorizScaleArray = {"Sync", "1 sec", "3 sec", "5 sec", "10 sec", "20 sec"};

    //Used to set text in dropdown menus when loading Head Plot settings
    String[] hpIntensityArray = {"4x", "2x", "1x", "0.5x", "0.2x", "0.02x"};
    String[] hpPolarityArray = {"+/-", " + "};
    String[] hpContoursArray = {"ON", "OFF"};
    String[] hpSmoothingArray = {"0.0", "0.5", "0.75", "0.9", "0.95", "0.98"};

    //Used to set text in dropdown menus when loading EMG settings
    String[] emgSmoothingArray = {"0.01 s", "0.1 s", "0.15 s", "0.25 s", "0.5 s", "0.75 s", "1.0 s", "2.0 s"};
    String[] emguVLimArray = {"50 uV", "100 uV", "200 uV", "400 uV"};
    String[] emgCreepArray = {"0.9", "0.95", "0.98", "0.99", "0.999"};
    String[] emgMinDeltauVArray = {"10 uV", "20 uV", "40 uV", "80 uV"};

    //Used to set text in dropdown menus when loading Focus Setings
    String[] focusThemeArray = {"Green", "Orange", "Cyan"};
    String[] focusKeyArray = {"OFF", "UP", "SPACE"};

    //Save Time Series settings variables
    int tsActiveSetting = 1;
    int tsGainSetting;
    int tsInputTypeSetting;
    int tsBiasSetting;
    int tsSrb2Setting;
    int tsSrb1Setting;

    //Load global settings variables
    int loadLayoutSetting;
    int loadNotchSetting;
    int loadBandpassSetting;
    BoardMode loadBoardMode;

    //Load TS dropdown variables
    int loadTimeSeriesVertScale;
    int loadTimeSeriesHorizScale;

    //Load Accel. dropdown variables
    int loadAccelVertScale;
    int loadAccelHorizScale;

    //Load Analog Read dropdown variables
    int loadAnalogReadVertScale;
    int loadAnalogReadHorizScale;

    //Load FFT dropdown variables
    int fftMaxFrqLoad;
    int fftMaxuVLoad;
    int fftLogLinLoad;
    int fftSmoothingLoad;
    int fftFilterLoad;

    //Load Headplot dropdown variables
    int hpIntensityLoad;
    int hpPolarityLoad;
    int hpContoursLoad;
    int hpSmoothingLoad;

    //EMG settings
    int emgSmoothingLoad;
    int emguVLimLoad;
    int emgCreepLoad;
    int emgMinDeltauVLoad;

    //Focus widget settings
    int focusThemeLoad;
    int focusKeyLoad;

    //SSVEP widget settings
    int numSSVEPsLoad;
    int[] ssvepFreqsLoad = new int[4];
    List<Integer> loadSSVEPActiveChans = new ArrayList<Integer>();

    //Band Power widget settings
    //smoothing and filter dropdowns are linked to FFT, so no need to save again
    List<Integer> loadBPActiveChans = new ArrayList<Integer>();

    //Networking Settings save/load variables
    int nwProtocolLoad;
    //OSC load variables
    String nwOscIp1Load;  String nwOscIp2Load;  String nwOscIp3Load;  String nwOscIp4Load;
    String nwOscPort1Load;  String nwOscPort2Load;  String nwOscPort3Load;  String nwOscPort4Load;
    String nwOscAddress1Load;  String nwOscAddress2Load; String nwOscAddress3Load; String nwOscAddress4Load;
    int nwOscFilter1Load;  int nwOscFilter2Load;  int nwOscFilter3Load;  int nwOscFilter4Load;
    //UDP load variables
    String nwUdpIp1Load;  String nwUdpIp2Load;  String nwUdpIp3Load;
    String nwUdpPort1Load;  String nwUdpPort2Load;  String nwUdpPort3Load;
    int nwUdpFilter1Load;  int nwUdpFilter2Load;  int nwUdpFilter3Load;
    //LSL load variables
    String nwLSLName1Load;  String nwLSLName2Load;  String nwLSLName3Load;
    String nwLSLType1Load;  String nwLSLType2Load;  String nwLSLType3Load;
    String nwLSLNumChan1Load;  String nwLSLNumChan2Load; String nwLSLNumChan3Load;
    int nwLSLFilter1Load;  int nwLSLFilter2Load;  int nwLSLFilter3Load;
    //Serial load variables
    int nwSerialBaudRateLoad;
    int nwSerialFilter1Load;

    private JSONObject saveSettingsJSONData;
    private JSONObject loadSettingsJSONData;

    private final String kJSONKeyDataInfo = "dataInfo";
    private final String kJSONKeyTimeSeries = "timeSeries";
    private final String kJSONKeySettings = "settings";
    private final String kJSONKeyFFT = "fft";
    private final String kJSONKeyAccel = "accelerometer";
    private final String kJSONKeyNetworking = "networking";
    private final String kJSONKeyHeadplot = "headplot";
    private final String kJSONKeyEMG = "emg";
    private final String kJSONKeyFocus = "focus";
    private final String kJSONKeyBandPower = "bandPower";
    private final String kJSONKeySSVEP = "ssvep";
    private final String kJSONKeyWidget = "widget";
    private final String kJSONKeyVersion = "version";

    //used only in this tab to count the number of channels being used while saving/loading, this gets updated in updateToNChan whenever the number of channels being used changes
    int slnchan;
    int numChanloaded;
    boolean chanNumError = false;
    int numLoadedWidgets;
    String [] loadedWidgetsArray;
    int loadFramerate;
    int loadDatasource;
    boolean dataSourceError = false;
    //used globally to track and determine if expertMode is on or off
    boolean expertModeToggle = false;

    String saveDialogName; //Used when Save button is pressed
    String loadDialogName; //Used when Load button is pressed
    String controlEventDataSource; //Used for output message on system start
    Boolean errorUserSettingsNotFound = false; //For error catching
    int loadErrorTimerStart;
    int loadErrorTimeWindow = 5000; //Time window in milliseconds to apply channel settings to Cyton board. This is to avoid a GUI crash at ~ 4500-5000 milliseconds.
    Boolean loadErrorCytonEvent = false;
    Boolean settingsLoaded = false; //Used to determine if settings are done loading successfully after init
    final int initTimeoutThreshold = 12000; //Timeout threshold in milliseconds

    SoftwareSettings() {
        //Instantiated on app start in OpenBCI_GUI.pde
        dropdownColors.setActive((int)color(150, 170, 200)); //bg color of box when pressed
        dropdownColors.setForeground((int)color(177, 184, 193)); //when hovering over any box (primary or dropdown)
        dropdownColors.setBackground((int)color(255)); //bg color of boxes (including primary)
        dropdownColors.setCaptionLabel((int)color(1, 18, 41)); //color of text in primary box
        // dropdownColors.setValueLabel((int)color(1, 18, 41)); //color of text in all dropdown boxes
        dropdownColors.setValueLabel((int)color(100)); //color of text in all dropdown boxes
    }

    ///////////////////////////////////
    // OpenBCI Data Format Functions //
    ///////////////////////////////////

    public void setLogFileIsOpen (boolean _toggle) {
        logFileIsOpen = _toggle;
    }

    public boolean isLogFileOpen() {
        return logFileIsOpen;
    }

    public void setLogFileStartTime(long _time) {
        logFileStartTime = _time;
        verbosePrint("Settings: LogFileStartTime = " + _time);
    }

    public void setLogFileMaxDuration() {
        int _maxFileSize = (eegDataSource == DATASOURCE_CYTON) ? cytonOBCIMaxFileSize : ganglionOBCIMaxFileSize;
        logFileMaxDuration = fileDurationInts[_maxFileSize] * 1000000000L * 60;
        println("Settings: LogFileMaxDuration = " + fileDurationInts[_maxFileSize] + " minutes");
    }

    //Only called during live mode && using OpenBCI Data Format
    public boolean maxLogTimeReached() {
        if (logFileMaxDuration < 0) {
            return false;
        } else {
            return (System.nanoTime() - logFileStartTime) > (logFileMaxDuration);
        }
    }

    //Called in OpenBCI_GUI.pde to gate the above function
    public boolean limitOBCILogFileDuration() {
        if (logFileMaxDuration > 0) {
            return true;
        } else {
            //If the value is less than zero, don't call maxLogTimeReached()
            return false;
        }
    }

    public void setSessionPath (String _path) {
        sessionPath = _path;
    }

    public String getSessionPath() {
        return sessionPath;
    }

    ////////////////////////////////////////////////////////////////
    //               Init GUI Software Settings                   //
    //                                                            //
    //  - Called during system initialization in OpenBCI_GUI.pde  //
    ////////////////////////////////////////////////////////////////
    public void init() {
        String defaultSettingsFileToSave = getPath("Default", eegDataSource, nchan);
        int defaultNumChanLoaded = 0;
        int defaultLoadedDataSource = 0;
        String defaultSettingsVersion = "";
        String defaultGUIVersion = "";

        //Take a snapshot of the default GUI settings on every system init
        println("InitSettings: Saving Default Settings to file!");
        try {
            this.save(defaultSettingsFileToSave); //to avoid confusion with save() image
        } catch (Exception e) {
            println("InitSettings: Error trying to save settings");
        }

        //Try Auto-load GUI settings between checkpoints 4 and 5 during system init.
        //Otherwise, load default settings.
        String settingsFileToLoad = getPath("User", eegDataSource, nchan);
        try {
            this.load(settingsFileToLoad);
            errorUserSettingsNotFound = false;
        } catch (Exception e) {
            //e.printStackTrace();
            println("InitSettings: " + settingsFileToLoad + " not found or other error.");
            errorUserSettingsNotFound = true;
            File f = new File(settingsFileToLoad);
            //Only delete the settings file for other errors
            //Leave file if it's just a channelNumber error or DataSource mismatch
            if (!chanNumError && !dataSourceError) {
                if (f.exists()) {
                    if (f.delete()) println("SoftwareSettings: Removed old/broken settings file.");
                }
            }
        }
    }

    ///////////////////////////////
    //      Save GUI Settings    //
    ///////////////////////////////
    public void save(String saveGUISettingsFileLocation) {

        //Set up a JSON array
        saveSettingsJSONData = new JSONObject();

        //Save the number of channels being used and eegDataSource in the first object
        JSONObject saveNumChannelsData = new JSONObject();
        saveNumChannelsData.setInt("Channels", slnchan);
        saveNumChannelsData.setInt("Data Source", eegDataSource);
        //println("Settings: NumChan: " + slnchan);
        saveSettingsJSONData.setJSONObject(kJSONKeyDataInfo, saveNumChannelsData);

        //Make a new JSON Object for Time Series Settings
        JSONObject saveTSSettings = new JSONObject();
        saveTSSettings.setInt("Time Series Vert Scale", tsVertScaleSave);
        saveTSSettings.setInt("Time Series Horiz Scale", tsHorizScaleSave);
        ////////////////////////////////////////////////////////////////////////////////////
        //                 Case for saving TS settings in Cyton Data Modes                //
        if (eegDataSource == DATASOURCE_CYTON)  {
            //Set up an array to store channel settings
            JSONArray saveTSSettingsJSONArray = new JSONArray();
            //Save all of the channel settings for number of Time Series channels being used
            for (int i = 0; i < slnchan; i++) {
                //Make a JSON Object for each of the Time Series Channels
                JSONObject saveChannelSettings = new JSONObject();
                //Copy channel settings from channelSettingValues
                for (int j = 0; j < numSettingsPerChannel; j++) {
                    switch(j) {  //what setting are we looking at
                        case 0: //on/off
                            tsActiveSetting = Character.getNumericValue(channelSettingValues[i][j]);  //Store integer value for active channel (0 or 1) from char array channelSettingValues
                            break;
                        case 1: //GAIN
                            tsGainSetting = Character.getNumericValue(channelSettingValues[i][j]);  //Store integer value for gain
                            break;
                        case 2: //input type
                            tsInputTypeSetting = Character.getNumericValue(channelSettingValues[i][j]);  //Store integer value for input type
                            break;
                        case 3: //BIAS
                            tsBiasSetting = Character.getNumericValue(channelSettingValues[i][j]);  //Store integer value for bias
                            break;
                        case 4: // SRB2
                            tsSrb2Setting = Character.getNumericValue(channelSettingValues[i][j]);  //Store integer value for srb2
                            break;
                        case 5: // SRB1
                            tsSrb1Setting = Character.getNumericValue(channelSettingValues[i][j]); //Store integer value for srb1
                            break;
                        }
                    //Store all channel settings in Time Series JSON object, one channel at a time
                    saveChannelSettings.setInt("Channel_Number", (i+1));
                    saveChannelSettings.setInt("Active", tsActiveSetting);
                    saveChannelSettings.setInt("PGA Gain", PApplet.parseInt(tsGainSetting));
                    saveChannelSettings.setInt("Input Type", tsInputTypeSetting);
                    saveChannelSettings.setInt("Bias", tsBiasSetting);
                    saveChannelSettings.setInt("SRB2", tsSrb2Setting);
                    saveChannelSettings.setInt("SRB1", tsSrb1Setting);
                    saveTSSettingsJSONArray.setJSONObject(i, saveChannelSettings);
                } //end channel settings for loop
            } //end all channels for loop
            saveTSSettings.setJSONArray("channelSettings", saveTSSettingsJSONArray); //Set the JSON array for all channels
        }
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //              Case for saving TS settings when in Ganglion, Synthetic, and Playback data modes                       //
        if (eegDataSource == DATASOURCE_PLAYBACKFILE || eegDataSource == DATASOURCE_SYNTHETIC || eegDataSource == DATASOURCE_GANGLION) {
            //Set up an array to store channel settings
            JSONArray saveTSSettingsJSONArray = new JSONArray();
            for (int i = 0; i < slnchan; i++) { //For all channels...
                //Make a JSON Object for each of the Time Series Channels
                JSONObject saveTimeSeriesSettings = new JSONObject();
                //Get integer value from char array channelSettingValues
                tsActiveSetting = Character.getNumericValue(channelSettingValues[i][0]);
                //Catch case where channel settings is not 0 or 1, due to unkown error
                tsActiveSetting = (tsActiveSetting == 0 ||  tsActiveSetting == 1) ?
                    tsActiveSetting ^= 1 :
                    1; //save channel setting as active if there is an error
                saveTimeSeriesSettings.setInt("Channel_Number", (i+1));
                saveTimeSeriesSettings.setInt("Active", tsActiveSetting);
                saveTSSettingsJSONArray.setJSONObject(i, saveTimeSeriesSettings);
            } //end loop for all channels
            saveTSSettings.setJSONArray("channelSettings", saveTSSettingsJSONArray); //Set the JSON array for all channels
        }
        saveSettingsJSONData.setJSONObject(kJSONKeyTimeSeries, saveTSSettings);
        //Make a second JSON object within our JSONArray to store Global settings for the GUI
        JSONObject saveGlobalSettings = new JSONObject();
        saveGlobalSettings.setBoolean("Expert Mode", expertModeToggle);
        saveGlobalSettings.setInt("Current Layout", currentLayout);
        saveGlobalSettings.setInt("Notch", dataProcessingNotchSave);
        saveGlobalSettings.setInt("Bandpass Filter", dataProcessingBandpassSave);
        saveGlobalSettings.setInt("Framerate", frameRateCounter);
        saveGlobalSettings.setBoolean("Accelerometer Mode", w_accelerometer.isAccelModeActive());
        if (eegDataSource == DATASOURCE_CYTON) { //Only save these settings if you are using a Cyton board for live streaming
            saveGlobalSettings.setInt("Analog Read Vert Scale", arVertScaleSave);
            saveGlobalSettings.setInt("Analog Read Horiz Scale", arHorizScaleSave);
            saveGlobalSettings.setBoolean("Pulse Analog Read", w_pulsesensor.analogReadOn);
            saveGlobalSettings.setBoolean("Analog Read", w_analogRead.analogReadOn);
            saveGlobalSettings.setBoolean("Digital Read", w_digitalRead.digitalReadOn);
            saveGlobalSettings.setBoolean("Marker Mode", w_markermode.markerModeOn);
            saveGlobalSettings.setInt("Board Mode", cyton.curBoardMode.ordinal());
        }
        saveSettingsJSONData.setJSONObject(kJSONKeySettings, saveGlobalSettings);

        /////Setup JSON Object for gui version and settings Version
        JSONObject saveVersionInfo = new JSONObject();
        saveVersionInfo.setString("gui", localGUIVersionString);
        saveVersionInfo.setString("settings", settingsVersion);
        saveSettingsJSONData.setJSONObject(kJSONKeyVersion, saveVersionInfo);

        ///////////////////////////////////////////////Setup new JSON object to save FFT settings
        JSONObject saveFFTSettings = new JSONObject();

        //Save FFT_Max Freq Setting. The max frq variable is updated every time the user selects a dropdown in the FFT widget
        saveFFTSettings.setInt("FFT_Max Freq", fftMaxFrqSave);
        //Save FFT_Max uV Setting. The max uV variable is updated also when user selects dropdown in the FFT widget
        saveFFTSettings.setInt("FFT_Max uV", fftMaxuVSave);
        //Save FFT_LogLin Setting. Same thing happens for LogLin
        saveFFTSettings.setInt("FFT_LogLin", fftLogLinSave);
        //Save FFT_Smoothing Setting
        saveFFTSettings.setInt("FFT_Smoothing", fftSmoothingSave);
        //Save FFT_Filter Setting
        if (isFFTFiltered == true)  fftFilterSave = 0;
        if (isFFTFiltered == false)  fftFilterSave = 1;
        saveFFTSettings.setInt("FFT_Filter",  fftFilterSave);
        //Set the FFT JSON Object
        saveSettingsJSONData.setJSONObject(kJSONKeyFFT, saveFFTSettings); //next object will be set to slnchan+3, etc.

        ///////////////////////////////////////////////Setup new JSON object to save Accelerometer settings
        JSONObject saveAccSettings = new JSONObject();
        saveAccSettings.setInt("Accelerometer Vert Scale", accVertScaleSave);
        saveAccSettings.setInt("Accelerometer Horiz Scale", accHorizScaleSave);
        saveSettingsJSONData.setJSONObject(kJSONKeyAccel, saveAccSettings);

        ///////////////////////////////////////////////Setup new JSON object to save Networking settings
        JSONObject saveNetworkingSettings = new JSONObject();
        //Save Protocol
        saveNetworkingSettings.setInt("Protocol", nwProtocolSave);//***Save User networking protocol mode
        switch(nwProtocolSave) {
            case 3:
                for (int i = 1; i <= 4; i++) {
                    saveNetworkingSettings.setInt("OSC_DataType"+i, (Integer) w_networking.getCP5Map().get(w_networking.datatypeNames[i-1]));
                    saveNetworkingSettings.setString("OSC_ip"+i, (String) w_networking.getCP5Map().get("OSC_ip"+i));
                    saveNetworkingSettings.setString("OSC_port"+i, (String) w_networking.getCP5Map().get("OSC_port"+i));
                    saveNetworkingSettings.setString("OSC_address"+i, (String) w_networking.getCP5Map().get("OSC_address"+i));
                    saveNetworkingSettings.setInt("OSC_filter"+i, (Integer) w_networking.getCP5Map().get("filter"+i));
                }
                break;
            case 2:
                for (int i = 1; i <= 3; i++) {
                    saveNetworkingSettings.setInt("UDP_DataType"+i, (Integer) w_networking.getCP5Map().get(w_networking.datatypeNames[i-1]));
                    saveNetworkingSettings.setString("UDP_ip"+i, (String) w_networking.getCP5Map().get("UDP_ip"+i));
                    saveNetworkingSettings.setString("UDP_port"+i, (String) w_networking.getCP5Map().get("UDP_port"+i));
                    saveNetworkingSettings.setInt("UDP_filter"+i, (Integer) w_networking.getCP5Map().get("filter"+i));
                }
                break;
            case 1:
                for (int i = 1; i <= 3; i++) {
                    saveNetworkingSettings.setInt("LSL_DataType"+i, (Integer) w_networking.getCP5Map().get(w_networking.datatypeNames[i-1]));
                    saveNetworkingSettings.setString("LSL_name"+i, (String) w_networking.getCP5Map().get("LSL_name"+i));
                    saveNetworkingSettings.setString("LSL_type"+i, (String) w_networking.getCP5Map().get("LSL_type"+i));
                    saveNetworkingSettings.setString("LSL_numchan"+i, (String) w_networking.getCP5Map().get("LSL_numchan"+i));
                    saveNetworkingSettings.setInt("LSL_filter"+i, (Integer) w_networking.getCP5Map().get("filter"+i));
                }
                break;
            case 0:
                saveNetworkingSettings.setInt("Serial_DataType1", (Integer) w_networking.getCP5Map().get("dataType1"));
                saveNetworkingSettings.setInt("Serial_baudrate", (Integer) w_networking.getCP5Map().get("baud_rate"));
                saveNetworkingSettings.setInt("Serial_filter1", (Integer) w_networking.getCP5Map().get("filter1"));
                saveNetworkingSettings.setString("Serial_portName", (String) w_networking.getCP5Map().get("port_name"));
                break;
        }//end of networking proctocol switch
        //Set Networking Settings JSON Object
        saveSettingsJSONData.setJSONObject(kJSONKeyNetworking, saveNetworkingSettings);

        ///////////////////////////////////////////////Setup new JSON object to save Headplot settings
        JSONObject saveHeadplotSettings = new JSONObject();

        //Save Headplot Intesity
        saveHeadplotSettings.setInt("HP_intensity", hpIntensitySave);
        //Save Headplot Polarity
        saveHeadplotSettings.setInt("HP_polarity", hpPolaritySave);
        //Save Headplot contours
        saveHeadplotSettings.setInt("HP_contours", hpContoursSave);
        //Save Headplot Smoothing Setting
        saveHeadplotSettings.setInt("HP_smoothing", hpSmoothingSave);
        //Set the Headplot JSON Object
        saveSettingsJSONData.setJSONObject(kJSONKeyHeadplot, saveHeadplotSettings);

        ///////////////////////////////////////////////Setup new JSON object to save Headplot settings
        JSONObject saveEMGSettings = new JSONObject();

        //Save EMG Smoothing
        saveEMGSettings.setInt("EMG_smoothing", emgSmoothingSave);
        //Save EMG uV limit
        saveEMGSettings.setInt("EMG_uVlimit", emguVLimSave);
        //Save EMG creep speed
        saveEMGSettings.setInt("EMG_creepspeed", emgCreepSave);
        //Save EMG min delta uV
        saveEMGSettings.setInt("EMG_minuV", emgMinDeltauVSave);
        //Set the EMG JSON Object
        saveSettingsJSONData.setJSONObject(kJSONKeyEMG, saveEMGSettings);

        ///////////////////////////////////////////////Setup new JSON object to save Headplot settings
        JSONObject saveFocusSettings = new JSONObject();

        //Save Focus theme
        saveFocusSettings.setInt("Focus_theme", focusThemeSave);
        //Save Focus keypress
        saveFocusSettings.setInt("Focus_keypress", focusKeySave);
        //Set the Focus JSON Object
        saveSettingsJSONData.setJSONObject(kJSONKeyFocus, saveFocusSettings);

        ///////////////////////////////////////////////Setup new JSON object to save SSVEP settings
        JSONObject saveSSVEPSettings = new JSONObject();

        int num_ssveps = numSSVEPs + 1; //add 1 here, dropdown items start count from 0
        saveSSVEPSettings.setInt("NumSSVEPs", num_ssveps);
        //Save data from the Active channel checkBoxes
        JSONArray saveActiveChanSSVEP = new JSONArray();
        int numActiveSSVEPChan = w_ssvep.numActiveChannels;
        for (int i = 0; i < numActiveSSVEPChan; i++) {
            int activeChan = w_ssvep.ssvepChanSelect.activeChan.get(i) + 1; //add 1 here so channel numbers are correct
            saveActiveChanSSVEP.setInt(i, activeChan);
        }
        saveSSVEPSettings.setJSONArray("activeChannels", saveActiveChanSSVEP);
        //Save data from the 1 to 4 ssvep frequency dropdowns inside the widget
        JSONObject ssvepFrequencies = new JSONObject();
        for (int i = 0; i < num_ssveps; i++) {
            ssvepFrequencies.setInt("SSVEP_"+i, w_ssvep.freqs[i]);
        }
        saveSSVEPSettings.setJSONObject("SSVEP_frequencies", ssvepFrequencies);
        saveSettingsJSONData.setJSONObject(kJSONKeySSVEP, saveSSVEPSettings);

        ///////////////////////////////////////////////Setup new JSON object to save Band Power settings
        JSONObject saveBPSettings = new JSONObject();

        //Save data from the Active channel checkBoxes
        JSONArray saveActiveChanBP = new JSONArray();
        int numActiveBPChan = w_bandPower.bpChanSelect.activeChan.size();
        for (int i = 0; i < numActiveBPChan; i++) {
            int activeChan = w_bandPower.bpChanSelect.activeChan.get(i) + 1; //add 1 here so channel numbers are correct
            saveActiveChanBP.setInt(i, activeChan);
        }
        saveBPSettings.setJSONArray("activeChannels", saveActiveChanBP);
        saveSettingsJSONData.setJSONObject(kJSONKeyBandPower, saveBPSettings);

        ///////////////////////////////////////////////Setup new JSON object to save Widgets Active in respective Containers
        JSONObject saveWidgetSettings = new JSONObject();

        int numActiveWidgets = 0;
        //Save what Widgets are active and respective Container number (see Containers.pde)
        for (int i = 0; i < wm.widgets.size(); i++) { //increment through all widgets
            if (wm.widgets.get(i).isActive) { //If a widget is active...
                numActiveWidgets++; //increment numActiveWidgets
                //println("Widget" + i + " is active");
                // activeWidgets.add(i); //keep track of the active widget
                int containerCountsave = wm.widgets.get(i).currentContainer;
                //println("Widget " + i + " is in Container " + containerCountsave);
                saveWidgetSettings.setInt("Widget_"+i, containerCountsave);
            } else if (!wm.widgets.get(i).isActive) { //If a widget is not active...
                saveWidgetSettings.remove("Widget_"+i); //remove non-active widget from JSON
                //println("widget"+i+" is not active");
            }
        }
        println("SoftwareSettings: " + numActiveWidgets + " active widgets saved!");
        //Print what widgets are in the containers used by current layout for only the number of active widgets
        //for (int i = 0; i < numActiveWidgets; i++) {
            //int containerCounter = wm.layouts.get(currentLayout-1).containerInts[i];
            //println("Container " + containerCounter + " is available"); //For debugging
        //}
        saveSettingsJSONData.setJSONObject(kJSONKeyWidget, saveWidgetSettings);

        /////////////////////////////////////////////////////////////////////////////////
        ///ADD more global settings above this line in the same formats as above/////////

        //Let's save the JSON array to a file!
        saveJSONObject(saveSettingsJSONData, saveGUISettingsFileLocation);

    }  //End of Save GUI Settings function

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                                                Load GUI Settings                                                       //
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public void load(String loadGUISettingsFileLocation) throws Exception {
        //Load all saved User Settings from a JSON file if it exists
        loadSettingsJSONData = loadJSONObject(loadGUISettingsFileLocation);

        //Check the number of channels saved to json first!
        JSONObject loadDataSettings = loadSettingsJSONData.getJSONObject(kJSONKeyDataInfo);
        numChanloaded = loadDataSettings.getInt("Channels");
        //Print error if trying to load a different number of channels
        if (numChanloaded != slnchan) {
            println("Channels being loaded from " + loadGUISettingsFileLocation + " don't match channels being used!");
            chanNumError = true;
            throw new Exception();
        } else {
            chanNumError = false;
        }
        //Check the Data Source integer next: Cyton = 0, Ganglion = 1, Playback = 2, Synthetic = 3
        loadDatasource = loadDataSettings.getInt("Data Source");
        verbosePrint("loadGUISettings: Data source loaded: " + loadDatasource + ". Current data source: " + eegDataSource);
        //Print error if trying to load a different data source (ex. Live != Synthetic)
        if (loadDatasource != eegDataSource) {
            println("Data source being loaded from " + loadGUISettingsFileLocation + " doesn't match current data source.");
            dataSourceError = true;
            throw new Exception();
        } else {
            dataSourceError = false;
        }

        //get the global settings JSON object
        JSONObject loadGlobalSettings = loadSettingsJSONData.getJSONObject(kJSONKeySettings);
        loadLayoutSetting = loadGlobalSettings.getInt("Current Layout");
        loadNotchSetting = loadGlobalSettings.getInt("Notch");
        loadBandpassSetting = loadGlobalSettings.getInt("Bandpass Filter");
        loadFramerate = loadGlobalSettings.getInt("Framerate");
        Boolean loadExpertModeToggle = loadGlobalSettings.getBoolean("Expert Mode");
        Boolean loadAccelerometer = loadGlobalSettings.getBoolean("Accelerometer Mode");
        if (eegDataSource == DATASOURCE_CYTON) { //Only save these settings if you are using a Cyton board for live streaming
            loadAnalogReadVertScale = loadGlobalSettings.getInt("Analog Read Vert Scale");
            loadAnalogReadHorizScale = loadGlobalSettings.getInt("Analog Read Horiz Scale");
            loadBoardMode = BoardMode.values()[loadGlobalSettings.getInt("Board Mode")];
        }
        //Store loaded layout to current layout variable
        currentLayout = loadLayoutSetting;
        //Load more global settings after this line, if needed

        //Create a string array to print global settings to console
        String[] loadedGlobalSettings = {
            "Using Layout Number: " + loadLayoutSetting,
            "Default Notch: " + loadNotchSetting, //default notch
            "Default BP: " + loadBandpassSetting, //default bp
            "Default Framerate: " + loadFramerate, //default framerate
            "Expert Mode: " + loadExpertModeToggle,
            "TS Vert Scale: " + loadTimeSeriesVertScale,
            "TS Horiz Scale: " + loadTimeSeriesHorizScale,
            "Analog Vert Scale: " + loadAnalogReadVertScale,
            "Analog Horiz Scale: " + loadAnalogReadHorizScale,
            "Accelerometer: " + loadAccelerometer,
            "Board Mode: " + loadBoardMode,
            //Add new global settings above this line to print to console
            };
        //Print the global settings that have been loaded to the console
        //printArray(loadedGlobalSettings);

        //get the FFT settings
        JSONObject loadFFTSettings = loadSettingsJSONData.getJSONObject(kJSONKeyFFT);
        fftMaxFrqLoad = loadFFTSettings.getInt("FFT_Max Freq");
        fftMaxuVLoad = loadFFTSettings.getInt("FFT_Max uV");
        fftLogLinLoad = loadFFTSettings.getInt("FFT_LogLin");
        fftSmoothingLoad = loadFFTSettings.getInt("FFT_Smoothing");
        fftFilterLoad = loadFFTSettings.getInt("FFT_Filter");

        //Create a string array to print to console
        String[] loadedFFTSettings = {
            "FFT_Max Frequency: " + fftMaxFrqLoad,
            "FFT_Max uV: " + fftMaxuVLoad,
            "FFT_Log/Lin: " + fftLogLinLoad,
            "FFT_Smoothing: " + fftSmoothingLoad,
            "FFT_Filter: " + fftFilterLoad
            };
        //Print the FFT settings that have been loaded to the console
        //printArray(loadedFFTSettings);

        //get the Accelerometer settings
        JSONObject loadAccSettings = loadSettingsJSONData.getJSONObject(kJSONKeyAccel);
        loadAccelVertScale = loadAccSettings.getInt("Accelerometer Vert Scale");
        loadAccelHorizScale = loadAccSettings.getInt("Accelerometer Horiz Scale");
        String[] loadedAccSettings = {
            "Accelerometer Vert Scale: " + loadAccelVertScale,
            "Accelerometer Horiz Scale: " + loadAccelHorizScale
        };

        //get the Networking Settings
        JSONObject loadNetworkingSettings = loadSettingsJSONData.getJSONObject(kJSONKeyNetworking);
        nwProtocolLoad = loadNetworkingSettings.getInt("Protocol");
        switch (nwProtocolLoad)  {
            case 3:
                nwDataType1 = loadNetworkingSettings.getInt("OSC_DataType1");
                nwDataType2 = loadNetworkingSettings.getInt("OSC_DataType2");
                nwDataType3 = loadNetworkingSettings.getInt("OSC_DataType3");
                nwDataType4 = loadNetworkingSettings.getInt("OSC_DataType4");
                nwOscIp1Load = loadNetworkingSettings.getString("OSC_ip1");
                nwOscIp2Load = loadNetworkingSettings.getString("OSC_ip2");
                nwOscIp3Load = loadNetworkingSettings.getString("OSC_ip3");
                nwOscIp4Load = loadNetworkingSettings.getString("OSC_ip4");
                nwOscPort1Load = loadNetworkingSettings.getString("OSC_port1");
                nwOscPort2Load = loadNetworkingSettings.getString("OSC_port2");
                nwOscPort3Load = loadNetworkingSettings.getString("OSC_port3");
                nwOscPort4Load = loadNetworkingSettings.getString("OSC_port4");
                nwOscAddress1Load = loadNetworkingSettings.getString("OSC_address1");
                nwOscAddress2Load = loadNetworkingSettings.getString("OSC_address2");
                nwOscAddress3Load = loadNetworkingSettings.getString("OSC_address3");
                nwOscAddress4Load = loadNetworkingSettings.getString("OSC_address4");
                nwOscFilter1Load = loadNetworkingSettings.getInt("OSC_filter1");
                nwOscFilter2Load = loadNetworkingSettings.getInt("OSC_filter2");
                nwOscFilter3Load = loadNetworkingSettings.getInt("OSC_filter3");
                nwOscFilter4Load = loadNetworkingSettings.getInt("OSC_filter4");
                break;
            case 2:
                nwDataType1 = loadNetworkingSettings.getInt("UDP_DataType1");
                nwDataType2 = loadNetworkingSettings.getInt("UDP_DataType2");
                nwDataType3 = loadNetworkingSettings.getInt("UDP_DataType3");
                nwUdpIp1Load = loadNetworkingSettings.getString("UDP_ip1");
                nwUdpIp2Load = loadNetworkingSettings.getString("UDP_ip2");
                nwUdpIp3Load = loadNetworkingSettings.getString("UDP_ip3");
                nwUdpPort1Load = loadNetworkingSettings.getString("UDP_port1");
                nwUdpPort2Load = loadNetworkingSettings.getString("UDP_port2");
                nwUdpPort3Load = loadNetworkingSettings.getString("UDP_port3");
                nwUdpFilter1Load = loadNetworkingSettings.getInt("UDP_filter1");
                nwUdpFilter2Load = loadNetworkingSettings.getInt("UDP_filter2");
                nwUdpFilter3Load = loadNetworkingSettings.getInt("UDP_filter3");
                break;
            case 1:
                nwDataType1 = loadNetworkingSettings.getInt("LSL_DataType1");
                nwDataType2 = loadNetworkingSettings.getInt("LSL_DataType2");
                nwDataType3 = loadNetworkingSettings.getInt("LSL_DataType3");
                nwLSLName1Load = loadNetworkingSettings.getString("LSL_name1");
                nwLSLName2Load = loadNetworkingSettings.getString("LSL_name2");
                nwLSLName3Load = loadNetworkingSettings.getString("LSL_name3");
                nwLSLType1Load = loadNetworkingSettings.getString("LSL_type1");
                nwLSLType2Load = loadNetworkingSettings.getString("LSL_type2");
                nwLSLType3Load = loadNetworkingSettings.getString("LSL_type3");
                nwLSLNumChan1Load = loadNetworkingSettings.getString("LSL_numchan1");
                nwLSLNumChan2Load = loadNetworkingSettings.getString("LSL_numchan2");
                nwLSLNumChan3Load = loadNetworkingSettings.getString("LSL_numchan3");
                nwLSLFilter1Load = loadNetworkingSettings.getInt("LSL_filter1");
                nwLSLFilter2Load = loadNetworkingSettings.getInt("LSL_filter2");
                nwLSLFilter3Load = loadNetworkingSettings.getInt("LSL_filter3");
                break;
            case 0:
                nwDataType1 = loadNetworkingSettings.getInt("Serial_DataType1");
                nwSerialBaudRateLoad = loadNetworkingSettings.getInt("Serial_baudrate");
                nwSerialFilter1Load = loadNetworkingSettings.getInt("Serial_filter1");
                nwSerialPort = loadNetworkingSettings.getString("Serial_portName");
                break;
        } //end switch case for all networking types

        //get the  Headplot settings
        JSONObject loadHeadplotSettings = loadSettingsJSONData.getJSONObject(kJSONKeyHeadplot);
        hpIntensityLoad = loadHeadplotSettings.getInt("HP_intensity");
        hpPolarityLoad = loadHeadplotSettings.getInt("HP_polarity");
        hpContoursLoad = loadHeadplotSettings.getInt("HP_contours");
        hpSmoothingLoad = loadHeadplotSettings.getInt("HP_smoothing");

        //Create a string array to print to console
        String[] loadedHPSettings = {
            "HP_intensity: " + hpIntensityLoad,
            "HP_polarity: " + hpPolarityLoad,
            "HP_contours: " + hpContoursLoad,
            "HP_smoothing: " + hpSmoothingLoad
            };
        //Print the Headplot settings
        //printArray(loadedHPSettings);

        //get the EMG settings
        JSONObject loadEMGSettings = loadSettingsJSONData.getJSONObject(kJSONKeyEMG);
        emgSmoothingLoad = loadEMGSettings.getInt("EMG_smoothing");
        emguVLimLoad = loadEMGSettings.getInt("EMG_uVlimit");
        emgCreepLoad = loadEMGSettings.getInt("EMG_creepspeed");
        emgMinDeltauVLoad = loadEMGSettings.getInt("EMG_minuV");

        //Create a string array to print to console
        String[] loadedEMGSettings = {
            "EMG_smoothing: " + emgSmoothingLoad,
            "EMG_uVlimit: " + emguVLimLoad,
            "EMG_creepspeed: " + emgCreepLoad,
            "EMG_minuV: " + emgMinDeltauVLoad
            };
        //Print the EMG settings
        //printArray(loadedEMGSettings);

        //get the  Focus settings
        JSONObject loadFocusSettings = loadSettingsJSONData.getJSONObject(kJSONKeyFocus);
        focusThemeLoad = loadFocusSettings.getInt("Focus_theme");
        focusKeyLoad = loadFocusSettings.getInt("Focus_keypress");

        //Create a string array to print to console
        String[] loadedFocusSettings = {
            "Focus_theme: " + focusThemeLoad,
            "Focus_keypress: " + focusKeyLoad
            };
        //Print the EMG settings
        //printArray(loadedFocusSettings);

        //Clear the list and array for holding SSVEP settings
        loadSSVEPActiveChans.clear(); //clear this list so user can load settings over and over
        ssvepFreqsLoad = new int[4]; //clear the dropdown settings array
        //get the ssvep settings
        JSONObject loadSSVEPSettings = loadSettingsJSONData.getJSONObject(kJSONKeySSVEP);
        numSSVEPsLoad = loadSSVEPSettings.getInt("NumSSVEPs");
        JSONObject loadSSVEPFreqs = loadSSVEPSettings.getJSONObject("SSVEP_frequencies");
        for (int i = 0; i < numSSVEPsLoad; i++) {
            int f = loadSSVEPFreqs.getInt("SSVEP_" + i);
            ssvepFreqsLoad[i] = f;
        }
        JSONArray loadSSVEPChan = loadSSVEPSettings.getJSONArray("activeChannels");
        for (int i = 0; i < loadSSVEPChan.size(); i++) {
            loadSSVEPActiveChans.add(loadSSVEPChan.getInt(i));
        }
        //println("Settings: ssvep active chans loaded = " + loadSSVEPActiveChans);

        //get band power settings
        loadBPActiveChans.clear();
        JSONObject loadBPSettings = loadSettingsJSONData.getJSONObject(kJSONKeyBandPower);
        JSONArray loadBPChan = loadBPSettings.getJSONArray("activeChannels");
        for (int i = 0; i < loadBPChan.size(); i++) {
            loadBPActiveChans.add(loadBPChan.getInt(i));
        }
        //println("Settings: band power active chans loaded = " + loadBPActiveChans );

        //get the  Widget/Container settings
        JSONObject loadWidgetSettings = loadSettingsJSONData.getJSONObject(kJSONKeyWidget);
        //Apply Layout directly before loading and applying widgets to containers
        wm.setNewContainerLayout(loadLayoutSetting);
        verbosePrint("LoadGUISettings: Layout " + loadLayoutSetting + " Loaded!");
        numLoadedWidgets = loadWidgetSettings.size();


        //int numActiveWidgets = 0; //reset the counter
        for (int w = 0; w < wm.widgets.size(); w++) { //increment through all widgets
            if (wm.widgets.get(w).isActive) { //If a widget is active...
                verbosePrint("Deactivating widget [" + w + "]");
                wm.widgets.get(w).isActive = false;
                //numActiveWidgets++; //counter the number of de-activated widgets
            }
        }

        //Store the Widget number keys from JSON to a string array
        loadedWidgetsArray = (String[]) loadWidgetSettings.keys().toArray(new String[loadWidgetSettings.size()]);
        //printArray(loadedWidgetsArray);
        int widgetToActivate = 0;
        for (int w = 0; w < numLoadedWidgets; w++) {
                String [] loadWidgetNameNumber = split(loadedWidgetsArray[w], '_');
                //Store the value of the widget to be activated
                widgetToActivate = Integer.valueOf(loadWidgetNameNumber[1]);
                //Load the container for the current widget[w]
                int containerToApply = loadWidgetSettings.getInt(loadedWidgetsArray[w]);

                wm.widgets.get(widgetToActivate).isActive = true;//activate the new widget
                wm.widgets.get(widgetToActivate).setContainer(containerToApply);//map it to the container that was loaded!
                println("LoadGUISettings: Applied Widget " + widgetToActivate + " to Container " + containerToApply);
        }//end case for all widget/container settings

        /////////////////////////////////////////////////////////////
        //    Load more widget settings above this line as above   //

        //}//end case for all objects in JSON

        //Apply notch
        dataProcessing.currentNotch_ind = loadNotchSetting;
        topNav.filtNotchButton.but_txt = "Notch\n" + dataProcessingNotchArray[loadNotchSetting];
        //Apply Bandpass filter
        dataProcessing.currentFilt_ind = loadBandpassSetting;
        topNav.filtBPButton.but_txt = "BP Filt\n" + dataProcessingBPArray[loadBandpassSetting]; //this works

        //Apply Board Mode to Cyton Only
        if (eegDataSource == DATASOURCE_CYTON) {
            applyBoardMode();
        }

        //Apply Expert Mode toggle
        if (loadExpertModeToggle) {
            topNav.configSelector.configOptions.get(0).setString("Turn Expert Mode Off");
            topNav.configSelector.configOptions.get(0).setColorNotPressed(topNav.configSelector.expertPurple);
            println("LoadGUISettings: Expert Mode On");
            expertModeToggle = true;
        } else {
            topNav.configSelector.configOptions.get(0).setString("Turn Expert Mode On");
            topNav.configSelector.configOptions.get(0).setColorNotPressed(topNav.configSelector.newGreen);
            println("LoadGUISettings: Expert Mode Off");
            expertModeToggle = false;
        }

        //Apply Framerate
        frameRateCounter = loadFramerate;
        switch (frameRateCounter) {
            case 0:
                topNav.fpsButton.setString("24 fps");
                frameRate(24); //refresh rate ... this will slow automatically, if your processor can't handle the specified rate
                break;
            case 1:
                topNav.fpsButton.setString("30 fps");
                frameRate(30); //refresh rate ... this will slow automatically, if your processor can't handle the specified rate
                break;
            case 2:
                topNav.fpsButton.setString("45 fps");
                frameRate(45); //refresh rate ... this will slow automatically, if your processor can't handle the specified rate
                break;
            case 3:
                topNav.fpsButton.setString("60 fps");
                frameRate(60); //refresh rate ... this will slow automatically, if your processor can't handle the specified rate
                break;
        }

        //Load and apply all of the settings that are in dropdown menus. It's a bit much, so it has it's own function below.
        loadApplyWidgetDropdownText();

        //Apply Time Series Settings Last!!!
        loadApplyTimeSeriesSettings();

        //Force headplot to redraw if it is active
        int hpWidgetNumber;
        if (eegDataSource == DATASOURCE_GANGLION) {
            hpWidgetNumber = 6;
        } else {
            hpWidgetNumber = 5;
        }
        if (wm.widgets.get(hpWidgetNumber).isActive) {
            w_headPlot.headPlot.setPositionSize(w_headPlot.headPlot.hp_x, w_headPlot.headPlot.hp_y, w_headPlot.headPlot.hp_w, w_headPlot.headPlot.hp_h, w_headPlot.headPlot.hp_win_x, w_headPlot.headPlot.hp_win_y);
            println("Headplot is active: Redrawing");
        }

        //Apply the accelerometer boolean to backend and frontend when using Ganglion. When using Cyton, applyBoardMode does the work.
        if (eegDataSource == DATASOURCE_GANGLION) {
            if (loadAccelerometer) { //if loadAccelerometer is true. This has been loaded from JSON file.
                // daniellasry: it seems the ganglion board does not like turning on the accelerometer
                // immediately after activating channels. From what I can tell, the issue is in the
                // firmware. This delay is a workaround for the issue.
                // retiutut: Containing this fix to BLED112 only!
                if (ganglion.getInterface() == INTERFACE_HUB_BLED112) {
                    delay(1000);
                }
                ganglion.accelStart(); //send message to hub
            } else {
                ganglion.accelStop(); //send message to hub
            }
        }

    } //end of loadGUISettings
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private void applyBoardMode() {
        //Apply Board Mode
        switch(loadBoardMode) { //Switch-case for loaded board mode
            case DEFAULT:
                cyton.setBoardMode(BoardMode.DEFAULT);
                //outputSuccess("Starting to read accelerometer");
                w_analogRead.analogReadOn = false;
                w_pulsesensor.analogReadOn = false;
                w_digitalRead.digitalReadOn = false;
                w_markermode.markerModeOn = false;
                break;
            case DEBUG: //Not being used currently
                break;
            case ANALOG:
                if (cyton.isPortOpen()) { //This code has been copied from AnalogRead
                    if (cyton.getBoardMode() != BoardMode.ANALOG) {
                        cyton.setBoardMode(BoardMode.ANALOG);
                        if (cyton.isWifi()) {
                            output("Starting to read analog inputs on pin marked A5 (D11) and A6 (D12)");
                        } else {
                            output("Starting to read analog inputs on pin marked A5 (D11), A6 (D12) and A7 (D13)");
                        }
                        w_digitalRead.digitalReadOn = false;
                        w_markermode.markerModeOn = false;
                        w_pulsesensor.analogReadOn = true;
                        w_analogRead.analogReadOn = true;
                    } else {
                        cyton.setBoardMode(BoardMode.DEFAULT);
                        output("Starting to read accelerometer");
                    }
                }
                break;
            case DIGITAL:
                if (cyton.isPortOpen()) { //This code has been copied from DigitalRead
                    if (cyton.getBoardMode() != BoardMode.DIGITAL) {
                        cyton.setBoardMode(BoardMode.DIGITAL);
                        if (cyton.isWifi()) {
                            output("Starting to read digital inputs on pin marked D11, D12 and D17");
                        } else {
                            output("Starting to read digital inputs on pin marked D11, D12, D13, D17 and D18");
                        }
                        w_analogRead.analogReadOn = false;
                        w_pulsesensor.analogReadOn = false;
                        w_markermode.markerModeOn = false;
                    } else {
                        cyton.setBoardMode(BoardMode.DEFAULT);
                        outputSuccess("Starting to read accelerometer");
                    }
                }
                break;
            case MARKER:
                if ((cyton.isPortOpen() && eegDataSource == DATASOURCE_CYTON) || eegDataSource == DATASOURCE_SYNTHETIC) {
                    if (cyton.getBoardMode() != BoardMode.MARKER) {
                        cyton.setBoardMode(BoardMode.MARKER);
                        output("Starting to read markers");
                        w_markermode.markerModeButton.setString("Turn Marker Off");
                        w_analogRead.analogReadOn = false;
                        w_pulsesensor.analogReadOn = false;
                        w_digitalRead.digitalReadOn = false;
                    } else {
                        cyton.setBoardMode(BoardMode.DEFAULT);
                        output("Starting to read accelerometer");
                        w_markermode.markerModeButton.setString("Turn Marker On");
                        w_analogRead.analogReadOn = false;
                        w_pulsesensor.analogReadOn = false;
                        w_digitalRead.digitalReadOn = false;
                    }
                }
                break;
        }//end switch/case
    }

    private void loadApplyWidgetDropdownText() {

        ////////Apply Time Series dropdown settings in loadApplyTimeSeriesSettings() instead of here

        ////////Apply FFT settings
        MaxFreq(fftMaxFrqLoad); //This changes the back-end
            w_fft.cp5_widget.getController("MaxFreq").getCaptionLabel().setText(fftMaxFrqArray[fftMaxFrqLoad]); //This changes front-end... etc.

        VertScale(fftMaxuVLoad);
            w_fft.cp5_widget.getController("VertScale").getCaptionLabel().setText(fftVertScaleArray[fftMaxuVLoad]);

        LogLin(fftLogLinLoad);
            w_fft.cp5_widget.getController("LogLin").getCaptionLabel().setText(fftLogLinArray[fftLogLinLoad]);

        Smoothing(fftSmoothingLoad);
            w_fft.cp5_widget.getController("Smoothing").getCaptionLabel().setText(fftSmoothingArray[fftSmoothingLoad]);

        UnfiltFilt(fftFilterLoad);
            w_fft.cp5_widget.getController("UnfiltFilt").getCaptionLabel().setText(fftFilterArray[fftFilterLoad]);

        ////////Apply Accelerometer settings;
        accelVertScale(loadAccelVertScale);
            w_accelerometer.cp5_widget.getController("accelVertScale").getCaptionLabel().setText(accVertScaleArray[loadAccelVertScale]);

        accelDuration(loadAccelHorizScale);
            w_accelerometer.cp5_widget.getController("accelDuration").getCaptionLabel().setText(accHorizScaleArray[loadAccelHorizScale]);

        ////////Apply Anolog Read dropdowns to Live Cyton Only
        if (eegDataSource == DATASOURCE_CYTON) {
            ////////Apply Analog Read settings
            VertScale_AR(loadAnalogReadVertScale);
                w_analogRead.cp5_widget.getController("VertScale_AR").getCaptionLabel().setText(arVertScaleArray[loadAnalogReadVertScale]);

            Duration_AR(loadAnalogReadHorizScale);
                w_analogRead.cp5_widget.getController("Duration_AR").getCaptionLabel().setText(arHorizScaleArray[loadAnalogReadHorizScale]);
        }

        ////////////////////////////Apply Headplot settings
        Intensity(hpIntensityLoad);
            w_headPlot.cp5_widget.getController("Intensity").getCaptionLabel().setText(hpIntensityArray[hpIntensityLoad]);

        Polarity(hpPolarityLoad);
            w_headPlot.cp5_widget.getController("Polarity").getCaptionLabel().setText(hpPolarityArray[hpPolarityLoad]);

        ShowContours(hpContoursLoad);
            w_headPlot.cp5_widget.getController("ShowContours").getCaptionLabel().setText(hpContoursArray[hpContoursLoad]);

        SmoothingHeadPlot(hpSmoothingLoad);
            w_headPlot.cp5_widget.getController("SmoothingHeadPlot").getCaptionLabel().setText(hpSmoothingArray[hpSmoothingLoad]);

        //Force redraw headplot on load. Fixes issue where heaplot draws outside of the widget.
        w_headPlot.headPlot.setPositionSize(w_headPlot.headPlot.hp_x, w_headPlot.headPlot.hp_y, w_headPlot.headPlot.hp_w, w_headPlot.headPlot.hp_h, w_headPlot.headPlot.hp_win_x, w_headPlot.headPlot.hp_win_y);

        ////////////////////////////Apply EMG settings
        SmoothEMG(emgSmoothingLoad);
            w_emg.cp5_widget.getController("SmoothEMG").getCaptionLabel().setText(emgSmoothingArray[emgSmoothingLoad]);

        uVLimit(emguVLimLoad);
            w_emg.cp5_widget.getController("uVLimit").getCaptionLabel().setText(emguVLimArray[emguVLimLoad]);

        CreepSpeed(emgCreepLoad);
            w_emg.cp5_widget.getController("CreepSpeed").getCaptionLabel().setText(emgCreepArray[emgCreepLoad]);

        minUVRange(emgMinDeltauVLoad);
            w_emg.cp5_widget.getController("minUVRange").getCaptionLabel().setText(emgMinDeltauVArray[emgMinDeltauVLoad]);

        ////////////////////////////Apply Focus settings
        ChooseFocusColor(focusThemeLoad);
            w_focus.cp5_widget.getController("ChooseFocusColor").getCaptionLabel().setText(focusThemeArray[focusThemeLoad]);

        StrokeKeyWhenFocused(focusKeyLoad);
            w_focus.cp5_widget.getController("StrokeKeyWhenFocused").getCaptionLabel().setText(focusKeyArray[focusKeyLoad]);

        ////////////////////////////Apply SSVEP settings
        //Apply number ssveps dropdown
        NumberSSVEP(numSSVEPsLoad - 1); //subtract 1 here because dropdowns count from 0
            w_ssvep.cp5_widget.getController("NumberSSVEP").getCaptionLabel().setText(String.valueOf(numSSVEPsLoad));
        //Apply ssvep frequency dropdowns
        for (int i = 0; i < numSSVEPsLoad; i++) {
            if (ssvepFreqsLoad[i] > 1) {
                w_ssvep.cp5_ssvep.getController("Frequency_"+(i+1)).getCaptionLabel().setText(ssvepFreqsLoad[i]+" Hz");
                w_ssvep.cp5_ssvep.get(ScrollableList.class, "Frequency_"+(i+1)).setValue(ssvepFreqsLoad[i] - 7);
                w_ssvep.freqs[i] = ssvepFreqsLoad[i];
            } else { // -1 - none selected
                w_ssvep.cp5_ssvep.getController("Frequency_"+(i+1)).getCaptionLabel().setText("Frequency_"+(i+1));
            }
        }
        //Apply ssvepActiveChans settings by activating/deactivating check boxes for all channels
        try {
            //deactivate all channels and then activate the active channels
            w_ssvep.ssvepChanSelect.cp5_channelCheckboxes.get(CheckBox.class, "SSVEP_Channels").deactivateAll();
            if (loadSSVEPActiveChans.size() > 0) {
                int activeChanCounter = 0;
                for (int i = 0; i < nchan; i++) {
                    if (activeChanCounter  < loadSSVEPActiveChans.size()) {
                        //subtract 1 because cp5 starts count from 0
                        if (i == (loadSSVEPActiveChans.get(activeChanCounter) - 1)) {
                            w_ssvep.ssvepChanSelect.cp5_channelCheckboxes.get(CheckBox.class, "SSVEP_Channels").activate(i);
                            activeChanCounter++;
                        }
                    }
                }
            }
        } catch (Exception e) {
            println("Settings: Exception caught applying ssvep settings" + e);
        }
        verbosePrint("Settings: SSVEP Active Channels: " + loadSSVEPActiveChans);

        ////////////////////////////Apply Band Power settings
        try {
            //use the same process as ssvep to apply channel checkbox settings
            w_bandPower.bpChanSelect.cp5_channelCheckboxes.get(CheckBox.class, "BP_Channels").deactivateAll();
            if (loadBPActiveChans.size() > 0) {
                int activeChanCounterBP = 0;
                for (int i = 0; i < nchan; i++) {
                    if (activeChanCounterBP  < loadBPActiveChans.size()) {
                        //subtract 1 because cp5 starts count from 0
                        if (i == (loadBPActiveChans.get(activeChanCounterBP) - 1)) {
                            w_bandPower.bpChanSelect.cp5_channelCheckboxes.get(CheckBox.class, "BP_Channels").activate(i);
                            activeChanCounterBP++;
                        }
                    }
                }
            }
        } catch (Exception e) {
            println("Settings: Exception caught applying band power settings " + e);
        }
        verbosePrint("Settings: SSVEP Active Channels: " + loadSSVEPActiveChans);

        ///////////Apply Networking Settings
        //Update protocol with loaded value
        Protocol(nwProtocolLoad);
        //Update dropdowns and textfields in the Networking widget with loaded values
        w_networking.cp5_widget.getController("Protocol").getCaptionLabel().setText(nwProtocolArray[nwProtocolLoad]); //Reference the dropdown from the appropriate widget
        switch (nwProtocolLoad) {
            case 3:  //Apply OSC if loaded
                println("Apply OSC Networking Mode");
                w_networking.cp5_networking_dropdowns.getController("dataType1").getCaptionLabel().setText(nwDataTypesArray[nwDataType1]); //Set text on frontend
                w_networking.cp5_networking_dropdowns.get(ScrollableList.class, "dataType1").setValue(nwDataType1); //Set value in backend
                w_networking.cp5_networking_dropdowns.getController("dataType2").getCaptionLabel().setText(nwDataTypesArray[nwDataType2]); //etc...
                w_networking.cp5_networking_dropdowns.get(ScrollableList.class, "dataType2").setValue(nwDataType2);
                w_networking.cp5_networking_dropdowns.getController("dataType3").getCaptionLabel().setText(nwDataTypesArray[nwDataType3]);
                w_networking.cp5_networking_dropdowns.get(ScrollableList.class, "dataType3").setValue(nwDataType3);
                w_networking.cp5_networking_dropdowns.getController("dataType4").getCaptionLabel().setText(nwDataTypesArray[nwDataType4]);
                w_networking.cp5_networking_dropdowns.get(ScrollableList.class, "dataType4").setValue(nwDataType4);
                w_networking.cp5_networking.get(Textfield.class, "OSC_ip1").setText(nwOscIp1Load); //Simply set the text for text boxes
                w_networking.cp5_networking.get(Textfield.class, "OSC_ip2").setText(nwOscIp2Load); //The strings are referenced on command
                w_networking.cp5_networking.get(Textfield.class, "OSC_ip3").setText(nwOscIp3Load);
                w_networking.cp5_networking.get(Textfield.class, "OSC_ip4").setText(nwOscIp4Load);
                w_networking.cp5_networking.get(Textfield.class, "OSC_port1").setText(nwOscPort1Load);
                w_networking.cp5_networking.get(Textfield.class, "OSC_port2").setText(nwOscPort2Load);
                w_networking.cp5_networking.get(Textfield.class, "OSC_port3").setText(nwOscPort3Load);
                w_networking.cp5_networking.get(Textfield.class, "OSC_port4").setText(nwOscPort4Load);
                w_networking.cp5_networking.get(Textfield.class, "OSC_address1").setText(nwOscAddress1Load);
                w_networking.cp5_networking.get(Textfield.class, "OSC_address2").setText(nwOscAddress2Load);
                w_networking.cp5_networking.get(Textfield.class, "OSC_address3").setText(nwOscAddress3Load);
                w_networking.cp5_networking.get(Textfield.class, "OSC_address4").setText(nwOscAddress4Load);
                w_networking.cp5_networking.get(RadioButton.class, "filter1").activate(nwOscFilter1Load);
                w_networking.cp5_networking.get(RadioButton.class, "filter2").activate(nwOscFilter2Load);
                w_networking.cp5_networking.get(RadioButton.class, "filter3").activate(nwOscFilter3Load);
                w_networking.cp5_networking.get(RadioButton.class, "filter4").activate(nwOscFilter4Load);
                break;
            case 2:  //Apply UDP if loaded
                println("Apply UDP Networking Mode");
                w_networking.cp5_networking_dropdowns.getController("dataType1").getCaptionLabel().setText(nwDataTypesArray[nwDataType1]); //Set text on frontend
                w_networking.cp5_networking_dropdowns.get(ScrollableList.class, "dataType1").setValue(nwDataType1); //Set value in backend
                w_networking.cp5_networking_dropdowns.getController("dataType2").getCaptionLabel().setText(nwDataTypesArray[nwDataType2]); //etc...
                w_networking.cp5_networking_dropdowns.get(ScrollableList.class, "dataType2").setValue(nwDataType2);
                w_networking.cp5_networking_dropdowns.getController("dataType3").getCaptionLabel().setText(nwDataTypesArray[nwDataType3]);
                w_networking.cp5_networking_dropdowns.get(ScrollableList.class, "dataType3").setValue(nwDataType3);
                w_networking.cp5_networking.get(Textfield.class, "UDP_ip1").setText(nwUdpIp1Load);
                w_networking.cp5_networking.get(Textfield.class, "UDP_ip2").setText(nwUdpIp2Load);
                w_networking.cp5_networking.get(Textfield.class, "UDP_ip3").setText(nwUdpIp3Load);
                w_networking.cp5_networking.get(Textfield.class, "UDP_port1").setText(nwUdpPort1Load);
                w_networking.cp5_networking.get(Textfield.class, "UDP_port2").setText(nwUdpPort2Load);
                w_networking.cp5_networking.get(Textfield.class, "UDP_port3").setText(nwUdpPort3Load);
                w_networking.cp5_networking.get(RadioButton.class, "filter1").activate(nwUdpFilter1Load);
                w_networking.cp5_networking.get(RadioButton.class, "filter2").activate(nwUdpFilter2Load);
                w_networking.cp5_networking.get(RadioButton.class, "filter3").activate(nwUdpFilter3Load);
                break;
            case 1:  //Apply LSL if loaded
                println("Apply LSL Networking Mode");
                w_networking.cp5_networking_dropdowns.getController("dataType1").getCaptionLabel().setText(nwDataTypesArray[nwDataType1]); //Set text on frontend
                w_networking.cp5_networking_dropdowns.get(ScrollableList.class, "dataType1").setValue(nwDataType1); //Set value in backend
                w_networking.cp5_networking_dropdowns.getController("dataType2").getCaptionLabel().setText(nwDataTypesArray[nwDataType2]); //etc...
                w_networking.cp5_networking_dropdowns.get(ScrollableList.class, "dataType2").setValue(nwDataType2);
                w_networking.cp5_networking_dropdowns.getController("dataType3").getCaptionLabel().setText(nwDataTypesArray[nwDataType3]);
                w_networking.cp5_networking_dropdowns.get(ScrollableList.class, "dataType3").setValue(nwDataType3);
                w_networking.cp5_networking.get(Textfield.class, "LSL_name1").setText(nwLSLName1Load);
                w_networking.cp5_networking.get(Textfield.class, "LSL_name2").setText(nwLSLName2Load);
                w_networking.cp5_networking.get(Textfield.class, "LSL_name3").setText(nwLSLName3Load);
                w_networking.cp5_networking.get(Textfield.class, "LSL_type1").setText(nwLSLType1Load);
                w_networking.cp5_networking.get(Textfield.class, "LSL_type2").setText(nwLSLType2Load);
                w_networking.cp5_networking.get(Textfield.class, "LSL_type3").setText(nwLSLType3Load);
                w_networking.cp5_networking.get(Textfield.class, "LSL_numchan1").setText(nwLSLNumChan1Load);
                w_networking.cp5_networking.get(Textfield.class, "LSL_numchan2").setText(nwLSLNumChan2Load);
                w_networking.cp5_networking.get(Textfield.class, "LSL_numchan3").setText(nwLSLNumChan3Load);
                w_networking.cp5_networking.get(RadioButton.class, "filter1").activate(nwLSLFilter1Load);
                w_networking.cp5_networking.get(RadioButton.class, "filter2").activate(nwLSLFilter2Load);
                w_networking.cp5_networking.get(RadioButton.class, "filter3").activate(nwLSLFilter3Load);
                break;
            case 0:  //Apply Serial if loaded
                println("Apply Serial Networking Mode");
                w_networking.cp5_networking_dropdowns.getController("dataType1").getCaptionLabel().setText(nwDataTypesArray[nwDataType1]); //Set text on frontend
                w_networking.cp5_networking_dropdowns.get(ScrollableList.class, "dataType1").setValue(nwDataType1); //Set value in backend
                w_networking.cp5_networking_baudRate.getController("baud_rate").getCaptionLabel().setText(nwBaudRatesArray[nwSerialBaudRateLoad]); //Set text
                w_networking.cp5_networking_baudRate.get(ScrollableList.class, "baud_rate").setValue(nwSerialBaudRateLoad); //Set value in backend
                w_networking.cp5_networking.get(RadioButton.class, "filter1").activate(nwSerialFilter1Load);

                //Look for the portName in the dropdown list
                int listSize = w_networking.cp5_networking_portName.get(ScrollableList.class, "port_name").getItems().size();
                for (int i = 0; i < listSize; i++) {
                    String s = w_networking.cp5_networking_portName.get(ScrollableList.class, "port_name").getItem(i).get("name").toString();
                    if (s.equals(nwSerialPort)) {
                        verbosePrint("Settings: NWSerial: Found com port " + s + " !");
                        w_networking.cp5_networking_portName.getController("port_name").getCaptionLabel().setText(s);
                        w_networking.cp5_networking_portName.get(ScrollableList.class, "port_name").setValue(i);
                        break;
                    } else {
                        if (i == listSize - 1) verbosePrint("Settings: NWSerial: Port not found...");
                    }
                }
                break;
        }//end switch-case for networking settings for all networking protocols

        ////////////////////////////////////////////////////////////
        //    Apply more loaded widget settings above this line   //

    } //end of loadApplyWidgetDropdownText()

    private void loadApplyTimeSeriesSettings() {

        JSONObject loadTimeSeriesSettings = loadSettingsJSONData.getJSONObject(kJSONKeyTimeSeries);
        loadTimeSeriesVertScale = loadTimeSeriesSettings.getInt("Time Series Vert Scale");
        loadTimeSeriesHorizScale = loadTimeSeriesSettings.getInt("Time Series Horiz Scale");

        ////////Apply Time Series widget settings
        VertScale_TS(loadTimeSeriesVertScale);// changes back-end
            w_timeSeries.cp5_widget.getController("VertScale_TS").getCaptionLabel().setText(tsVertScaleArray[loadTimeSeriesVertScale]); //changes front-end
        Duration(loadTimeSeriesHorizScale);
            w_timeSeries.cp5_widget.getController("Duration").getCaptionLabel().setText(tsHorizScaleArray[loadTimeSeriesHorizScale]);

        //Make a JSON object to load channel setting array
        JSONArray loadTimeSeriesJSONArray = loadTimeSeriesSettings.getJSONArray("channelSettings");

        //Case for loading time series settings in Live Data mode
        if (eegDataSource == DATASOURCE_CYTON)  {
            //get the channel settings first for only the number of channels being used
            for (int i = 0; i < numChanloaded; i++) {
                JSONObject loadTSChannelSettings = loadTimeSeriesJSONArray.getJSONObject(i);
                int channel = loadTSChannelSettings.getInt("Channel_Number") - 1; //when using with channelSettingsValues, will need to subtract 1
                int active = loadTSChannelSettings.getInt("Active");
                int gainSetting = loadTSChannelSettings.getInt("PGA Gain");
                int inputType = loadTSChannelSettings.getInt("Input Type");
                int biasSetting = loadTSChannelSettings.getInt("Bias");
                int srb2Setting = loadTSChannelSettings.getInt("SRB2");
                int srb1Setting = loadTSChannelSettings.getInt("SRB1");
                println("Ch " + channel + ", " +
                    channelsActiveArray[active] + ", " +
                    gainSettingsArray[gainSetting] + ", " +
                    inputTypeArray[inputType] + ", " +
                    biasIncludeArray[biasSetting] + ", " +
                    srb2SettingArray[srb2Setting] + ", " +
                    srb1SettingArray[srb1Setting]);

                //Use channelSettingValues variable to store these settings once they are loaded from JSON file. Update occurs in hwSettingsController
                channelSettingValues[i][0] = (char)(active + '0');
                if (active == 0) {
                    if (eegDataSource == DATASOURCE_GANGLION) {
                        activateChannel(channel);// power down == false, set color to vibrant
                    }
                    w_timeSeries.channelBars[i].isOn = true;
                    w_timeSeries.channelBars[i].onOffButton.setColorNotPressed(channelColors[(channel)%8]);
                } else {
                    if (eegDataSource == DATASOURCE_GANGLION) {
                        deactivateChannel(channel); // power down == true, set color to dark gray, indicating power down
                    }
                    w_timeSeries.channelBars[i].isOn = false; // deactivate it
                    w_timeSeries.channelBars[i].onOffButton.setColorNotPressed(color(50));
                }
                //Set gain
                channelSettingValues[i][1] = (char)(gainSetting + '0');  //Convert int to char by adding the gainSetting to ASCII char '0'
                //Set inputType
                channelSettingValues[i][2] = (char)(inputType + '0');
                //Set Bias
                channelSettingValues[i][3] = (char)(biasSetting + '0');
                //Set SRB2
                channelSettingValues[i][4] = (char)(srb2Setting + '0');
                //Set SRB1
                channelSettingValues[i][5] = (char)(srb1Setting + '0');
            } //end case for all channels

            loadErrorTimerStart = millis();
            for (int i = 0; i < slnchan; i++) { //For all time series channels...
                try {
                    cyton.writeChannelSettings(i, channelSettingValues); //Write the channel settings to the board!
                } catch (RuntimeException e) {
                    verbosePrint("Runtime Error when trying to write channel settings to cyton...");
                }
                if (checkForSuccessTS > 0) { // If we receive a return code...
                    println("Return code: " + checkForSuccessTS);
                    //when successful, iterate to next channel(i++) and set Check to null
                    if (checkForSuccessTS == RESP_SUCCESS) {
                        // i++;
                        checkForSuccessTS = 0;
                    }

                    //This catches the error when there is difficulty connecting to Cyton. Tested by using dongle with Cyton turned off!
                    int timeElapsed = millis() - loadErrorTimerStart;
                    if (timeElapsed >= loadErrorTimeWindow) { //If the time window (3.8 seconds) has elapsed...
                        println("FAILED TO APPLY SETTINGS TO CYTON WITHIN TIME WINDOW. STOPPING SYSTEM.");
                        loadErrorCytonEvent = true; //Set true because an error has occured
                        haltSystem(); //Halt the system to stop the initialization process
                        return;
                    }
                }
                //delay(10);// Works on 8 chan sometimes
                delay(250); // Works on 8 and 16 channels 3/3 trials applying settings to all channels.
                //Tested by setting gain 1x and loading 24x.
            }
            loadErrorCytonEvent = false;
        } //end Cyton case

        //////////Case for loading Time Series settings when in Ganglion, Synthetic, or Playback data mode
        if (eegDataSource == DATASOURCE_SYNTHETIC || eegDataSource == DATASOURCE_PLAYBACKFILE || eegDataSource == DATASOURCE_GANGLION) {
            //get the channel settings first for only the number of channels being used
            if (eegDataSource == DATASOURCE_GANGLION) numChanloaded = 4;
            for (int i = 0; i < numChanloaded; i++) {
                JSONObject loadTSChannelSettings = loadTimeSeriesJSONArray.getJSONObject(i);
                //int channel = loadTSChannelSettings.getInt("Channel_Number") - 1; //when using with channelSettingsValues, will need to subtract 1
                int active = loadTSChannelSettings.getInt("Active");
                //println("Ch " + channel + ", " + channelsActiveArray[active]);
                if (active == 1) {
                    if (eegDataSource == DATASOURCE_GANGLION) { //if using Ganglion, send the appropriate command to the hub to activate a channel
                        println("Ganglion: loadApplyChannelSettings(): activate: sending " + command_activate_channel[i]);
                        hub.sendCommand(command_activate_channel[i]);
                        w_timeSeries.hsc.powerUpChannel(i);
                    }
                    w_timeSeries.channelBars[i].isOn = true;
                    channelSettingValues[i][0] = '0';
                    w_timeSeries.channelBars[i].onOffButton.setColorNotPressed(channelColors[(i)%8]);
                } else {
                    if (eegDataSource == DATASOURCE_GANGLION) { //if using Ganglion, send the appropriate command to the hub to activate a channel
                        println("Ganglion: loadApplyChannelSettings(): deactivate: sending " + command_deactivate_channel[i]);
                        hub.sendCommand(command_deactivate_channel[i]);
                        w_timeSeries.hsc.powerDownChannel(i);
                    }
                    w_timeSeries.channelBars[i].isOn = false; // deactivate it
                    channelSettingValues[i][0] = '1';
                    w_timeSeries.channelBars[i].onOffButton.setColorNotPressed(color(50));
                }
            }
        } //end of Ganglion/Playback/Synthetic case
    } //end loadApplyTimeSeriesSettings

    /**
      * @description Used in TopNav when user clicks ClearSettings->AreYouSure->Yes
      * @params none
      * Output Success message to bottom of GUI when done
      */
    public void clearAll() {
        for (File file: new File(settingsPath).listFiles())
            if (!file.isDirectory())
                file.delete();
        controlPanel.recentPlaybackBox.cp5_recentPlayback_dropdown.get(ScrollableList.class, "recentFiles").clear();
        controlPanel.recentPlaybackBox.shortFileNames.clear();
        controlPanel.recentPlaybackBox.longFilePaths.clear();
        outputSuccess("All settings have been cleared!");
    }

    /**
      * @description Used in System Init, TopNav, and Interactivity
      * @params mode="User"or"Default", dataSource, and number of channels
      * @returns {String} - filePath or Error if mode not specified correctly
      */
    public String getPath(String _mode, int dataSource, int _nchan) {
        String filePath = settingsPath;
        String[] fileNames = new String[7];
        if (_mode.equals("Default")) {
            fileNames = defaultSettingsFiles;
        } else if (_mode.equals("User")) {
            fileNames = userSettingsFiles;
        } else {
            filePath = "Error";
        }
        if (!filePath.equals("Error")) {
            if (dataSource == DATASOURCE_CYTON) {
                filePath += (_nchan == NCHAN_CYTON) ?
                    fileNames[0] :
                    fileNames[1];
            } else if (dataSource == DATASOURCE_GANGLION) {
                filePath += fileNames[2];
            } else if (dataSource ==  DATASOURCE_PLAYBACKFILE) {
                filePath += fileNames[3];
            } else if (dataSource == DATASOURCE_SYNTHETIC) {
                if (_nchan == NCHAN_GANGLION) {
                    filePath += fileNames[4];
                } else if (_nchan == NCHAN_CYTON) {
                    filePath += fileNames[5];
                } else {
                    filePath += fileNames[6];
                }
            }
        }
        return filePath;
    }

    public void initCheckPointFive() {
        //Prepare the data mode and version, if needed, to be printed at init checkpoint 5 below
        String firmwareToPrint = "";
        String dataModeVersionToPrint = controlEventDataSource;
        if (eegDataSource == DATASOURCE_CYTON) {
            if (!settings.loadErrorCytonEvent) {
                firmwareToPrint = " " + hub.firmwareVersion + ")";
            } else {
                firmwareToPrint = "v.?)";
            }
            dataModeVersionToPrint = controlEventDataSource.replace(")", " ");
            dataModeVersionToPrint += firmwareToPrint;
        }

        //Output messages when Loading settings is complete
        if (chanNumError == false
            && dataSourceError == false
            && errorUserSettingsNotFound == false
            && loadErrorCytonEvent == false) {
                verbosePrint("OpenBCI_GUI: initSystem: -- Init 5 -- " + "Settings Loaded! " + millis()); //Print success to console
                if (eegDataSource == DATASOURCE_SYNTHETIC || eegDataSource == DATASOURCE_PLAYBACKFILE) {
                    outputSuccess("Settings Loaded!"); //Show success message for loading User Settings
                }
        } else if (chanNumError) {
            verbosePrint("OpenBCI_GUI: initSystem: -- Init 5 -- " + "Load settings error: Invalid number of channels in JSON " + millis()); //Print the error to console
            output("The new data source is " + dataModeVersionToPrint + " and NCHAN = [" + nchan + "]. Channel number error: Default Settings Loaded."); //Show a normal message for loading Default Settings
        } else if (dataSourceError) {
            verbosePrint("OpenBCI_GUI: initSystem: -- Init 5 -- " + "Load settings error: Invalid data source " + millis()); //Print the error to console
            output("The new data source is " + dataModeVersionToPrint + " and NCHAN = [" + nchan + "]. Data source error: Default Settings Loaded."); //Show a normal message for loading Default Settings
        } else if (errorUserSettingsNotFound) {
            verbosePrint("OpenBCI_GUI: initSystem: -- Init 5 -- " + "Load settings error: File not found. " + millis()); //Print the error to console
            output("The new data source is " + dataModeVersionToPrint + " and NCHAN = [" + nchan + "]. User Settings Error: Default Settings Loaded."); //Show a normal message for loading Default Settings
        } else {
            verbosePrint("OpenBCI_GUI: initSystem: -- Init 5 -- " + "Load settings error: Connection Error: Failed to apply channel settings to Cyton" + millis()); //Print the error to console
            outputError(dataModeVersionToPrint + " and NCHAN = [" + nchan + "]. Connection Error: Channel settings failed to apply to Cyton."); //Show a normal message for loading Default Settings
        }
        //At this point, either User or Default settings have been Loaded. Use this var to keep track of this.
        settingsLoaded = true;
    }

    public void loadKeyPressed() {
        loadErrorTimerStart = millis();
        String settingsFileToLoad = getPath("User", eegDataSource, nchan);
        try {
            load(settingsFileToLoad);
            errorUserSettingsNotFound = false;
        } catch (Exception e) {
            //println(e.getMessage());
            println(settingsFileToLoad + " not found or other error. Save settings with keyboard 'n' or using dropdown menu.");
            errorUserSettingsNotFound = true;
        }
        //Output message when Loading settings is complete
        String err = null;
        if (chanNumError == false && dataSourceError == false && errorUserSettingsNotFound == false && loadErrorCytonEvent == false) {
            outputSuccess("Settings Loaded!");
        } else if (chanNumError) {
            err = "Invalid number of channels";
        } else if (dataSourceError) {
            err = "Invalid data source";
        } else if (errorUserSettingsNotFound) {
            err = settingsFileToLoad + " not found.";
        }

        //Only try to delete file for SettingsNotFound/Broken settings
        if (err != null && (!chanNumError && !dataSourceError)) {
            println("Load Settings Error: " + err);
            File f = new File(settingsFileToLoad);
            if (f.exists()) {
                if (f.delete()) {
                    outputError("Found old/broken GUI settings. Please reconfigure the GUI and save new settings.");
                } else {
                    outputError("SoftwareSettings: Error deleting old/broken settings file...");
                }
            }
        }
    }

    public void saveButtonPressed() {
        if (saveDialogName == null) {
            selectOutput("Save a custom settings file as JSON:",
                        "saveConfigFile",
                        dataFile(settings.getPath("User", eegDataSource, nchan)));
        } else {
            println("saveSettingsFileName = " + saveDialogName);
            saveDialogName = null;
        }
    }

    public void loadButtonPressed() {
        //Select file to load from dialog box
        if (loadDialogName == null) {
            selectInput("Load a custom settings file from JSON:", "loadConfigFile");
            saveDialogName = null;
        } else {
            println("loadSettingsFileName = " + loadDialogName);
            loadDialogName = null;
        }
    }

    public void defaultButtonPressed() {
        //Revert GUI to default settings that were flashed on system start!
        String defaultSettingsFileToLoad = getPath("Default", eegDataSource, nchan);
        try {
            //Load all saved User Settings from a JSON file to see if it exists
            JSONObject loadDefaultSettingsJSONData = loadJSONObject(defaultSettingsFileToLoad);
            this.load(defaultSettingsFileToLoad);
            outputSuccess("Default Settings Loaded!");
        } catch (Exception e) {
            outputError("Default Settings Error: Valid Default Settings will be saved next system start.");
            File f = new File(defaultSettingsFileToLoad);
            if (f.exists()) {
                if (f.delete()) {
                    println("SoftwareSettings: Old/Broken Default Settings file succesfully deleted.");
                } else {
                    println("SoftwareSettings: Error deleting Default Settings file...");
                }
            }
        }
    }

    
} //end of Software Settings class

public void imposeMinimumGUIDimensions() {
    //impose minimum gui dimensions
    if (width < settings.minGUIWidth || height < settings.minGUIHeight) {
        if (width < settings.minGUIWidth) win_x = settings.minGUIWidth;
        if (height < settings.minGUIHeight) win_y = settings.minGUIHeight;
        surface.setSize(win_x, win_y);
    }
}


//////////////////////////////////////////
//  Global Functions                    //
// Called by Buttons with the same name //
//////////////////////////////////////////
// Select file to save custom settings using dropdown in TopNav.pde
public void saveConfigFile(File selection) {
    if (selection == null) {
        println("SoftwareSettings: saveConfigFile: Window was closed or the user hit cancel.");
    } else {
        println("SoftwareSettings: saveConfigFile: User selected " + selection.getAbsolutePath());
        settings.saveDialogName = selection.getAbsolutePath();
        settings.save(settings.saveDialogName); //save current settings to JSON file in SavedData
        outputSuccess("Settings Saved! The GUI will now load with these settings. Click \"Default\" to revert to factory settings."); //print success message to screen
        settings.saveDialogName = null; //reset this variable for future use
    }
}
// Select file to load custom settings using dropdown in TopNav.pde
public void loadConfigFile(File selection) {
    if (selection == null) {
        println("SoftwareSettings: loadConfigFile: Window was closed or the user hit cancel.");
    } else {
        println("SoftwareSettings: loadConfigFile: User selected " + selection.getAbsolutePath());
        //output("You have selected \"" + selection.getAbsolutePath() + "\" to Load custom settings.");
        settings.loadDialogName = selection.getAbsolutePath();
        try {
            settings.load(settings.loadDialogName); //load settings from JSON file in /data/
            //Output success message when Loading settings is complete without errors
            if (settings.chanNumError == false
                && settings.dataSourceError == false
                && settings.loadErrorCytonEvent == false) {
                    outputSuccess("Settings Loaded!");
                }
        } catch (Exception e) {
            println("SoftwareSettings: Incompatible settings file or other error");
            if (settings.chanNumError == true) {
                outputError("Settings Error:  Channel Number Mismatch Detected");
            } else if (settings.dataSourceError == true) {
                outputError("Settings Error: Data Source Mismatch Detected");
            } else {
                outputError("Error trying to load settings file, possibly from previous GUI. Removing old settings.");
                if (selection.exists()) selection.delete();
            }
        }
        settings.loadDialogName = null; //reset this variable for future use
    }
}
///////////////////////////////////////////////////////////////////////////////////////
//
//  Created by Conor Russomanno, 11/3/16
//  Extracting old code Gui_Manager.pde, adding new features for GUI v2 launch
//
//  Edited by Richard Waltman 9/24/18
//  Added feature to check GUI version using "latest version" tag on Github
///////////////////////////////////////////////////////////////////////////////////////





int navBarHeight = 32;
TopNav topNav;

class TopNav {

    Button controlPanelCollapser;
    Button fpsButton;
    Button debugButton;

    Button stopButton;

    Button filtBPButton;
    Button filtNotchButton;

    Button tutorialsButton;
    Button shopButton;
    Button issuesButton;
    Button updateGuiVersionButton;
    Button layoutButton;
    Button configButton;

    LayoutSelector layoutSelector;
    TutorialSelector tutorialSelector;
    ConfigSelector configSelector;
    int previousSystemMode = 0;

    String webGUIVersionString;
    int webGUIVersionInt;
    int localGUIVersionInt;
    Boolean guiVersionIsUpToDate;
    Boolean internetIsConnected;

    //constructor
    TopNav() {
        int w = 256;
        controlPanelCollapser = new Button(3, 3, w, 26, "System Control Panel", fontInfo.buttonLabel_size);
        controlPanelCollapser.setFont(h3, 16);
        controlPanelCollapser.setIsActive(true);
        controlPanelCollapser.isDropdownButton = true;

        fpsButton = new Button(controlPanelCollapser.but_x + controlPanelCollapser.but_dx + 3, 3, 73, 26, "XX" + " fps", fontInfo.buttonLabel_size);
        if (frameRateCounter==0) {
            fpsButton.setString("24 fps");
        }
        if (frameRateCounter==1) {
            fpsButton.setString("30 fps");
        }
        if (frameRateCounter==2) {
            fpsButton.setString("45 fps");
        }
        if (frameRateCounter==3) {
            fpsButton.setString("60 fps");
        }

        fpsButton.setFont(h3, 16);
        fpsButton.setHelpText("If you're having latency issues, try adjusting the frame rate and see if it helps!");
        //highRezButton = new Button(3+3+w+73+3, 3, 26, 26, "XX", fontInfo.buttonLabel_size);
        controlPanelCollapser.setFont(h3, 16);

        //top right buttons from right to left
        debugButton = new Button(width - 33 - 3, 3, 33, 26, " ", fontInfo.buttonLabel_size);
        debugButton.setHelpText("Click to open the Console Log window.");

        tutorialsButton = new Button(debugButton.but_x - 80 - 3, 3, 80, 26, "Help", fontInfo.buttonLabel_size);
        tutorialsButton.setFont(h3, 16);
        tutorialsButton.setHelpText("Click to find links to helpful online tutorials and getting started guides. Also, check out how to create custom widgets for the GUI!");

        issuesButton = new Button(tutorialsButton.but_x - 80 - 3, 3, 80, 26, "Issues", fontInfo.buttonLabel_size);
        issuesButton.setHelpText("If you have suggestions or want to share a bug you've found, please create an issue on the GUI's Github repo!");
        issuesButton.setURL("https://github.com/OpenBCI/OpenBCI_GUI/issues");
        issuesButton.setFont(h3, 16);

        shopButton = new Button(issuesButton.but_x - 80 - 3, 3, 80, 26, "Shop", fontInfo.buttonLabel_size);
        shopButton.setHelpText("Head to our online store to purchase the latest OpenBCI hardware and accessories.");
        shopButton.setURL("http://shop.openbci.com/");
        shopButton.setFont(h3, 16);

        configButton = new Button(width - 70 - 3, 35, 70, 26, "Settings", fontInfo.buttonLabel_size);
        configButton.setHelpText("Save and Load GUI Settings! Click Default to revert to factory settings.");
        configButton.setFont(h4, 14);

        //Lookup and check the local GUI version against the latest Github release
        updateGuiVersionButton = new Button(shopButton.but_x - 80 - 3, 3, 80, 26, "Update", fontInfo.buttonLabel_size);
        updateGuiVersionButton.setFont(h3, 16);
        
        checkInternetFetchGithubData();

        layoutSelector = new LayoutSelector();
        tutorialSelector = new TutorialSelector();
        configSelector = new ConfigSelector();

        updateNavButtonsBasedOnColorScheme();
    }

    public void initSecondaryNav() {
        stopButton = new Button(3, 35, 170, 26, stopButton_pressToStart_txt, fontInfo.buttonLabel_size);
        stopButton.setFont(h4, 14);
        stopButton.setColorNotPressed(color(184, 220, 105));
        stopButton.setHelpText("Press this button to Stop/Start the data stream. Or press <SPACEBAR>");

        filtNotchButton = new Button(7 + stopButton.but_dx, 35, 70, 26, "Notch\n" + dataProcessing.getShortNotchDescription(), fontInfo.buttonLabel_size);
        filtNotchButton.setFont(p5, 12);
        filtNotchButton.setHelpText("Here you can adjust the Notch Filter that is applied to all \"Filtered\" data.");

        filtBPButton = new Button(11 + stopButton.but_dx + 70, 35, 70, 26, "BP Filt\n" + dataProcessing.getShortFilterDescription(), fontInfo.buttonLabel_size);
        filtBPButton.setFont(p5, 12);
        filtBPButton.setHelpText("Here you can adjust the Band Pass Filter that is applied to all \"Filtered\" data.");

        //right to left in top right (secondary nav)
        layoutButton = new Button(width - 3 - 60, 35, 60, 26, "Layout", fontInfo.buttonLabel_size);
        layoutButton.setHelpText("Here you can alter the overall layout of the GUI, allowing for different container configurations with more or less widgets.");
        layoutButton.setFont(h4, 14);

        updateSecondaryNavButtonsColor();
    }

    public void updateNavButtonsBasedOnColorScheme() {
        if (colorScheme == COLOR_SCHEME_DEFAULT) {
            controlPanelCollapser.setColorNotPressed(color(255));
            fpsButton.setColorNotPressed(color(255));
            debugButton.setColorNotPressed(color(255));
            //highRezButton.setColorNotPressed(color(255));
            issuesButton.setColorNotPressed(color(255));
            shopButton.setColorNotPressed(color(255));
            tutorialsButton.setColorNotPressed(color(255));
            updateGuiVersionButton.setColorNotPressed(color(255));
            configButton.setColorNotPressed(color(255));

            controlPanelCollapser.textColorNotActive = color(bgColor);
            fpsButton.textColorNotActive = color(bgColor);
            debugButton.textColorNotActive = color(bgColor);
            //highRezButton.textColorNotActive = color(bgColor);
            issuesButton.textColorNotActive = color(bgColor);
            shopButton.textColorNotActive = color(bgColor);
            tutorialsButton.textColorNotActive = color(bgColor);
            updateGuiVersionButton.textColorNotActive = color(bgColor);
            configButton.textColorNotActive = color(bgColor);
        } else if (colorScheme == COLOR_SCHEME_ALTERNATIVE_A) {
            controlPanelCollapser.setColorNotPressed(openbciBlue);
            fpsButton.setColorNotPressed(openbciBlue);
            debugButton.setColorNotPressed(openbciBlue);
            //highRezButton.setColorNotPressed(openbciBlue);
            issuesButton.setColorNotPressed(openbciBlue);
            shopButton.setColorNotPressed(openbciBlue);
            tutorialsButton.setColorNotPressed(openbciBlue);
            updateGuiVersionButton.setColorNotPressed(openbciBlue);
            configButton.setColorNotPressed(color(57, 128, 204));

            controlPanelCollapser.textColorNotActive = color(255);
            fpsButton.textColorNotActive = color(255);
            debugButton.textColorNotActive = color(255);
            //highRezButton.textColorNotActive = color(255);
            issuesButton.textColorNotActive = color(255);
            shopButton.textColorNotActive = color(255);
            tutorialsButton.textColorNotActive = color(255);
            updateGuiVersionButton.textColorNotActive = color(255);
            configButton.textColorNotActive = color(255);
        }

        if (systemMode >= SYSTEMMODE_POSTINIT) {
            updateSecondaryNavButtonsColor();
        }
    }

    public void updateSecondaryNavButtonsColor() {
        if (colorScheme == COLOR_SCHEME_DEFAULT) {
            filtBPButton.setColorNotPressed(color(255));
            filtNotchButton.setColorNotPressed(color(255));
            layoutButton.setColorNotPressed(color(255));

            filtBPButton.textColorNotActive = color(bgColor);
            filtNotchButton.textColorNotActive = color(bgColor);
            layoutButton.textColorNotActive = color(bgColor);
        } else if (colorScheme == COLOR_SCHEME_ALTERNATIVE_A) {
            filtBPButton.setColorNotPressed(color(57, 128, 204));
            filtNotchButton.setColorNotPressed(color(57, 128, 204));
            layoutButton.setColorNotPressed(color(57, 128, 204));

            filtBPButton.textColorNotActive = color(255);
            filtNotchButton.textColorNotActive = color(255);
            layoutButton.textColorNotActive = color(255);
        }
    }

    public void update() {
        //ignore settings button when help dropdown is open
        if (tutorialSelector.isVisible) {
            configButton.setIgnoreHover(true);
        } else {
            configButton.setIgnoreHover(false);
        }

        if (previousSystemMode != systemMode) {
            if (systemMode >= SYSTEMMODE_POSTINIT) {
                layoutSelector.update();
                tutorialSelector.update();
                if (configButton.but_x != width - (70*2) + 3) {
                    configButton.but_x = width - (70*2) + 3;
                    verbosePrint("TopNav: Updated Settings Button Position");
                }
            } else {
                if (configButton.but_x != width - 70 - 3) {
                    configButton.but_x = width - 70 - 3;
                    verbosePrint("TopNav: Updated Settings Button Position");
                }
            }
            configSelector.update();
            previousSystemMode = systemMode;
        }
    }

    public void draw() {
        pushStyle();

        if (colorScheme == COLOR_SCHEME_DEFAULT) {
            noStroke();
            fill(229);
            rect(0, 0, width, topNav_h);
            stroke(bgColor);
            fill(255);
            rect(-1, 0, width+2, navBarHeight);
            //hide the center logo if buttons would overlap it
            if (width > 860) {
                //this is the center logo
                image(logo_blue, width/2 - (128/2) - 2, 6, 128, 22);
            }
        } else if (colorScheme == COLOR_SCHEME_ALTERNATIVE_A) {
            noStroke();
            fill(100);
            fill(57, 128, 204);
            rect(0, 0, width, topNav_h);
            stroke(bgColor);
            fill(31, 69, 110);
            rect(-1, 0, width+2, navBarHeight);
            //hide the center logo if buttons would overlap it
            if (width > 860) {
                //this is the center logo
                image(logo_white, width/2 - (128/2) - 2, 6, 128, 22);
            }
        }

        popStyle();

        if (systemMode == SYSTEMMODE_POSTINIT) {
            stopButton.draw();
            filtBPButton.draw();
            filtNotchButton.draw();
            layoutButton.draw();
        }

        controlPanelCollapser.draw();
        fpsButton.draw();
        debugButton.draw();
        configButton.draw();
        if (colorScheme == COLOR_SCHEME_DEFAULT) {
            image(consoleImgBlue, debugButton.but_x + 6, debugButton.but_y + 2, 22, 22);
        } else {
            image(consoleImgWhite, debugButton.but_x + 6, debugButton.but_y + 2, 22, 22);
        }
        tutorialsButton.draw();
        issuesButton.draw();
        shopButton.draw();
        updateGuiVersionButton.draw();

        layoutSelector.draw();
        tutorialSelector.draw();
        configSelector.draw();
    }

    public void screenHasBeenResized(int _x, int _y) {
        debugButton.but_x = width - debugButton.but_dx - 3;
        tutorialsButton.but_x = debugButton.but_x - 80 - 3;
        issuesButton.but_x = tutorialsButton.but_x - 80 - 3;
        shopButton.but_x = issuesButton.but_x - 80 - 3;
        updateGuiVersionButton.but_x = shopButton.but_x - 80 - 3;
        configButton.but_x = width - configButton.but_dx - 3;

        if (systemMode == SYSTEMMODE_POSTINIT) {
            layoutButton.but_x = width - 3 - layoutButton.but_dx;
            configButton.but_x = width - (configButton.but_dx*2) + 3;
            layoutSelector.screenResized();     //pass screenResized along to layoutSelector
            tutorialSelector.screenResized();
        }
        configSelector.screenResized();
    }

    public void mousePressed() {
        if (systemMode >= SYSTEMMODE_POSTINIT) {
            if (stopButton.isMouseHere()) {
                stopButton.setIsActive(true);
                stopButtonWasPressed();
            }
            if (filtBPButton.isMouseHere()) {
                filtBPButton.setIsActive(true);
                incrementFilterConfiguration();
            }
            if (topNav.filtNotchButton.isMouseHere()) {
                filtNotchButton.setIsActive(true);
                incrementNotchConfiguration();
            }
            if (layoutButton.isMouseHere()) {
                layoutButton.setIsActive(true);
                //toggle layout window to enable the selection of your container layoutButton...
            }
        }

        //was control panel button pushed
        if (controlPanelCollapser.isMouseHere()) {
            if (controlPanelCollapser.isActive && systemMode == SYSTEMMODE_POSTINIT) {
                controlPanelCollapser.setIsActive(false);
                controlPanel.close();
            } else {
                controlPanelCollapser.setIsActive(true);
                // controlPanelCollapser.setIsActive(false);
                controlPanel.open();
            }
        } else {
            if (controlPanel.isOpen) {
                controlPanel.CPmousePressed();
            }
        }

        //this is super hacky... but needs to be done otherwise... the controlPanelCollapser doesn't match the open control panel
        if (controlPanel.isOpen) {
            controlPanelCollapser.setIsActive(true);
        }

        if (fpsButton.isMouseHere()) {
            fpsButton.setIsActive(true);
        }

        if (debugButton.isMouseHere()) {
            debugButton.setIsActive(true);
        }

        if (tutorialsButton.isMouseHere()) {
            tutorialsButton.setIsActive(true);
            //toggle help/tutorial dropdown menu
        }
        if (issuesButton.isMouseHere()) {
            issuesButton.setIsActive(true);
            //toggle help/tutorial dropdown menu
        }
        if (shopButton.isMouseHere()) {
            shopButton.setIsActive(true);
            //toggle help/tutorial dropdown menu
        }
        if (updateGuiVersionButton.isMouseHere() && !guiVersionIsUpToDate && internetIsConnected) {
            updateGuiVersionButton.setIsActive(true);
            //toggle help/tutorial dropdown menu
        }
        if (configButton.isMouseHere()) {
            configButton.setIsActive(true);
            //toggle save/load window
        }


        layoutSelector.mousePressed();     //pass mousePressed along to layoutSelector
        tutorialSelector.mousePressed();
        configSelector.mousePressed();
    }

    public void mouseReleased() {

        if (fpsButton.isMouseHere() && fpsButton.isActive()) {
            toggleFrameRate();
        }
        if (debugButton.isMouseHere() && debugButton.isActive()) {
            thread("openConsole");
        }

        if (tutorialsButton.isMouseHere() && tutorialsButton.isActive()) {
            tutorialSelector.toggleVisibility();
            tutorialsButton.setIsActive(true);
        }

        if (issuesButton.isMouseHere() && issuesButton.isActive()) {
            //go to Github issues
            issuesButton.goToURL();
        }

        if (shopButton.isMouseHere() && shopButton.isActive()) {
            //go to OpenBCI Shop
            shopButton.goToURL();
        }

        if (updateGuiVersionButton.isMouseHere() && updateGuiVersionButton.isActive()) {
            //go to OpenBCI Shop
            updateGuiVersionButton.goToURL();
        }

        //make Help button and Settings button mutually exclusive
        if (!tutorialSelector.isVisible && configButton.isMouseHere() && configButton.isActive()) {
            configSelector.toggleVisibility();
            configButton.setIsActive(true);
        }

        if (systemMode == SYSTEMMODE_POSTINIT) {
            if (!tutorialSelector.isVisible) { //make sure that you can't open the layout selector accidentally
                if (layoutButton.isMouseHere() && layoutButton.isActive()) {
                    layoutSelector.toggleVisibility();
                    layoutButton.setIsActive(true);
                    //wm.printLayouts(); //Used for debugging
                    println("TopNav: Layout Dropdown Opened");
                }
            }
            stopButton.setIsActive(false);
            filtBPButton.setIsActive(false);
            filtNotchButton.setIsActive(false);
            layoutButton.setIsActive(false);
        }

        fpsButton.setIsActive(false);
        debugButton.setIsActive(false);
        //highRezButton.setIsActive(false);
        tutorialsButton.setIsActive(false);
        issuesButton.setIsActive(false);
        shopButton.setIsActive(false);
        updateGuiVersionButton.setIsActive(false);
        configButton.setIsActive(false);


        layoutSelector.mouseReleased();    //pass mouseReleased along to layoutSelector
        tutorialSelector.mouseReleased();
        configSelector.mouseReleased();
    } //end mouseReleased

    //Load data from the latest release page from Github and the info.plist file
    public void loadGUIVersionData() {
        try {
            Process process = java.lang.Runtime.getRuntime().exec("ping -c 1 www.github.com"); 
            internetIsConnected = (process.waitFor() == 0) ? true : false;
        } catch (Exception e) {
            println("TopNav::loadGUIVersionData: Exception " + e.getMessage());
        }

        if (internetIsConnected) {
            println("TopNav: Internet Connection Successful");
            //Get the latest release version from Github
            String webTitle;
            String[] version;
            String[] lines = loadStrings(guiLatestReleaseLocation);
            String html = join(lines, "");
            String start = "<title>";
            String end = "</title>";
            webTitle = giveMeTextBetween(html, start, end);
            version = split(webTitle, '·'); //split the string in the html title
            String[] webVersionNumberArray = split(version[0], ' ');

            webGUIVersionString = removeV(webVersionNumberArray[1]);
            webGUIVersionString = removeAlphaBeta(webGUIVersionString);

            //Copy the local GUI version from OpenBCI_GUI.pde
            String localVersionString = localGUIVersionString;
            localVersionString = removeV(localVersionString);
            localVersionString = removeAlphaBeta(localVersionString);

            ///////Perform Comparison (000-1000 format)
            int[] webVersionCompareArray = PApplet.parseInt(split(webGUIVersionString, '.'));
            int[] localVersionCompareArray = PApplet.parseInt(split(localVersionString, '.'));
            webGUIVersionInt = webVersionCompareArray[0]*100 + webVersionCompareArray[1]*10 + webVersionCompareArray[2];
            localGUIVersionInt = localVersionCompareArray[0]*100 + localVersionCompareArray[1]*10 + localVersionCompareArray[2];
            println("Local Version: " + localGUIVersionInt + ", Latest Version: " + webGUIVersionInt);
            if (localGUIVersionInt < webGUIVersionInt) {
                guiVersionIsUpToDate = false;
                println("GUI needs to be updated. Download at https://github.com/OpenBCI/OpenBCI_GUI/releases/latest");
            } else if (localGUIVersionInt >= webGUIVersionInt) {
                guiVersionIsUpToDate = true;
                println("GUI is up to date!");
            }
        } else {
            println("TopNav: Internet Connection Not Available");
        }
    }

    // This function returns a substring between two substrings (before and after).
    public String giveMeTextBetween(String s, String before, String after) {
        // Find the index of before
        int start = s.indexOf(before);
        if (start == -1) {
            return "";
        }

        // Move to the end of the beginning tag
        // and find the index of the "after" String
        start += before.length();
        int end = s.indexOf(after, start);
        if (end == -1) {
            return "";
        }

        // Return the text in between
        return s.substring(start, end);
    }

    public String removeV(String s) {
        if (s.charAt(0) == 'v') {
            String[] tempArr = split(s, 'v');
            s = tempArr[1];
        }
        return s;
    }

    public String removeAlphaBeta(String s) {
        if (s.length() > 5) {
            String[] tempArr = split(s, '-');
            s = tempArr[0];
        }
        return s;
    }

    public void checkInternetFetchGithubData() {
        try {
            loadGUIVersionData();
            //Print the message to the button help text that appears when mouse hovers over button
            if (!guiVersionCheckHasOccured && internetIsConnected) {
                if (guiVersionIsUpToDate) {
                    updateGuiVersionButton.setHelpText("GUI is up to date! -- Local: " + localGUIVersionString +  " GitHub: v" + webGUIVersionString);
                } else {
                    updateGuiVersionButton.setHelpText("GUI needs to be updated. -- Local: " + localGUIVersionString +  " GitHub: v" + webGUIVersionString);
                }
                //Pressing the button opens web browser to Github latest release page
                updateGuiVersionButton.setURL(guiLatestReleaseLocation);
                guiVersionCheckHasOccured = true;
            } else {
                guiVersionIsUpToDate = true;
                updateGuiVersionButton.setHelpText("Connect to internet to check GUI version.-- Local: " + localGUIVersionString);
            }
            
        } catch (NullPointerException e)  {
            //e.printStackTrace();
            //If github is unreachable, catch the error update button help text
            updateGuiVersionButton.setHelpText("Connect to internet to check GUI version. -- Local: " + localGUIVersionString);
        }
    }
}

//=============== OLD STUFF FROM Gui_Manger.pde ===============//

public void incrementFilterConfiguration() {
    dataProcessing.incrementFilterConfiguration();

    //update the button strings
    topNav.filtBPButton.but_txt = "BP Filt\n" + dataProcessing.getShortFilterDescription();
    // topNav.titleMontage.string = "EEG Data (" + dataProcessing.getFilterDescription() + ")";
}

public void incrementNotchConfiguration() {
    dataProcessing.incrementNotchConfiguration();

    //update the button strings
    topNav.filtNotchButton.but_txt = "Notch\n" + dataProcessing.getShortNotchDescription();
    // topNav.titleMontage.string = "EEG Data (" + dataProcessing.getFilterDescription() + ")";
}

class LayoutSelector {

    int x, y, w, h, margin, b_w, b_h;
    boolean isVisible;

    ArrayList<Button> layoutOptions; //

    LayoutSelector() {
        w = 180;
        x = width - w - 3;
        y = (navBarHeight * 2) - 3;
        margin = 6;
        b_w = (w - 5*margin)/4;
        b_h = b_w;
        h = margin*3 + b_h*2;


        isVisible = false;

        layoutOptions = new ArrayList<Button>();
        addLayoutOptionButton();
    }

    public void update() {
        if (isVisible) { //only update if visible
            // //close dropdown when mouse leaves
            // if ((mouseX < x || mouseX > x + w || mouseY < y || mouseY > y + h) && !topNav.layoutButton.isMouseHere()){
            //   toggleVisibility();
            // }
        }
    }

    public void draw() {
        if (isVisible) { //only draw if visible
            pushStyle();

            stroke(bgColor);
            // fill(229); //bg
            fill(57, 128, 204); //bg
            rect(x, y, w, h);

            for (int i = 0; i < layoutOptions.size(); i++) {
                layoutOptions.get(i).draw();
            }

            fill(57, 128, 204);
            // fill(177, 184, 193);
            noStroke();
            rect(x+w-(topNav.layoutButton.but_dx-1), y, (topNav.layoutButton.but_dx-1), 1);

            popStyle();
        }
    }

    public void isMouseHere() {
    }

    public void mousePressed() {
        //only allow button interactivity if isVisible==true
        if (isVisible) {
            for (int i = 0; i < layoutOptions.size(); i++) {
                if (layoutOptions.get(i).isMouseHere()) {
                    layoutOptions.get(i).setIsActive(true);
                }
            }
        }
    }

    public void mouseReleased() {
        //only allow button interactivity if isVisible==true
        if (isVisible) {
            if ((mouseX < x || mouseX > x + w || mouseY < y || mouseY > y + h) && !topNav.layoutButton.isMouseHere()) {
                toggleVisibility();
            }
            for (int i = 0; i < layoutOptions.size(); i++) {
                if (layoutOptions.get(i).isMouseHere() && layoutOptions.get(i).isActive()) {
                    int layoutSelected = i+1;
                    println("Layout [" + layoutSelected + "] selected.");
                    output("Layout [" + layoutSelected + "] selected.");
                    layoutOptions.get(i).setIsActive(false);
                    toggleVisibility(); //shut layoutSelector if something is selected
                    wm.setNewContainerLayout(layoutSelected-1); //have WidgetManager update Layout and active widgets
                    settings.currentLayout = layoutSelected; //copy this value to be used when saving Layout setting
                }
            }
        }
    }

    public void screenResized() {
        //update position of outer box and buttons
        int oldX = x;
        x = width - w - 3;
        int dx = oldX - x;
        for (int i = 0; i < layoutOptions.size(); i++) {
            layoutOptions.get(i).setX(layoutOptions.get(i).but_x - dx);
        }
    }

    public void toggleVisibility() {
        isVisible = !isVisible;
        if (isVisible) {
            //the very convoluted way of locking all controllers of a single controlP5 instance...
            for (int i = 0; i < wm.widgets.size(); i++) {
                for (int j = 0; j < wm.widgets.get(i).cp5_widget.getAll().size(); j++) {
                    wm.widgets.get(i).cp5_widget.getController(wm.widgets.get(i).cp5_widget.getAll().get(j).getAddress()).lock();
                }
            }
        } else {
            //the very convoluted way of unlocking all controllers of a single controlP5 instance...
            for (int i = 0; i < wm.widgets.size(); i++) {
                for (int j = 0; j < wm.widgets.get(i).cp5_widget.getAll().size(); j++) {
                    wm.widgets.get(i).cp5_widget.getController(wm.widgets.get(i).cp5_widget.getAll().get(j).getAddress()).unlock();
                }
            }
        }
    }

    public void addLayoutOptionButton() {

        //FIRST ROW

        //setup button 1 -- full screen
        Button tempLayoutButton = new Button(x + margin, y + margin, b_w, b_h, "N/A");
        PImage tempBackgroundImage = loadImage("layout_buttons/layout_1.png");
        tempLayoutButton.setBackgroundImage(tempBackgroundImage);
        layoutOptions.add(tempLayoutButton);

        //setup button 2 -- 2x2
        tempLayoutButton = new Button(x + 2*margin + b_w*1, y + margin, b_w, b_h, "N/A");
        tempBackgroundImage = loadImage("layout_buttons/layout_2.png");
        tempLayoutButton.setBackgroundImage(tempBackgroundImage);
        layoutOptions.add(tempLayoutButton);

        //setup button 3 -- 2x1
        tempLayoutButton = new Button(x + 3*margin + b_w*2, y + margin, b_w, b_h, "N/A");
        tempBackgroundImage = loadImage("layout_buttons/layout_3.png");
        tempLayoutButton.setBackgroundImage(tempBackgroundImage);
        layoutOptions.add(tempLayoutButton);

        //setup button 4 -- 1x2
        tempLayoutButton = new Button(x + 4*margin + b_w*3, y + margin, b_w, b_h, "N/A");
        tempBackgroundImage = loadImage("layout_buttons/layout_4.png");
        tempLayoutButton.setBackgroundImage(tempBackgroundImage);
        layoutOptions.add(tempLayoutButton);

        //SECOND ROW

        //setup button 5
        tempLayoutButton = new Button(x + margin, y + 2*margin + 1*b_h, b_w, b_h, "N/A");
        tempBackgroundImage = loadImage("layout_buttons/layout_5.png");
        tempLayoutButton.setBackgroundImage(tempBackgroundImage);
        layoutOptions.add(tempLayoutButton);

        //setup button 6
        tempLayoutButton = new Button(x + 2*margin + b_w*1, y + 2*margin + 1*b_h, b_w, b_h, "N/A");
        tempBackgroundImage = loadImage("layout_buttons/layout_6.png");
        tempLayoutButton.setBackgroundImage(tempBackgroundImage);
        layoutOptions.add(tempLayoutButton);

        //setup button 7
        tempLayoutButton = new Button(x + 3*margin + b_w*2, y + 2*margin + 1*b_h, b_w, b_h, "N/A");
        tempBackgroundImage = loadImage("layout_buttons/layout_7.png");
        tempLayoutButton.setBackgroundImage(tempBackgroundImage);
        layoutOptions.add(tempLayoutButton);

        //setup button 8
        tempLayoutButton = new Button(x + 4*margin + b_w*3, y + 2*margin + 1*b_h, b_w, b_h, "N/A");
        tempBackgroundImage = loadImage("layout_buttons/layout_8.png");
        tempLayoutButton.setBackgroundImage(tempBackgroundImage);
        layoutOptions.add(tempLayoutButton);

        //THIRD ROW -- commented until more widgets are added

        h = margin*4 + b_h*3;
        //setup button 9
        tempLayoutButton = new Button(x + margin, y + 3*margin + 2*b_h, b_w, b_h, "N/A");
        tempBackgroundImage = loadImage("layout_buttons/layout_9.png");
        tempLayoutButton.setBackgroundImage(tempBackgroundImage);
        layoutOptions.add(tempLayoutButton);

        //setup button 10
        tempLayoutButton = new Button(x + 2*margin + b_w*1, y + 3*margin + 2*b_h, b_w, b_h, "N/A");
        tempBackgroundImage = loadImage("layout_buttons/layout_10.png");
        tempLayoutButton.setBackgroundImage(tempBackgroundImage);
        layoutOptions.add(tempLayoutButton);

        //setup button 11
        tempLayoutButton = new Button(x + 3*margin + b_w*2, y + 3*margin + 2*b_h, b_w, b_h, "N/A");
        tempBackgroundImage = loadImage("layout_buttons/layout_11.png");
        tempLayoutButton.setBackgroundImage(tempBackgroundImage);
        layoutOptions.add(tempLayoutButton);

        //setup button 12
        tempLayoutButton = new Button(x + 4*margin + b_w*3, y + 3*margin + 2*b_h, b_w, b_h, "N/A");
        tempBackgroundImage = loadImage("layout_buttons/layout_12.png");
        tempLayoutButton.setBackgroundImage(tempBackgroundImage);
        layoutOptions.add(tempLayoutButton);
    }
}

class ConfigSelector {
    int x, y, w, h, margin, b_w, b_h;
    boolean clearAllSettingsPressed;
    boolean isVisible;
    ArrayList<Button> configOptions;
    int configHeight = 0;
    int newGreen = color(114,204,171);
    int expertPurple = color(135,95,154);
    int cautionRed = color(214,100,100);

    int osPadding = 0;
    int osPadding2 = 0;
    int buttonSpacer = 0;

    ConfigSelector() {
        int _padding = (systemMode == SYSTEMMODE_POSTINIT) ? -3 : 3;
        w = 140;
        x = width - w - _padding;
        y = (navBarHeight * 2) - 3;
        margin = 6;
        b_w = w - margin*2;
        b_h = 22;
        h = margin*3 + b_h;
        //makes the setting text "are you sure" display correctly on linux
        osPadding = isLinux() ? -3 : -2;
        osPadding2 = isLinux() ? 5 : 0;

        isVisible = false;

        configOptions = new ArrayList<Button>();
        addConfigButtons();

        buttonSpacer = (systemMode == SYSTEMMODE_POSTINIT) ? configOptions.size() : configOptions.size() - 4;
    }

    public void update() {
        updateConfigButtonPositions();
    }

    public void draw() {
        if (isVisible) { //only draw if visible
            pushStyle();

            stroke(bgColor);
            fill(57, 128, 204); //bg
            rect(x, y, w, h);

            //configOptions.get(0).draw();
            if (systemMode == SYSTEMMODE_POSTINIT) {
                for (int i = 0; i < 4; i++) {
                    configOptions.get(i).draw();
                }
            }
            configOptions.get(4).draw();
            if (clearAllSettingsPressed) {
                int fontSize = 16;
                textFont(p2, fontSize);
                fill(255);
                text("Are You Sure?", x + margin, y + margin*(buttonSpacer + osPadding) + b_h*(buttonSpacer-1) + osPadding2);
                configOptions.get(configOptions.size()-2).draw();
                configOptions.get(configOptions.size()-1).draw();
            }

            fill(57, 128, 204);
            noStroke();
            //This makes the dropdown box look like it's apart of the button by drawing over the bottom edge of the button
            rect(x+w-(topNav.configButton.but_dx-1), y, (topNav.configButton.but_dx-1), 1);

            popStyle();
        }
    }

    public void isMouseHere() {
    }

    public void mousePressed() {
        //only allow button interactivity if isVisible==true
        if (isVisible) {
            for (int i = 0; i < configOptions.size(); i++) {
                //Allow interaction with all settings buttons after init
                if (systemMode == SYSTEMMODE_POSTINIT) {
                    if (i >= 0 && i < 5) {
                        if (configOptions.get(i).isMouseHere()) {
                            configOptions.get(i).setIsActive(true);
                            //println("TopNav: Settings: Button Pressed");
                        }
                    } else if (i == 5 || i == 6){
                        if (configOptions.get(i).isMouseHere() && clearAllSettingsPressed) {
                            configOptions.get(i).setIsActive(true);
                            //println("TopNav: ClearSettings: AreYouSure? Button Pressed");
                        }
                    }
                //Before system start, Only allow interaction with "Expert Mode" and "Clear All"
                } else if (systemMode == SYSTEMMODE_PREINIT) {
                    if (i == 4) {
                        if (configOptions.get(i).isMouseHere()) {
                            configOptions.get(i).setIsActive(true);
                            //println("TopNav: Settings: Clear Settings Pressed");
                        }
                    } else if (i == 5 || i == 6){
                        if (configOptions.get(i).isMouseHere() && clearAllSettingsPressed) {
                            configOptions.get(i).setIsActive(true);
                            //println("TopNav: ClearSettings: AreYouSure? Button Pressed");
                        }
                    }
                }
            }
        }
    }

    public void mouseReleased() {
        //only allow button interactivity if isVisible==true
        if (isVisible) {
            if ((mouseX < x || mouseX > x + w || mouseY < y || mouseY > y + h) && !topNav.configButton.isMouseHere()) {
                toggleVisibility();
                clearAllSettingsPressed = false;
            }
            for (int i = 0; i < configOptions.size(); i++) {
                if (configOptions.get(i).isMouseHere() && configOptions.get(i).isActive()) {
                    int configSelected = i;
                    configOptions.get(i).setIsActive(false);
                    if (configSelected == 0) { //If expert mode toggle button is pressed...
                        if (configOptions.get(0).getButtonText().equals("Turn Expert Mode On")) {
                            configOptions.get(0).setString("Turn Expert Mode Off");
                            configOptions.get(0).setColorNotPressed(expertPurple);
                            println("TopNav: Expert Mode On");
                            output("Expert Mode ON: All keyboard shortcuts and features are enabled!");
                            settings.expertModeToggle = true;
                        } else {
                            configOptions.get(0).setString("Turn Expert Mode On");
                            configOptions.get(0).setColorNotPressed(newGreen);
                            println("TopNav: Expert Mode Off");
                            output("Expert Mode OFF: Use spacebar to start/stop the data stream.");
                            settings.expertModeToggle = false;
                        }
                    } else if (configSelected == 1) { ////Save Button
                        settings.saveButtonPressed();
                    } else if (configSelected == 2) { ////Load Button
                        settings.loadButtonPressed();
                    } else if (configSelected == 3) { ////Default Button
                        settings.defaultButtonPressed();
                    } else if (configSelected == 4) { ///ClearAllSettings Button
                        clearAllSettingsPressed = true;
                        //expand the height of the dropdown
                        h = margin*(buttonSpacer+2) + b_h*(buttonSpacer+1);
                    } else if (configSelected == 5 && clearAllSettingsPressed) {
                        //Do nothing because the user clicked Are You Sure?->No
                        clearAllSettingsPressed = false;
                    } else if (configSelected == 6 && clearAllSettingsPressed) {
                        //User has selected Are You Sure?->Yes
                        settings.clearAll();
                        clearAllSettingsPressed = false;
                        //Stop the system if the user clears all settings
                        if (systemMode == SYSTEMMODE_POSTINIT) {
                            haltSystem();
                        }
                    }
                    //shut configSelector if something other than clear settings was pressed
                    if (!clearAllSettingsPressed) toggleVisibility();
                } //end case mouseHere && Active
            } //end for all configOptions loop
        }
    }

    public void screenResized() {
        updateConfigButtonPositions();
    }

    public void toggleVisibility() {
        isVisible = !isVisible;
        if (systemMode >= SYSTEMMODE_POSTINIT) {
            if (isVisible) {
                //the very convoluted way of locking all controllers of a single controlP5 instance...
                for (int i = 0; i < wm.widgets.size(); i++) {
                    for (int j = 0; j < wm.widgets.get(i).cp5_widget.getAll().size(); j++) {
                        wm.widgets.get(i).cp5_widget.getController(wm.widgets.get(i).cp5_widget.getAll().get(j).getAddress()).lock();
                    }
                }
                //resize the height of the settings dropdown
                h = margin*(configOptions.size()-4) + b_h*(configOptions.size()-1);
                clearAllSettingsPressed = false;
            } else {
                //the very convoluted way of unlocking all controllers of a single controlP5 instance...
                for (int i = 0; i < wm.widgets.size(); i++) {
                    for (int j = 0; j < wm.widgets.get(i).cp5_widget.getAll().size(); j++) {
                        wm.widgets.get(i).cp5_widget.getController(wm.widgets.get(i).cp5_widget.getAll().get(j).getAddress()).unlock();
                    }
                }
            }
        } else if ((systemMode < SYSTEMMODE_POSTINIT) && isVisible && topNav.configButton.isActive()) {
            //resize the height of the settings dropdown
            h = margin*2 + b_h;
            clearAllSettingsPressed = false;
        }
    }

    public void addConfigButtons() {
        //Customize initial button appearance here
        //setup button 0 -- Expert Mode Toggle Button
        int buttonNumber = 0;
        Button tempConfigButton = new Button(x + margin, y + margin*(buttonNumber+1) + b_h*(buttonNumber), b_w, b_h, "Turn Expert Mode On");
        tempConfigButton.setFont(p5, 12);
        tempConfigButton.setColorNotPressed(newGreen);
        tempConfigButton.setFontColorNotActive(color(255));
        tempConfigButton.setHelpText("Expert Mode enables advanced keyboard shortcuts and access to all GUI features.");
        configOptions.add(tempConfigButton);

        //setup button 1 -- Save Custom Settings
        buttonNumber++;
        tempConfigButton = new Button(x + margin, y + margin*(buttonNumber+1) + b_h*(buttonNumber), b_w, b_h, "Save");
        tempConfigButton.setFont(p5, 12); 
        configOptions.add(tempConfigButton);

        //setup button 2 -- Load Custom Settings
        buttonNumber++;
        tempConfigButton = new Button(x + margin, y + margin*(buttonNumber+1) + b_h*(buttonNumber), b_w, b_h, "Load");
        tempConfigButton.setFont(p5, 12);
        configOptions.add(tempConfigButton);

        //setup button 3 -- Default Settings
        buttonNumber++;
        tempConfigButton = new Button(x + margin, y + margin*(buttonNumber+1) + b_h*(buttonNumber), b_w, b_h, "Default");
        tempConfigButton.setFont(p5, 12);
        configOptions.add(tempConfigButton);

        //setup button 4 -- Clear All Settings
        buttonNumber = 0;
        //Update the height of the Settings dropdown
        h = margin*(buttonNumber+1) + b_h*(buttonNumber+1);
        tempConfigButton = new Button(x + margin, y + margin*(buttonNumber+1) + b_h*(buttonNumber), b_w, b_h, "Clear All");
        tempConfigButton.setFont(p5, 12);
        tempConfigButton.setColorNotPressed(cautionRed);
        tempConfigButton.setFontColorNotActive(color(255));
        tempConfigButton.setHelpText("This will clear all user settings and playback history. You will be asked to confirm.");
        configOptions.add(tempConfigButton);

        //setup button 5 -- Are You Sure? No
        buttonNumber++;
        //leave space for "Are You Sure?"
        tempConfigButton = new Button(x + margin, y + margin*(buttonNumber+1) + b_h*(buttonNumber+1), b_w, b_h, "No");
        tempConfigButton.setFont(p5, 12);
        configOptions.add(tempConfigButton);


        //setup button 6 -- Are You Sure? Yes
        buttonNumber++;
        tempConfigButton = new Button(x + margin, y + margin*(buttonNumber+1) + b_h*(buttonNumber+1), b_w, b_h, "Yes");
        tempConfigButton.setFont(p5, 12);
        tempConfigButton.setHelpText("Clicking 'Yes' will delete all user settings and stop the session if running.");
        configOptions.add(tempConfigButton);
    }

    public void updateConfigButtonPositions() {
        //update position of outer box and buttons
        int oldX = x;
        int multiplier = (systemMode == SYSTEMMODE_POSTINIT) ? 3 : 2;
        int _padding = (systemMode == SYSTEMMODE_POSTINIT) ? -3 : 3;
        x = width - 70*multiplier - _padding;
        int dx = oldX - x;
        buttonSpacer = (systemMode == SYSTEMMODE_POSTINIT) ? configOptions.size() : configOptions.size() - 4;
        if (systemMode == SYSTEMMODE_POSTINIT) {
            for (int i = 0; i < configOptions.size(); i++) {
                configOptions.get(i).setX(x + multiplier*2);
                int spacer = (i > configOptions.size() - 3) ? 1 : 0;
                int newY = y + margin*(i+spacer+1) + b_h*(i+spacer);
                configOptions.get(i).setY(newY);
            }
        } else if (systemMode < SYSTEMMODE_POSTINIT) {
            int[] t = {4, 5, 6}; //button numbers
            for (int i = 0; i < t.length; i++) {
                configOptions.get(t[i]).setX(configOptions.get(t[i]).but_x - dx);
                int spacer = (t[i] > 4) ? i + 1 : i;
                int newY = y + margin*(spacer+1) + b_h*(spacer);
                configOptions.get(t[i]).setY(newY);
            }
        }
        //println("TopNav: ConfigSelector: Button Positions Updated");
    }
}

class TutorialSelector {

    int x, y, w, h, margin, b_w, b_h;
    boolean isVisible;

    ArrayList<Button> tutorialOptions; //

    TutorialSelector() {
        w = 180;
        //account for consoleLog button, help button, and spacing
        x = width - 33 - w - 3*2;
        y = (navBarHeight) - 3;
        margin = 6;
        b_w = w - margin*2;
        b_h = 22;
        h = margin*3 + b_h*2;


        isVisible = false;

        tutorialOptions = new ArrayList<Button>();
        addTutorialButtons();
    }

    public void update() {
        if (isVisible) { //only update if visible
            // //close dropdown when mouse leaves
            // if ((mouseX < x || mouseX > x + w || mouseY < y || mouseY > y + h) && !topNav.tutorialsButton.isMouseHere()){
            //   toggleVisibility();
            // }
        }
    }

    public void draw() {
        if (isVisible) { //only draw if visible
            pushStyle();

            stroke(bgColor);
            // fill(229); //bg
            fill(31, 69, 110); //bg
            rect(x, y, w, h);

            for (int i = 0; i < tutorialOptions.size(); i++) {
                tutorialOptions.get(i).draw();
            }

            fill(openbciBlue);
            // fill(177, 184, 193);
            noStroke();
            rect(x+w-(topNav.tutorialsButton.but_dx-1), y, (topNav.tutorialsButton.but_dx-1), 1);

            popStyle();
        }
    }

    public void isMouseHere() {
    }

    public void mousePressed() {
        //only allow button interactivity if isVisible==true
        if (isVisible) {
            for (int i = 0; i < tutorialOptions.size(); i++) {
                if (tutorialOptions.get(i).isMouseHere()) {
                    tutorialOptions.get(i).setIsActive(true);
                }
            }
        }
    }

    public void mouseReleased() {
        //only allow button interactivity if isVisible==true
        if (isVisible) {
            if ((mouseX < x || mouseX > x + w || mouseY < y || mouseY > y + h) && !topNav.tutorialsButton.isMouseHere()) {
                toggleVisibility();
                topNav.configButton.setIgnoreHover(false);
            }
            for (int i = 0; i < tutorialOptions.size(); i++) {
                if (tutorialOptions.get(i).isMouseHere() && tutorialOptions.get(i).isActive()) {
                    int tutorialSelected = i+1;
                    tutorialOptions.get(i).setIsActive(false);
                    tutorialOptions.get(i).goToURL();
                    println("Attempting to use your default web browser to open " + tutorialOptions.get(i).myURL);
                    //output("Help button [" + tutorialSelected + "] selected.");
                    toggleVisibility(); //shut layoutSelector if something is selected
                    //open corresponding link
                }
            }
        }
    }

    public void screenResized() {
        //update position of outer box and buttons
        int oldX = x;
        x = width - w - 3;
        int dx = oldX - x;
        for (int i = 0; i < tutorialOptions.size(); i++) {
            tutorialOptions.get(i).setX(tutorialOptions.get(i).but_x - dx);
        }
    }

    public void toggleVisibility() {
        isVisible = !isVisible;
        if (systemMode >= SYSTEMMODE_POSTINIT) {
            if (isVisible) {
                //the very convoluted way of locking all controllers of a single controlP5 instance...
                for (int i = 0; i < wm.widgets.size(); i++) {
                    for (int j = 0; j < wm.widgets.get(i).cp5_widget.getAll().size(); j++) {
                        wm.widgets.get(i).cp5_widget.getController(wm.widgets.get(i).cp5_widget.getAll().get(j).getAddress()).lock();
                    }
                }
            } else {
                //the very convoluted way of unlocking all controllers of a single controlP5 instance...
                for (int i = 0; i < wm.widgets.size(); i++) {
                    for (int j = 0; j < wm.widgets.get(i).cp5_widget.getAll().size(); j++) {
                        wm.widgets.get(i).cp5_widget.getController(wm.widgets.get(i).cp5_widget.getAll().get(j).getAddress()).unlock();
                    }
                }
            }
        }
    }

    public void addTutorialButtons() {

        //FIRST ROW

        //setup button 1 -- full screen
        int buttonNumber = 0;
        Button tempTutorialButton = new Button(x + margin, y + margin*(buttonNumber+1) + b_h*(buttonNumber), b_w, b_h, "Getting Started");
        tempTutorialButton.setFont(p5, 12);
        tempTutorialButton.setURL("https://openbci.github.io/Documentation/docs/01GettingStarted/GettingStartedLanding");
        tutorialOptions.add(tempTutorialButton);

        buttonNumber = 1;
        h = margin*(buttonNumber+2) + b_h*(buttonNumber+1);
        tempTutorialButton = new Button(x + margin, y + margin*(buttonNumber+1) + b_h*(buttonNumber), b_w, b_h, "Testing Impedance");
        tempTutorialButton.setFont(p5, 12);
        tempTutorialButton.setURL("https://openbci.github.io/Documentation/docs/06Software/01-OpenBCISoftware/GUIDocs#impedance-testing");
        tutorialOptions.add(tempTutorialButton);

        buttonNumber = 2;
        h = margin*(buttonNumber+2) + b_h*(buttonNumber+1);
        tempTutorialButton = new Button(x + margin, y + margin*(buttonNumber+1) + b_h*(buttonNumber), b_w, b_h, "Troubleshooting Guide");
        tempTutorialButton.setFont(p5, 12);
        tempTutorialButton.setURL("https://docs.openbci.com/docs/10Troubleshooting/GUI_Troubleshooting");
        tutorialOptions.add(tempTutorialButton);

        buttonNumber = 3;
        h = margin*(buttonNumber+2) + b_h*(buttonNumber+1);
        tempTutorialButton = new Button(x + margin, y + margin*(buttonNumber+1) + b_h*(buttonNumber), b_w, b_h, "Building Custom Widgets");
        tempTutorialButton.setFont(p5, 12);
        tempTutorialButton.setURL("https://openbci.github.io/Documentation/docs/06Software/01-OpenBCISoftware/GUIWidgets#custom-widget");
        tutorialOptions.add(tempTutorialButton);

        buttonNumber = 4;
        h = margin*(buttonNumber+2) + b_h*(buttonNumber+1);
        tempTutorialButton = new Button(x + margin, y + margin*(buttonNumber+1) + b_h*(buttonNumber), b_w, b_h, "OpenBCI Forum");
        tempTutorialButton.setFont(p5, 12);
        tempTutorialButton.setURL("https://openbci.com/forum/");
        tutorialOptions.add(tempTutorialButton);
    }
}

////////////////////////////////////////////////////
//
// W_Accelerometer is used to visualize accelerometer data
//
// Created: Joel Murphy
// Modified: Colin Fausnaught, September 2016
// Modified: Wangshu Sun, November 2016
// Modified: Richard Waltman, November 2018
//
//
////////////////////////////////////////////////////

//Use the same colors for X,Y,Z throughout Accelerometer widget
final int ACCEL_X_COLOR = color(224, 56, 45);
final int ACCEL_Y_COLOR = color(49, 113, 89);
final int ACCEL_Z_COLOR = color(54, 87, 158);

float[][] accelArray; //holds X,Y,Z values for up to 20s
float accelXyzLimit = 4.0f; //hard limit on all accel values

class W_Accelerometer extends Widget {
    //To see all core variables/methods of the Widget class, refer to Widget.pde
    int graphStroke = color(210);
    int graphBG = color(245);
    int textColor = color(0);
    int strokeColor = color(138, 146, 153);
    int eggshell = color(255, 253, 248);

    //Graphing variables
    int[] xLimOptions = {0, 1, 3, 5, 10, 20}; //number of seconds (x axis of graph)
    int[] yLimOptions = {0, 1, 2, 4};
    int accelHorizLimit = 20;
    int accelBuffSize; //Number of points, used to make buffers
    AccelerometerBar accelerometerBar;

    //Bottom xyz graph
    int accelGraphWidth;
    int accelGraphHeight;
    int accelGraphX;
    int accelGraphY;
    int accPadding = 30;

    //Circular 3d xyz graph
    float polarWindowX;
    float polarWindowY;
    int polarWindowWidth;
    int polarWindowHeight;
    float polarCorner;

    float yMaxMin;

    private float[] currentAccelVals;

    private boolean visible = true;
    private boolean updating = true;
    boolean accelInitHasOccured = false;
    private Button accelModeButton;
    private boolean accelerometerModeOn = true;

    // Synthetic data timer. Track frame count for synthetic data.
    int synthTime;

    W_Accelerometer(PApplet _parent) {
        super(_parent); //calls the parent CONSTRUCTOR method of Widget (DON'T REMOVE)

        //Default dropdown settings
        settings.accVertScaleSave = 0;
        settings.accHorizScaleSave = 0;

        //Make dropdowns
        addDropdown("accelVertScale", "Vert Scale", Arrays.asList(settings.accVertScaleArray), settings.accVertScaleSave);
        addDropdown("accelDuration", "Window", Arrays.asList(settings.accHorizScaleArray), settings.accHorizScaleSave);

        setGraphDimensions();
        yMaxMin = adjustYMaxMinBasedOnSource();

        //XYZ buffer for bottom graph
        accelBuffSize = nPointsBasedOnDataSource();   //accelBuffSize = 20 seconds * 25 Hz
        accelArray = new float[NUM_ACCEL_DIMS][accelBuffSize];
        initAccelData();
        currentAccelVals = new float[NUM_ACCEL_DIMS];

        //create our channel bar and populate our accelerometerBar array!
        accelerometerBar = new AccelerometerBar(_parent, accelGraphX, accelGraphY, accelGraphWidth, accelGraphHeight);
        accelerometerBar.adjustTimeAxis(w_timeSeries.xLimOptions[settings.tsHorizScaleSave]); //sync horiz axis to Time Series by default

        accelModeButton = new Button((int)(x + 3), (int)(y + 3 - navHeight), 120, navHeight - 6, "", 12);
        accelModeButton.setCornerRoundess((int)(navHeight-6));
        accelModeButton.setFont(p5,12);
        accelModeButton.setColorNotPressed(color(57,128,204));
        accelModeButton.textColorNotActive = color(255);
        accelModeButton.hasStroke(false);
        accelModeButton.setHelpText("Click to activate/deactivate the accelerometer!");

        synthTime = 0;
    }

    public void initAccelData() {
        //initialize data
        for (int i = 0; i < accelArray[0].length; i++) {  //initialize the accelerometer data
            accelArray[0][i] = 1.0f;
            accelArray[1][i] = 0.f;
            accelArray[2][i] = -1.f;
        }
    }

    public float adjustYMaxMinBasedOnSource() {
        float _yMaxMin;
        if (eegDataSource == DATASOURCE_CYTON) {
            _yMaxMin = 4.0f;
        }else if (eegDataSource == DATASOURCE_GANGLION || nchan == 4) {
            _yMaxMin = 2.0f;
            accelXyzLimit = 2.0f;
        }else{
            _yMaxMin = 4.0f;
        }
        return _yMaxMin;
    }

    public int nPointsBasedOnDataSource() {
        return accelHorizLimit * (int)getSampleRateSafe();
    }

    public boolean isVisible() {
        return visible;
    }
    public boolean isUpdating() {
        return updating;
    }

    public void setVisible(boolean _visible) {
        visible = _visible;
    }
    public void setUpdating(boolean _updating) {
        updating = _updating;
    }

    public void update() {
        super.update(); //calls the parent update() method of Widget (DON'T REMOVE)

        if (isRunning && isAccelModeActive()) {
            //update the current Accelerometer values
            updateAccelPoints();
            //update the line graph and corresponding gplot points
            accelerometerBar.update();
        }
    }

    public void updateAccelPoints() {
        for (int i = 0; i < NUM_ACCEL_DIMS; i++) {
            if (eegDataSource == DATASOURCE_SYNTHETIC) {
                synthesizeAccelData();
            } else if (eegDataSource == DATASOURCE_CYTON) {
                currentAccelVals[i] = hub.validAccelValues[i] * cyton.get_scale_fac_accel_G_per_count();
            } else if (eegDataSource == DATASOURCE_GANGLION) {
                currentAccelVals[i] = hub.validAccelValues[i] * ganglion.get_scale_fac_accel_G_per_count();
            } else {  //playback data
                currentAccelVals[i] = accelerometerBuff[i][accelerometerBuff[i].length-1];
            }
        }
    }

    public float getCurrentAccelVal(int val) {
        return currentAccelVals[val];
    }

    // check the approrpiate board to see if accel mode is on
    public boolean isAccelModeActive() {
        if (eegDataSource == DATASOURCE_CYTON) {
            return (cyton.getBoardMode() == BoardMode.DEFAULT) && accelerometerModeOn;
        }
        else if (eegDataSource == DATASOURCE_GANGLION) {
            return ganglion.isAccelModeActive();
        }
        else {
            return true;
        }
    }

    public String getButtonString() {
        if (isAccelModeActive()) {
            return "Turn Accel. Off";
        }
        else {
            return "Turn Accel. On";
        }
    }

    public void draw() {
        super.draw(); //calls the parent draw() method of Widget (DON'T REMOVE)

        pushStyle();

        fill(50);
        textFont(p4, 14);
        textAlign(CENTER,CENTER);
        text("z", polarWindowX, (polarWindowY-polarWindowHeight/2)-12);
        text("x", (polarWindowX+polarWindowWidth/2)+8, polarWindowY-5);
        text("y", (polarWindowX+polarCorner)+10, (polarWindowY-polarCorner)-10);

        fill(graphBG);  //pulse window background
        stroke(graphStroke);
        ellipse(polarWindowX,polarWindowY,polarWindowWidth,polarWindowHeight);

        stroke(180);
        line(polarWindowX-polarWindowWidth/2, polarWindowY, polarWindowX+polarWindowWidth/2, polarWindowY);
        line(polarWindowX, polarWindowY-polarWindowHeight/2, polarWindowX, polarWindowY+polarWindowHeight/2);
        line(polarWindowX-polarCorner, polarWindowY+polarCorner, polarWindowX+polarCorner, polarWindowY-polarCorner);

        fill(50);
        textFont(p3, 16);
        accelModeButton.setString(getButtonString());

        if (eegDataSource == DATASOURCE_CYTON
        || (eegDataSource == DATASOURCE_GANGLION && ganglion.isBLE())) {
            accelModeButton.draw();
        }

        if (isAccelModeActive()) {
            drawAccValues();
            draw3DGraph();
            accelerometerBar.draw();
        }
        popStyle();
    }

    public void setGraphDimensions() {
        accelGraphWidth = w - accPadding*2;
        accelGraphHeight = PApplet.parseInt((PApplet.parseFloat(h) - PApplet.parseFloat(accPadding*3))/2.0f);
        accelGraphX = x + accPadding/3;
        accelGraphY = y + h - accelGraphHeight - PApplet.parseInt(accPadding*2) + accPadding/6;

        polarWindowWidth = accelGraphHeight;
        polarWindowHeight = accelGraphHeight;
        polarWindowX = x + w - accPadding - polarWindowWidth/2;
        polarWindowY = y + accPadding + polarWindowHeight/2 - 10;
        polarCorner = (sqrt(2)*polarWindowWidth/2)/2;
    }

    public void screenResized() {
        int prevX = x;
        int prevY = y;
        int prevW = w;
        int prevH = h;
        super.screenResized(); //calls the parent screenResized() method of Widget (DON'T REMOVE)
        setGraphDimensions();
        //resize the accelerometer line graph
        accelerometerBar.screenResized(accelGraphX, accelGraphY, accelGraphWidth-accPadding*2, accelGraphHeight); //bar x, bar y, bar w, bar h
        //update the position of the accel mode button
        accelModeButton.setPos((int)(x + 3), (int)(y + 3 - navHeight));
    }

    public void mousePressed() {
        super.mousePressed(); //calls the parent mousePressed() method of Widget (DON'T REMOVE)

        if (eegDataSource == DATASOURCE_GANGLION) {
            if (ganglion.isBLE()) {
                if (accelModeButton.isMouseHere()) {
                    accelModeButton.setIsActive(true);
                }
            }
        } else if (eegDataSource == DATASOURCE_CYTON) {
            if (accelModeButton.isMouseHere()) {
                accelModeButton.setIsActive(true);
            }
        }
    }

    public void mouseReleased() {
        super.mouseReleased(); //calls the parent mouseReleased() method of Widget (DON'T REMOVE)

        if (eegDataSource == DATASOURCE_GANGLION) {
            if (accelModeButton.isActive && accelModeButton.isMouseHere()) {
                if (isAccelModeActive()) {
                    ganglion.accelStop();
                } else{
                    ganglion.accelStart();
                }
            }
            accelModeButton.setIsActive(false);
        } else if (eegDataSource == DATASOURCE_CYTON) {
            if (accelModeButton.isActive && accelModeButton.isMouseHere()) {
                if (!accelerometerModeOn) {
                    cyton.setBoardMode(BoardMode.DEFAULT);
                    output("Starting to read accelerometer");
                    accelerometerModeOn = true;
                    w_analogRead.analogReadOn = false;
                    w_pulsesensor.analogReadOn = false;
                    w_digitalRead.digitalReadOn = false;
                    w_markermode.markerModeOn = false;
                } else {
                    accelerometerModeOn = false;
                }
            }
            accelModeButton.setIsActive(false);
        }
    }

    //Draw the current accelerometer values as text
    public void drawAccValues() {
        float displayX = 0;
        float displayY = 0;
        float displayZ = 0;
        if (eegDataSource == DATASOURCE_GANGLION) { //Fix implemented for #398
            displayX = currentAccelVals[1]; //Swap X and Y
            displayY = currentAccelVals[0];
            displayZ = -currentAccelVals[2]; //Invert Z
        } else {
            displayX = currentAccelVals[0];
            displayY = currentAccelVals[1];
            displayZ = currentAccelVals[2];
        }
        textAlign(LEFT,CENTER);
        textFont(h1,20);
        fill(ACCEL_X_COLOR);
        text("X = " + nf(displayX, 1, 3) + " g", x+accPadding , y + (h/12)*1.5f - 5);
        fill(ACCEL_Y_COLOR);
        text("Y = " + nf(displayY, 1, 3) + " g", x+accPadding, y + (h/12)*3 - 5);
        fill(ACCEL_Z_COLOR);
        text("Z = " + nf(displayZ, 1, 3) + " g", x+accPadding, y + (h/12)*4.5f - 5);
    }

    //Draw the current accelerometer values as a 3D graph
    public void draw3DGraph() {
        noFill();
        strokeWeight(3);
        stroke(ACCEL_X_COLOR);
        line(polarWindowX, polarWindowY, polarWindowX+map(currentAccelVals[0], -yMaxMin, yMaxMin, -polarWindowWidth/2, polarWindowWidth/2), polarWindowY);
        stroke(ACCEL_Y_COLOR);
        line(polarWindowX, polarWindowY, polarWindowX+map((sqrt(2)*currentAccelVals[1]/2), -yMaxMin, yMaxMin, -polarWindowWidth/2, polarWindowWidth/2), polarWindowY+map((sqrt(2)*currentAccelVals[1]/2), -yMaxMin, yMaxMin, polarWindowWidth/2, -polarWindowWidth/2));
        stroke(ACCEL_Z_COLOR);
        line(polarWindowX, polarWindowY, polarWindowX, polarWindowY+map(currentAccelVals[2], -yMaxMin, yMaxMin, polarWindowWidth/2, -polarWindowWidth/2));
        strokeWeight(1);
    }

    //Used during Synthetic data mode
    public void synthesizeAccelData() {
        for (int i = 0; i < NUM_ACCEL_DIMS; i++) {
            // simple sin wave tied to current time.
            // offset each axis by its index * 2
            // multiply by accelXyzLimit to fill the height of the plot
            currentAccelVals[i] = sin(synthTime/100.f + i*2.f) * accelXyzLimit;
        }
        synthTime ++;
    }//end void synthesizeAccelData
};//end W_Accelerometer class

//These functions are activated when an item from the corresponding dropdown is selected
public void accelVertScale(int n) {
    settings.accVertScaleSave = n;
    w_accelerometer.accelerometerBar.adjustVertScale(w_accelerometer.yLimOptions[n]);
    closeAllDropdowns();
}

//triggered when there is an event in the Duration Dropdown
public void accelDuration(int n) {
    settings.accHorizScaleSave = n;

    //Sync the duration of Time Series, Accelerometer, and Analog Read(Cyton Only)
    if (n == 0) {
        w_accelerometer.accelerometerBar.adjustTimeAxis(w_timeSeries.xLimOptions[settings.tsHorizScaleSave]);
    } else {
        //set accelerometer x axis to the duration selected from dropdown
        w_accelerometer.accelerometerBar.adjustTimeAxis(w_accelerometer.xLimOptions[n]);
    }
    closeAllDropdowns();
}

//========================================================================================================================
//                     Accelerometer Graph Class -- Implemented by Accelerometer Widget Class
//========================================================================================================================
class AccelerometerBar {
    //this class contains the plot for the 2d graph of accelerometer data
    int x, y, w, h;
    boolean isOn; //true means data is streaming and channel is active on hardware ... this will send message to OpenBCI Hardware
    int accBarPadding = 30;
    int xOffset;

    GPlot plot; //the actual grafica-based GPlot that will be rendering the Time Series trace
    GPointsArray accelPointsX;
    GPointsArray accelPointsY;
    GPointsArray accelPointsZ;
    int nPoints;
    int numSeconds = 20; //default to 20 seconds
    float timeBetweenPoints;
    float[] accelTimeArray;
    int numSamplesToProcess;
    float minX, minY, minZ;
    float maxX, maxY, maxZ;
    float minVal;
    float maxVal;
    final float autoScaleSpacing = 0.1f;

    int channelColor; //color of plot trace

    boolean isAutoscale; //when isAutoscale equals true, the y-axis will automatically update to scale to the largest visible amplitude
    int lastProcessedDataPacketInd = 0;

    AccelerometerBar(PApplet _parent, int _x, int _y, int _w, int _h) { //channel number, x/y location, height, width

        isOn = true;

        x = _x;
        y = _y;
        w = _w;
        h = _h;
        if (eegDataSource == DATASOURCE_CYTON) {
            xOffset = 22;
        } else {
            xOffset = 0;
        }

        plot = new GPlot(_parent);
        plot.setPos(x + 36 + 4 + xOffset, y); //match Accelerometer plot position with Time Series
        plot.setDim(w - 36 - 4 - xOffset, h);
        plot.setMar(0f, 0f, 0f, 0f);
        plot.setLineColor((int)channelColors[(NUM_ACCEL_DIMS)%8]);
        plot.setXLim(-numSeconds,0); //set the horizontal scale
        plot.setYLim(-accelXyzLimit,accelXyzLimit); //change this to adjust vertical scale
        //plot.setPointSize(2);
        plot.setPointColor(0);
        plot.getXAxis().setAxisLabelText("Time (s)");
        plot.getYAxis().setAxisLabelText("Acceleration (g)");
        plot.setAllFontProperties("Arial", 0, 14);
        plot.getXAxis().getAxisLabel().setOffset(PApplet.parseFloat(accBarPadding));
        plot.getYAxis().getAxisLabel().setOffset(PApplet.parseFloat(accBarPadding));

        nPoints = nPointsBasedOnDataSource();
        timeBetweenPoints = (float)numSeconds / (float)nPoints;
        accelTimeArray = new float[nPoints];
        for (int i = 0; i < accelTimeArray.length; i++) {
            accelTimeArray[i] = -(float)numSeconds + (float)i * timeBetweenPoints;
        }
        //make a GPoint array using float arrays x[] and y[] instead of plain index points
        accelPointsX = new GPointsArray(accelTimeArray, accelArray[0]);
        accelPointsY = new GPointsArray(accelTimeArray, accelArray[1]);
        accelPointsZ = new GPointsArray(accelTimeArray, accelArray[2]);

        //int accelBuffDiff = accelArrayX.length - nPoints;
        for (int i = 0; i < nPoints; i++) {
            //float time = -(float)numSeconds + (float)(i-accelBuffDiff)*timeBetweenPoints;
            GPoint tempPointX = new GPoint(accelTimeArray[i], accelArray[0][i]);
            GPoint tempPointY = new GPoint(accelTimeArray[i], accelArray[1][i]);
            GPoint tempPointZ = new GPoint(accelTimeArray[i], accelArray[2][i]);
            //println(accelTimeArray[i]);
            accelPointsX.set(i, tempPointX);
            accelPointsY.set(i, tempPointY);
            accelPointsZ.set(i, tempPointZ);
        }

        //set the plot points for X, Y, and Z axes
        plot.addLayer("layer 1", accelPointsX);
        plot.getLayer("layer 1").setLineColor(ACCEL_X_COLOR);
        plot.addLayer("layer 2", accelPointsY);
        plot.getLayer("layer 2").setLineColor(ACCEL_Y_COLOR);
        plot.addLayer("layer 3", accelPointsZ);
        plot.getLayer("layer 3").setLineColor(ACCEL_Z_COLOR);
    }

    //Used to update the accelerometerBar class
    public void update() {
        updateGPlotPoints();
        if (isAutoscale) {
            autoScale();
        }
    }

    public void draw() {
        pushStyle();
        plot.beginDraw();
        plot.drawBox(); //we won't draw this eventually ...
        plot.drawGridLines(2);
        plot.drawLines(); //Draw a Line graph!
        //plot.drawPoints(); //Used to draw Points instead of Lines
        plot.drawYAxis();
        plot.drawXAxis();
        plot.getXAxis().draw();
        plot.endDraw();
        popStyle();
    }

    public int nPointsBasedOnDataSource() {
        return numSeconds * (int)getSampleRateSafe();
    }

    public void adjustTimeAxis(int _newTimeSize) {
        numSeconds = _newTimeSize;
        plot.setXLim(-_newTimeSize,0);

        nPoints = nPointsBasedOnDataSource();
        timeBetweenPoints = (float)numSeconds / (float)nPoints;

        //Calculate the array for GPlot X axis (Time)
        accelTimeArray = new float[nPoints];
        for (int i = 0; i < accelTimeArray.length; i++) {
            accelTimeArray[i] = -(float)numSeconds + (float)i * timeBetweenPoints;
        }
        //Overwrite the existing GPointsArrays with a blank one of size == nPoints
        accelPointsX = new GPointsArray(nPoints);
        accelPointsY = new GPointsArray(nPoints);
        accelPointsZ = new GPointsArray(nPoints);
        //Set the number of axis divisions...
        if (_newTimeSize > 1) {
            plot.getXAxis().setNTicks(_newTimeSize);
        }else{
            plot.getXAxis().setNTicks(10);
        }
        //If user changes time window, and the accelerometer widget exists...
        if (w_accelerometer != null) {
            //...Redraw/update all of the points in the GPlot from the buffer
            setGPlotPoints(w_accelerometer.accelBuffSize);
        }
    }

    //Used to update the Points within the graph
    public void updateGPlotPoints() {
        int accelBuffSize = w_accelerometer.accelBuffSize;
        if (eegDataSource == DATASOURCE_CYTON || eegDataSource == DATASOURCE_GANGLION) {
            //Update data in plot
            numSamplesToProcess = curDataPacketInd - lastProcessedDataPacketInd;
            if (numSamplesToProcess < 0) {
                numSamplesToProcess += dataPacketBuff.length;
            }

            //Shift internal ring buffer numSamplesToProcess
            if (numSamplesToProcess > 0) {
                for (int i = 0; i < NUM_ACCEL_DIMS; i++) {
                    for (int j = 0; j < accelArray[0].length - numSamplesToProcess; j++) {
                        accelArray[i][j] = accelArray[i][j + numSamplesToProcess] ;
                    }
                }
            }

            //for each new sample
            int samplesProcessed = 0;
            while (samplesProcessed < numSamplesToProcess) {
                lastProcessedDataPacketInd++;

                //Watch for wrap around
                if (lastProcessedDataPacketInd > dataPacketBuff.length - 1) {
                    lastProcessedDataPacketInd = 0;
                }

                int curArrayInd = accelBuffSize - numSamplesToProcess + samplesProcessed;
                if(eegDataSource == DATASOURCE_GANGLION) { //Fix implemented for #398
                    accelArray[0][curArrayInd] = w_accelerometer.currentAccelVals[1]; //Swap X and Y
                    accelArray[1][curArrayInd] = w_accelerometer.currentAccelVals[0];
                    accelArray[2][curArrayInd] = -w_accelerometer.currentAccelVals[2]; //Invert Z
                } else {
                    for (int i = 0; i < NUM_ACCEL_DIMS; i++) {
                        accelArray[i][curArrayInd] = w_accelerometer.currentAccelVals[i];
                    }
                }

                samplesProcessed++;
            }
        } else {

            switch (eegDataSource) {
                case DATASOURCE_SYNTHETIC: //use synthetic data (for GUI debugging)
                    numSamplesToProcess = 1;
                    break;
                case DATASOURCE_PLAYBACKFILE:
                    // handle wrap-around
                    lastProcessedDataPacketInd = min(lastProcessedDataPacketInd, currentTableRowIndex);
                    //currentTableRowIndex is used for playback
                    numSamplesToProcess = currentTableRowIndex - lastProcessedDataPacketInd;
                    // we can't process more samples than we have a buffer for
                    numSamplesToProcess = min(numSamplesToProcess, accelBuffSize);
                    break;
                default:
                    numSamplesToProcess = 0;
            }
            //Shift internal ring buffer numSamplesToProcess
            if (numSamplesToProcess > 0) {
                for (int i = 0; i < NUM_ACCEL_DIMS; i++) {
                    for (int j = 0; j < accelArray[0].length - numSamplesToProcess; j++) {
                        accelArray[i][j] = accelArray[i][j + numSamplesToProcess] ;
                    }
                }
            }
            //for each new sample
            int samplesProcessed = 0;
            while (samplesProcessed < numSamplesToProcess) {
                lastProcessedDataPacketInd++;

                int curArrayInd = accelBuffSize - numSamplesToProcess + samplesProcessed;
                for (int i = 0; i < NUM_ACCEL_DIMS; i++) {
                    accelArray[i][curArrayInd] = w_accelerometer.currentAccelVals[i];
                }
                samplesProcessed++;
            }
        }
        setGPlotPoints(accelBuffSize);
    }

    public void setGPlotPoints(int accelBuffSize) {
        //println("UPDATING ACCEL GRAPH");
        int accelBuffDiff = accelBuffSize - nPoints;
        if (numSamplesToProcess > 0 || eegDataSource == DATASOURCE_SYNTHETIC) {
            try {
                for (int i = accelBuffDiff; i < accelBuffSize; i++) { //same method used in W_TimeSeries
                    GPoint tempPointX = new GPoint(accelTimeArray[i-accelBuffDiff], accelArray[0][i]);
                    GPoint tempPointY = new GPoint(accelTimeArray[i-accelBuffDiff], accelArray[1][i]);
                    GPoint tempPointZ = new GPoint(accelTimeArray[i-accelBuffDiff], accelArray[2][i]);
                    accelPointsX.set(i-accelBuffDiff, tempPointX);
                    accelPointsY.set(i-accelBuffDiff, tempPointY);
                    accelPointsZ.set(i-accelBuffDiff, tempPointZ);
                }
                //set points in three layers on the same plot, just like old graph
                plot.setPoints(accelPointsX, "layer 1");
                plot.setPoints(accelPointsY, "layer 2");
                plot.setPoints(accelPointsZ, "layer 3");
            } catch (ArrayIndexOutOfBoundsException e) {
                //catch exception that occurs when loading synthetic mode after Ganglion+WiFi
                println("SetGPlotPoints: ArrayIndexOutOfBoundsException");
            }
        }
    }

    public void adjustVertScale(int _vertScaleValue) {
        if (_vertScaleValue == 0) {
            isAutoscale = true;
        } else {
            isAutoscale = false;
            plot.setYLim(-_vertScaleValue, _vertScaleValue);
        }
    }

    public void autoScale() {
        float[] minMaxVals = minMax(accelPointsX, accelPointsY, accelPointsZ);
        plot.setYLim(minMaxVals[0] - autoScaleSpacing, minMaxVals[1] + autoScaleSpacing);
    }

    public float[] minMax(GPointsArray arrX, GPointsArray arrY, GPointsArray arrZ) {
        float[] minMaxVals = {0.f, 0.f};
        for (int i = 0; i < arrX.getNPoints(); i++) { //go through the XYZ GPpointArrays for on-screen values
            float[] vals = {arrX.getY(i), arrY.getY(i), arrZ.getY(i)};
            minMaxVals[0] = min(minMaxVals[0], min(vals)); //make room to see
            minMaxVals[1] = max(minMaxVals[1], max(vals));
        }
        return minMaxVals;
    }

    public void screenResized(int _x, int _y, int _w, int _h) {
        x = _x;
        y = _y;
        w = _w+100;
        h = _h;
        //reposition & resize the plot
        plot.setPos(x + 36 + 4 + xOffset, y);
        plot.setDim(w - 36 - 4 - xOffset, h);

    }

    public void clearAllGPlots() {
            accelArray = new float[NUM_ACCEL_DIMS][accelArray[0].length];
            w_accelerometer.initAccelData();
            setGPlotPoints(w_accelerometer.accelBuffSize);
    }
}; //end of class

//Global method
public void clearAllAccelGPlots() {
    w_accelerometer.accelerometerBar.clearAllGPlots();
}

////////////////////////////////////////////////////
//
//  W_AnalogRead is used to visiualze analog voltage values
//
//  Created: AJ Keller
//
//
///////////////////////////////////////////////////,

class W_AnalogRead extends Widget {

    //to see all core variables/methods of the Widget class, refer to Widget.pde
    //put your custom variables here...

    private int numAnalogReadBars;
    float xF, yF, wF, hF;
    float arPadding;
    float ar_x, ar_y, ar_h, ar_w; // values for actual time series chart (rectangle encompassing all analogReadBars)
    float plotBottomWell;
    float playbackWidgetHeight;
    int analogReadBarHeight;

    AnalogReadBar[] analogReadBars;

    int[] xLimOptions = {0, 1, 3, 5, 10, 20}; // number of seconds (x axis of graph)
    int[] yLimOptions = {0, 50, 100, 200, 400, 1000, 10000}; // 0 = Autoscale ... everything else is uV

    private boolean allowSpillover = false;
    private boolean visible = true;
    private boolean updating = true;
    private boolean analogReadOn = false;

    //Initial dropdown settings
    private int arInitialVertScaleIndex = 5;
    private int arInitialHorizScaleIndex = 0;

    Button analogModeButton;

    W_AnalogRead(PApplet _parent) {
        super(_parent); //calls the parent CONSTRUCTOR method of Widget (DON'T REMOVE)

        //Analog Read settings
        settings.arVertScaleSave = 5; //updates in VertScale_AR()
        settings.arHorizScaleSave = 0; //updates in Duration_AR()

        //This is the protocol for setting up dropdowns.
        //Note that these 3 dropdowns correspond to the 3 global functions below
        //You just need to make sure the "id" (the 1st String) has the same name as the corresponding function
        addDropdown("VertScale_AR", "Vert Scale", Arrays.asList(settings.arVertScaleArray), arInitialVertScaleIndex);
        addDropdown("Duration_AR", "Window", Arrays.asList(settings.arHorizScaleArray), arInitialHorizScaleIndex);
        // addDropdown("Spillover", "Spillover", Arrays.asList("False", "True"), 0);

        //set number of analog reads
        if (cyton.isWifi()) {
            numAnalogReadBars = 2;
        } else {
            numAnalogReadBars = 3;
        }

        xF = PApplet.parseFloat(x); //float(int( ... is a shortcut for rounding the float down... so that it doesn't creep into the 1px margin
        yF = PApplet.parseFloat(y);
        wF = PApplet.parseFloat(w);
        hF = PApplet.parseFloat(h);

        plotBottomWell = 45.0f; //this appears to be an arbitrary vertical space adds GPlot leaves at bottom, I derived it through trial and error
        arPadding = 10.0f;
        ar_x = xF + arPadding;
        ar_y = yF + (arPadding);
        ar_w = wF - arPadding*2;
        ar_h = hF - playbackWidgetHeight - plotBottomWell - (arPadding*2);
        analogReadBarHeight = PApplet.parseInt(ar_h/numAnalogReadBars);

        analogReadBars = new AnalogReadBar[numAnalogReadBars];

        //create our channel bars and populate our analogReadBars array!
        for(int i = 0; i < numAnalogReadBars; i++) {
            int analogReadBarY = PApplet.parseInt(ar_y) + i*(analogReadBarHeight); //iterate through bar locations
            AnalogReadBar tempBar = new AnalogReadBar(_parent, i+5, PApplet.parseInt(ar_x), analogReadBarY, PApplet.parseInt(ar_w), analogReadBarHeight); //int _channelNumber, int _x, int _y, int _w, int _h
            analogReadBars[i] = tempBar;
            analogReadBars[i].adjustVertScale(yLimOptions[arInitialVertScaleIndex]);
            //sync horiz axis to Time Series by default
            analogReadBars[i].adjustTimeAxis(w_timeSeries.xLimOptions[settings.tsHorizScaleSave]);
        }

        analogModeButton = new Button((int)(x + 3), (int)(y + 3 - navHeight), 128, navHeight - 6, "Turn Analog Read On", 12);
        analogModeButton.setCornerRoundess((int)(navHeight-6));
        analogModeButton.setFont(p5,12);
        analogModeButton.setColorNotPressed(color(57,128,204));
        analogModeButton.textColorNotActive = color(255);
        analogModeButton.hasStroke(false);
        if (cyton.isWifi()) {
            analogModeButton.setHelpText("Click this button to activate/deactivate analog read on Cyton pins A5(D11) and A6(D12).");
        } else {
            analogModeButton.setHelpText("Click this button to activate/deactivate analog read on Cyton pins A5(D11), A6(D12) and A7(D13).");
        }
    }

    public boolean isVisible() {
        return visible;
    }
    public boolean isUpdating() {
        return updating;
    }

    public int getNumAnalogReads() {
        return numAnalogReadBars;
    }

    public void setVisible(boolean _visible) {
        visible = _visible;
    }
    public void setUpdating(boolean _updating) {
        updating = _updating;
    }

    public void update() {
        if(visible && updating) {
            super.update(); //calls the parent update() method of Widget (DON'T REMOVE)

            //update channel bars ... this means feeding new EEG data into plots
            for(int i = 0; i < numAnalogReadBars; i++) {
                analogReadBars[i].update();
            }

            //ignore top left button interaction when widgetSelector dropdown is active
            ignoreButtonCheck(analogModeButton);
        }
    }

    public void draw() {
        if(visible) {
            super.draw(); //calls the parent draw() method of Widget (DON'T REMOVE)

            //remember to refer to x,y,w,h which are the positioning variables of the Widget class
            pushStyle();
            //draw channel bars
            analogModeButton.draw();
            if (cyton.getBoardMode() != BoardMode.ANALOG) {
                analogModeButton.setString("Turn Analog Read On");
            } else {
                analogModeButton.setString("Turn Analog Read Off");
                for(int i = 0; i < numAnalogReadBars; i++) {
                    analogReadBars[i].draw();
                }
            }
            popStyle();
        }
    }

    public void screenResized() {
        super.screenResized(); //calls the parent screenResized() method of Widget (DON'T REMOVE)

        xF = PApplet.parseFloat(x); //float(int( ... is a shortcut for rounding the float down... so that it doesn't creep into the 1px margin
        yF = PApplet.parseFloat(y);
        wF = PApplet.parseFloat(w);
        hF = PApplet.parseFloat(h);

        ar_x = xF + arPadding;
        ar_y = yF + (arPadding);
        ar_w = wF - arPadding*2;
        ar_h = hF - playbackWidgetHeight - plotBottomWell - (arPadding*2);
        analogReadBarHeight = PApplet.parseInt(ar_h/numAnalogReadBars);

        for(int i = 0; i < numAnalogReadBars; i++) {
            int analogReadBarY = PApplet.parseInt(ar_y) + i*(analogReadBarHeight); //iterate through bar locations
            analogReadBars[i].screenResized(PApplet.parseInt(ar_x), analogReadBarY, PApplet.parseInt(ar_w), analogReadBarHeight); //bar x, bar y, bar w, bar h
        }

        analogModeButton.setPos((int)(x + 3), (int)(y + 3 - navHeight));
    }

    public void mousePressed() {
        super.mousePressed(); //calls the parent mousePressed() method of Widget (DON'T REMOVE)

        if (analogModeButton.isMouseHere()) {
            analogModeButton.setIsActive(true);
        }
    }

    public void mouseReleased() {
        super.mouseReleased(); //calls the parent mouseReleased() method of Widget (DON'T REMOVE)

        if(analogModeButton.isActive && analogModeButton.isMouseHere()) {
            // println("analogModeButton...");
            if(cyton.isPortOpen()) {
                if (cyton.getBoardMode() != BoardMode.ANALOG) {
                    cyton.setBoardMode(BoardMode.ANALOG);
                    if (cyton.isWifi()) {
                        output("Starting to read analog inputs on pin marked A5 (D11) and A6 (D12)");
                    } else {
                        output("Starting to read analog inputs on pin marked A5 (D11), A6 (D12) and A7 (D13)");
                    }
                    w_digitalRead.digitalReadOn = false;
                    w_markermode.markerModeOn = false;
                    w_pulsesensor.analogReadOn = true;
                } else {
                    cyton.setBoardMode(BoardMode.DEFAULT);
                    output("Starting to read accelerometer");
                }
                analogReadOn = !analogReadOn;
            }
        }
        analogModeButton.setIsActive(false);
    }
};

//These functions need to be global! These functions are activated when an item from the corresponding dropdown is selected
public void VertScale_AR(int n) {
    settings.arVertScaleSave = n;
    for(int i = 0; i < w_analogRead.numAnalogReadBars; i++) {
            w_analogRead.analogReadBars[i].adjustVertScale(w_analogRead.yLimOptions[n]);
    }
    //closeAllDropdowns();
}

//triggered when there is an event in the LogLin Dropdown
public void Duration_AR(int n) {
    // println("adjust duration to: " + w_analogRead.analogReadBars[i].adjustTimeAxis(n));
    //set analog read x axis to the duration selected from dropdown
    settings.arHorizScaleSave = n;

    //Sync the duration of Time Series, Accelerometer, and Analog Read(Cyton Only)
    for(int i = 0; i < w_analogRead.numAnalogReadBars; i++) {
        if (n == 0) {
            w_analogRead.analogReadBars[i].adjustTimeAxis(w_timeSeries.xLimOptions[settings.tsHorizScaleSave]);
        } else {
            w_analogRead.analogReadBars[i].adjustTimeAxis(w_analogRead.xLimOptions[n]);
        }
    }
    //closeAllDropdowns();
}

//========================================================================================================================
//                      Analog Voltage BAR CLASS -- Implemented by Analog Read Widget Class
//========================================================================================================================
//this class contains the plot and buttons for a single channel of the Time Series widget
//one of these will be created for each channel (4, 8, or 16)
class AnalogReadBar{

    int analogInputPin;
    int auxValuesPosition;
    String analogInputString;
    int x, y, w, h;
    boolean isOn; //true means data is streaming and channel is active on hardware ... this will send message to OpenBCI Hardware

    GPlot plot; //the actual grafica-based GPlot that will be rendering the Time Series trace
    GPointsArray analogReadPoints;
    int nPoints;
    int numSeconds;
    float timeBetweenPoints;
    int arBuffSize;

    int channelColor; //color of plot trace

    boolean isAutoscale; //when isAutoscale equals true, the y-axis of each channelBar will automatically update to scale to the largest visible amplitude
    int autoScaleYLim = 0;

    TextBox analogValue;
    TextBox analogPin;
    TextBox digitalPin;

    boolean drawAnalogValue;
    int lastProcessedDataPacketInd = 0;

    int[] analogReadData;

    AnalogReadBar(PApplet _parent, int _analogInputPin, int _x, int _y, int _w, int _h) { // channel number, x/y location, height, width

        analogInputPin = _analogInputPin;
        int digitalPinNum = 0;
        if (analogInputPin == 7) {
            auxValuesPosition = 2;
            digitalPinNum = 13;
        } else if (analogInputPin == 6) {
            auxValuesPosition = 1;
            digitalPinNum = 12;
        } else {
            analogInputPin = 5;
            auxValuesPosition = 0;
            digitalPinNum = 11;
        }

        analogInputString = str(analogInputPin);
        isOn = true;

        x = _x;
        y = _y;
        w = _w;
        h = _h;

        numSeconds = 20;
        plot = new GPlot(_parent);
        plot.setPos(x + 36 + 4, y);
        plot.setDim(w - 36 - 4, h);
        plot.setMar(0f, 0f, 0f, 0f);
        plot.setLineColor((int)channelColors[(auxValuesPosition)%8]);
        plot.setXLim(-3.2f,-2.9f);
        plot.setYLim(-200,200);
        plot.setPointSize(2);
        plot.setPointColor(0);
        plot.setAllFontProperties("Arial", 0, 14);
        if (cyton.isWifi()) {
            if(auxValuesPosition == 1) {
                plot.getXAxis().setAxisLabelText("Time (s)");
            }
        } else {
            if(auxValuesPosition == 2) {
                plot.getXAxis().setAxisLabelText("Time (s)");
            }
        }

        nPoints = nPointsBasedOnDataSource(); //max duration 20s
        arBuffSize = nPoints;
        analogReadData = new int[nPoints];

        analogReadPoints = new GPointsArray(nPoints);
        timeBetweenPoints = (float)numSeconds / (float)nPoints;

        for (int i = 0; i < arBuffSize; i++) {
            float time = -(float)numSeconds + (float)i*timeBetweenPoints;
            float analog_value = 0.0f; //0.0 for all points to start
            GPoint tempPoint = new GPoint(time, analog_value);
            analogReadPoints.set(i, tempPoint);
        }

        plot.setPoints(analogReadPoints); //set the plot with 0.0 for all analogReadPoints to start

        analogValue = new TextBox("t", x + 36 + 4 + (w - 36 - 4) - 2, y + h);
        analogValue.textColor = color(bgColor);
        analogValue.alignH = RIGHT;
        // analogValue.alignV = TOP;
        analogValue.drawBackground = true;
        analogValue.backgroundColor = color(255,255,255,125);

        analogPin = new TextBox("A" + analogInputString, x+3, y + h);
        analogPin.textColor = color(bgColor);
        analogPin.alignH = CENTER;
        digitalPin = new TextBox("(D" + digitalPinNum + ")", x+3, y + h + 12);
        digitalPin.textColor = color(bgColor);
        digitalPin.alignH = CENTER;

        drawAnalogValue = true;

    }

    public void update() {

        //update the voltage value text string
        float val;

        //update the voltage values
        val = hub.validAccelValues[auxValuesPosition];
        analogValue.string = String.format(getFmt(val),val);

        // update data in plot
        updatePlotPoints();
        if(isAutoscale) {
            autoScale();
        }
    }

    private String getFmt(float val) {
        String fmt;
            if (val > 100.0f) {
                fmt = "%.0f";
            } else if (val > 10.0f) {
                fmt = "%.1f";
            } else {
                fmt = "%.2f";
            }
            return fmt;
    }

    public void updatePlotPoints() {
        // update data in plot
        int numSamplesToProcess = curDataPacketInd - lastProcessedDataPacketInd;
        if (numSamplesToProcess < 0) {
            numSamplesToProcess += dataPacketBuff.length;
        }

        // Shift internal ring buffer numSamplesToProcess
        if (numSamplesToProcess > 0) {
            for(int i = 0; i < analogReadData.length - numSamplesToProcess; i++) {
                analogReadData[i] = analogReadData[i + numSamplesToProcess];
            }
        }

        // for each new sample
        int samplesProcessed = 0;
        while (samplesProcessed < numSamplesToProcess) {
            lastProcessedDataPacketInd++;

            // Watch for wrap around
            if (lastProcessedDataPacketInd > dataPacketBuff.length - 1) {
                lastProcessedDataPacketInd = 0;
            }

            int voltage = dataPacketBuff[lastProcessedDataPacketInd].auxValues[auxValuesPosition];

            analogReadData[analogReadData.length - numSamplesToProcess + samplesProcessed] = voltage; //<>//

            samplesProcessed++;
        }

        int arBuffDiff = arBuffSize - nPoints;
        if (numSamplesToProcess > 0) {
            for (int i = arBuffDiff; i < arBuffSize; i++) {
                float timey = -(float)numSeconds + (float)(i-arBuffDiff)*timeBetweenPoints;
                float voltage = analogReadData[i];

                GPoint tempPoint = new GPoint(timey, voltage);
                analogReadPoints.set(i-arBuffDiff, tempPoint);

            }
            plot.setPoints(analogReadPoints); //reset the plot with updated analogReadPoints
        }
    }

    public void draw() {
        pushStyle();

        //draw plot
        stroke(31,69,110, 50);
        fill(color(125,30,12,30));

        rect(x + 36 + 4, y, w - 36 - 4, h);

        plot.beginDraw();
        plot.drawBox(); // we won't draw this eventually ...
        plot.drawGridLines(0);
        plot.drawLines();
        if (cyton.isWifi()) {
            if(auxValuesPosition == 1) { //only draw the x axis label on the bottom channel bar
                plot.drawXAxis();
                plot.getXAxis().draw();
            }
        }
        else {
            if(auxValuesPosition == 2) { //only draw the x axis label on the bottom channel bar
                plot.drawXAxis();
                plot.getXAxis().draw();
            }
        }

        plot.endDraw();

        if(drawAnalogValue) {
            analogValue.draw();
            analogPin.draw();
            digitalPin.draw();
        }

        popStyle();
    }

    public int nPointsBasedOnDataSource() {
        return numSeconds * (int)getSampleRateSafe();
    }

    public void adjustTimeAxis(int _newTimeSize) {
        numSeconds = _newTimeSize;
        plot.setXLim(-_newTimeSize,0);

        nPoints = nPointsBasedOnDataSource();

        analogReadPoints = new GPointsArray(nPoints);
        if (_newTimeSize > 1) {
            plot.getXAxis().setNTicks(_newTimeSize);  //sets the number of axis divisions...
        }
        else {
            plot.getXAxis().setNTicks(10);
        }
        if (w_analogRead != null) {
            if(w_analogRead.isUpdating()) {
                updatePlotPoints();
            }
        }
    }

    public void adjustVertScale(int _vertScaleValue) {
        if(_vertScaleValue == 0) {
            isAutoscale = true;
        } else {
            isAutoscale = false;
            plot.setYLim(-_vertScaleValue, _vertScaleValue);
        }
    }

    public void autoScale() {
        autoScaleYLim = 0;
        for(int i = 0; i < nPoints; i++) {
            if(PApplet.parseInt(abs(analogReadPoints.getY(i))) > autoScaleYLim) {
                autoScaleYLim = PApplet.parseInt(abs(analogReadPoints.getY(i)));
            }
        }
        plot.setYLim(-autoScaleYLim, autoScaleYLim);
    }

    public void screenResized(int _x, int _y, int _w, int _h) {
        x = _x;
        y = _y;
        w = _w;
        h = _h;

        plot.setPos(x + 36 + 4, y);
        plot.setDim(w - 36 - 4, h);

        analogValue.x = x + 36 + 4 + (w - 36 - 4) - 2;
        analogValue.y = y + h;

        analogPin.x = x + 14;
        analogPin.y = y + PApplet.parseInt(h/2.0f);
        digitalPin.x = analogPin.x;
        digitalPin.y = analogPin.y + 12;
    }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//    W_BandPowers.pde
//
//    This is a band power visualization widget!
//    (Couldn't think up more)
//    This is for visualizing the power of each brainwave band: delta, theta, alpha, beta, gamma
//    Averaged over all channels
//
//    Created by: Wangshu Sun, May 2017
//
////////////////////////////////////////////////////////////////////////////////////////////////////////

class W_BandPower extends Widget {
    
    private final int NUM_BANDS = 5;
    GPlot bp_plot;
    public ChannelSelect bpChanSelect;
    boolean prevChanSelectIsVisible = false;

    W_BandPower(PApplet _parent) {
        super(_parent); //calls the parent CONSTRUCTOR method of Widget (DON'T REMOVE)

        //Add channel select dropdown to this widget
        bpChanSelect = new ChannelSelect(pApplet, x, y, w, navH, "BP_Channels");
        
        //Add settings dropdowns
        addDropdown("Smoothing", "Smooth", Arrays.asList(settings.fftSmoothingArray), smoothFac_ind); //smoothFac_ind is a global variable at the top of W_HeadPlot.pde
        addDropdown("UnfiltFilt", "Filters?", Arrays.asList(settings.fftFilterArray), settings.fftFilterSave);

        // Setup for the BandPower plot
        bp_plot = new GPlot(_parent, x, y-navHeight, w, h+navHeight);
        // bp_plot.setPos(x, y+navHeight);
        bp_plot.setDim(w, h);
        bp_plot.setLogScale("y");
        bp_plot.setYLim(0.1f, 100);
        bp_plot.setXLim(0, 5);
        bp_plot.getYAxis().setNTicks(9);
        bp_plot.getXAxis().setNTicks(0);
        bp_plot.getTitle().setTextAlignment(LEFT);
        bp_plot.getTitle().setRelativePos(0);
        bp_plot.setAllFontProperties("Arial", 0, 14);
        bp_plot.getYAxis().getAxisLabel().setText("Power — (uV)^2 / Hz");
        bp_plot.getXAxis().setAxisLabelText("EEG Power Bands");
        bp_plot.startHistograms(GPlot.VERTICAL);
        bp_plot.getHistogram().setDrawLabels(true);

        //setting border of histograms to match BG
        bp_plot.getHistogram().setLineColors(new int[]{
            color(245), color(245), color(245), color(245), color(245)
          }
        );

        //setting bg colors of histogram bars to match the color scheme of the channel colors w/ an opacity of 150/255
        bp_plot.getHistogram().setBgColors(new int[] {
                color((int)channelColors[2], 150), color((int)channelColors[1], 150),
                color((int)channelColors[3], 150), color((int)channelColors[4], 150), color((int)channelColors[6], 150)

            }
        );

        //activate all channels in channelSelect by default
        activateAllChannels();
    } //end of constructor

    public void update() {
        super.update(); //calls the parent update() method of Widget (DON'T REMOVE)

        float[] activePower = new float[NUM_BANDS];

        for (int i = 0; i < NUM_BANDS; i++) {
            float sum = 0;

            for (int j = 0; j < bpChanSelect.activeChan.size(); j++) {
                int chan = bpChanSelect.activeChan.get(j);
                sum += dataProcessing.avgPowerInBins[chan][i];
                activePower[i] = sum / bpChanSelect.activeChan.size();
            }
        }
        
        //Update channel checkboxes and active channels
        bpChanSelect.update(x, y, w);
        
        //Flex the Gplot graph when channel select dropdown is open/closed
        if (bpChanSelect.isVisible() != prevChanSelectIsVisible) {
            flexGPlotSizeAndPosition();
            prevChanSelectIsVisible = bpChanSelect.isVisible();
        }

        GPointsArray bp_points = new GPointsArray(dataProcessing.headWidePower.length);
        bp_points.add(DELTA + 0.5f, activePower[DELTA], "DELTA");
        bp_points.add(THETA + 0.5f, activePower[THETA], "THETA");
        bp_points.add(ALPHA + 0.5f, activePower[ALPHA], "ALPHA");
        bp_points.add(BETA + 0.5f, activePower[BETA], "BETA");
        bp_points.add(GAMMA + 0.5f, activePower[GAMMA], "GAMMA");
        bp_plot.setPoints(bp_points);
    } //end of update

    public void draw() {
        super.draw(); //calls the parent draw() method of Widget (DON'T REMOVE)
        pushStyle();

        //remember to refer to x,y,w,h which are the positioning variables of the Widget class
        // Draw the third plot
        bp_plot.beginDraw();
        bp_plot.drawBackground();
        bp_plot.drawBox();
        bp_plot.drawXAxis();
        bp_plot.drawYAxis();
        bp_plot.drawHistograms();
        bp_plot.endDraw();

        //for this widget need to redraw the grey bar, bc the FFT plot covers it up...
        fill(200, 200, 200);
        rect(x, y - navHeight, w, navHeight); //button bar

        popStyle();
        bpChanSelect.draw();
        pushStyle();
    }

    public void screenResized() {
        super.screenResized(); //calls the parent screenResized() method of Widget (DON'T REMOVE)

        flexGPlotSizeAndPosition();

        bpChanSelect.screenResized(pApplet);
    }

    public void mousePressed() {
        super.mousePressed(); //calls the parent mousePressed() method of Widget (DON'T REMOVE)
        bpChanSelect.mousePressed(this.dropdownIsActive); //Calls channel select mousePressed and checks if clicked
    }

    public void mouseReleased() {
        super.mouseReleased(); //calls the parent mouseReleased() method of Widget (DON'T REMOVE)
    }

    public void flexGPlotSizeAndPosition() {
        if (bpChanSelect.isVisible()) {
                bp_plot.setPos(x, y);
                bp_plot.setOuterDim(w, h);
        } else {
            bp_plot.setPos(x, y - navHeight);
            bp_plot.setOuterDim(w, h + navHeight);
        }
    }

    public void activateAllChannels() {
        bpChanSelect.activeChan.clear();
        //Activate all channel checkboxes by default for this widget
        for (int i = 0; i < nchan; i++) {
            bpChanSelect.checkList.activate(i);
            bpChanSelect.activeChan.add(i);
        }
    }
};

////////////////////////////////////////////////////
//
//  W_DigitalRead is used to visiualze digital input values
//
//  Created: AJ Keller
//
//
///////////////////////////////////////////////////,

class W_DigitalRead extends Widget {
    private int numDigitalReadDots;
    float xF, yF, wF, hF;
    int dot_padding;
    float dot_x, dot_y, dot_h, dot_w; //values for actual time series chart (rectangle encompassing all digitalReadDots)
    float plotBottomWell;
    float playbackWidgetHeight;
    int digitalReaddotHeight;

    DigitalReadDot[] digitalReadDots;

    private boolean visible = true;
    private boolean updating = true;
    boolean digitalReadOn = false;

    Button digitalModeButton;

    W_DigitalRead(PApplet _parent){
        super(_parent); //calls the parent CONSTRUCTOR method of Widget (DON'T REMOVE)

        //This is the protocol for setting up dropdowns.
        //Note that these 3 dropdowns correspond to the 3 global functions below
        //You just need to make sure the "id" (the 1st String) has the same name as the corresponding function

        //set number of digital reads
        if (cyton.isWifi()) {
            numDigitalReadDots = 3;
        } else {
            numDigitalReadDots = 5;
        }

        xF = PApplet.parseFloat(x); //float(int( ... is a shortcut for rounding the float down... so that it doesn't creep into the 1px margin
        yF = PApplet.parseFloat(y);
        wF = PApplet.parseFloat(w);
        hF = PApplet.parseFloat(h);

        dot_padding = 10;
        dot_x = xF + dot_padding;
        dot_y = yF + (dot_padding);
        dot_w = wF - dot_padding*2;
        dot_h = hF - playbackWidgetHeight - plotBottomWell - (dot_padding*2);
        digitalReaddotHeight = PApplet.parseInt(dot_h/numDigitalReadDots);

        digitalReadDots = new DigitalReadDot[numDigitalReadDots];

        //create our channel bars and populate our digitalReadDots array!
        for(int i = 0; i < numDigitalReadDots; i++){
            int digitalReaddotY = PApplet.parseInt(dot_y) + i*(digitalReaddotHeight); //iterate through bar locations
            int digitalReaddotX = PApplet.parseInt(dot_x) + i*(digitalReaddotHeight); //iterate through bar locations
            int digitalPin = 0;
            if (i == 0) {
                digitalPin = 11;
            } else if (i == 1) {
                digitalPin = 12;
            } else if (i == 2) {
                if (cyton.isWifi()) {
                    digitalPin = 17;
                } else {
                    digitalPin = 13;
                }
            } else if (i == 3) {
                digitalPin = 17;
            } else {
                digitalPin = 18;
            }
            DigitalReadDot tempDot = new DigitalReadDot(_parent, digitalPin, digitalReaddotX, digitalReaddotY, PApplet.parseInt(dot_w), digitalReaddotHeight, dot_padding);
            digitalReadDots[i] = tempDot;
        }

        digitalModeButton = new Button((int)(x + 3), (int)(y + 3 - navHeight), 128, navHeight - 6, "Turn Analog Read On", 12);
        digitalModeButton.setCornerRoundess((int)(navHeight-6));
        digitalModeButton.setFont(p5,12);
        digitalModeButton.setColorNotPressed(color(57,128,204));
        digitalModeButton.textColorNotActive = color(255);
        digitalModeButton.hasStroke(false);

        if (cyton.isWifi()) {
            digitalModeButton.setHelpText("Click this button to activate/deactivate digital read on Cyton pins D11, D12, and D17.");
        } else {
            digitalModeButton.setHelpText("Click this button to activate/deactivate digital read on Cyton pins D11, D12, D13, D17 and D18.");
        }
    }

    public int getNumDigitalReads() {
        return numDigitalReadDots;
    }

    public boolean isVisible() {
        return visible;
    }
    public boolean isUpdating() {
        return updating;
    }

    public void setVisible(boolean _visible) {
        visible = _visible;
    }
    public void setUpdating(boolean _updating) {
        updating = _updating;
    }

    public void update(){
        if(visible && updating){
            super.update(); //calls the parent update() method of Widget (DON'T REMOVE)

            //update channel bars ... this means feeding new EEG data into plots
            for(int i = 0; i < numDigitalReadDots; i++){
                digitalReadDots[i].update();
            }

            //ignore top left button interaction when widgetSelector dropdown is active
            ignoreButtonCheck(digitalModeButton);
        }
    }

    public void draw(){
        if(visible){
            super.draw(); //calls the parent draw() method of Widget (DON'T REMOVE)

            //remember to refer to x,y,w,h which are the positioning variables of the Widget class
            pushStyle();
            //draw channel bars
            digitalModeButton.draw();
            if (cyton.getBoardMode() != BoardMode.DIGITAL) {
                digitalModeButton.setString("Turn Digital Read On");
            } else {
                digitalModeButton.setString("Turn Digital Read Off");
                for(int i = 0; i < numDigitalReadDots; i++){
                    digitalReadDots[i].draw();
                }
            }
            popStyle();
        }
    }

    public void screenResized(){
        super.screenResized(); //calls the parent screenResized() method of Widget (DON'T REMOVE)

        xF = PApplet.parseFloat(x); //float(int( ... is a shortcut for rounding the float down... so that it doesn't creep into the 1px margin
        yF = PApplet.parseFloat(y);
        wF = PApplet.parseFloat(w);
        hF = PApplet.parseFloat(h);

        if (wF > hF) {
            digitalReaddotHeight = PApplet.parseInt(hF/(numDigitalReadDots+1));
        } else {
            digitalReaddotHeight = PApplet.parseInt(wF/(numDigitalReadDots+1));
        }

        if (numDigitalReadDots == 3) {
            digitalReadDots[0].screenResized(x+PApplet.parseInt(wF*(1.0f/3.0f)), y+PApplet.parseInt(hF*(1.0f/3.0f)), digitalReaddotHeight, digitalReaddotHeight); //bar x, bar y, bar w, bar h
            digitalReadDots[1].screenResized(x+PApplet.parseInt(wF/2), y+PApplet.parseInt(hF/2), digitalReaddotHeight, digitalReaddotHeight); //bar x, bar y, bar w, bar h
            digitalReadDots[2].screenResized(x+PApplet.parseInt(wF*(2.0f/3.0f)), y+PApplet.parseInt(hF*(2.0f/3.0f)), digitalReaddotHeight, digitalReaddotHeight); //bar x, bar y, bar w, bar h
        } else {
            int y_pad = y + dot_padding;
            digitalReadDots[0].screenResized(x+PApplet.parseInt(wF*(1.0f/8.0f)), y_pad+PApplet.parseInt(hF*(1.0f/8.0f)), digitalReaddotHeight, digitalReaddotHeight);
            digitalReadDots[2].screenResized(x+PApplet.parseInt(wF/2), y_pad+PApplet.parseInt(hF/2), digitalReaddotHeight, digitalReaddotHeight);
            digitalReadDots[4].screenResized(x+PApplet.parseInt(wF*(7.0f/8.0f)), y_pad+PApplet.parseInt(hF*(7.0f/8.0f)), digitalReaddotHeight, digitalReaddotHeight);
            digitalReadDots[1].screenResized(digitalReadDots[0].dotX+PApplet.parseInt(wF*(3.0f/16.0f)), digitalReadDots[0].dotY+PApplet.parseInt(hF*(3.0f/16.0f)), digitalReaddotHeight, digitalReaddotHeight);
            digitalReadDots[3].screenResized(digitalReadDots[2].dotX+PApplet.parseInt(wF*(3.0f/16.0f)), digitalReadDots[2].dotY+PApplet.parseInt(hF*(3.0f/16.0f)), digitalReaddotHeight, digitalReaddotHeight);

        }

        digitalModeButton.setPos((int)(x + 3), (int)(y + 3 - navHeight));
    }

    public void mousePressed(){
        super.mousePressed(); //calls the parent mousePressed() method of Widget (DON'T REMOVE)

        if (digitalModeButton.isMouseHere()) {
            digitalModeButton.setIsActive(true);
        }
    }

    public void mouseReleased(){
        super.mouseReleased(); //calls the parent mouseReleased() method of Widget (DON'T REMOVE)

        if(digitalModeButton.isActive && digitalModeButton.isMouseHere()){
            if(cyton.isPortOpen()) {
                if (cyton.getBoardMode() != BoardMode.DIGITAL) {
                    cyton.setBoardMode(BoardMode.DIGITAL);
                    if (cyton.isWifi()) {
                        output("Starting to read digital inputs on pin marked D11, D12 and D17");
                    } else {
                        output("Starting to read digital inputs on pin marked D11, D12, D13, D17 and D18");
                    }
                    w_analogRead.analogReadOn = false;
                    w_pulsesensor.analogReadOn = false;
                    w_markermode.markerModeOn = false;
                } else {
                    cyton.setBoardMode(BoardMode.DEFAULT);
                    output("Starting to read accelerometer");
                }
                digitalReadOn = !digitalReadOn;
            }
        }
        digitalModeButton.setIsActive(false);
    }
};

//========================================================================================================================
//                      Analog Voltage BAR CLASS -- Implemented by Analog Read Widget Class
//========================================================================================================================
//this class contains the plot and buttons for a single channel of the Time Series widget
//one of these will be created for each channel (4, 8, or 16)
class DigitalReadDot{

    private int digitalInputPin;
    private int digitalInputVal;
    String digitalInputString;
    int padding;
    boolean isOn; //true means data is streaming and channel is active on hardware ... this will send message to OpenBCI Hardware

    TextBox digitalValue;
    TextBox digitalPin;

    boolean drawDigitalValue;

    int dotStroke = 0xffd2d2d2;
    int dot0Fill = 0xfff5f5f5;
    int dot1Fill = 0xfff5f5f5;
    int val0Fill = 0xff000000;
    int val1Fill = 0xffffffff;

    int dotX;
    int dotY;
    int dotWidth;
    int dotHeight;
    float dotCorner;

    DigitalReadDot(PApplet _parent, int _digitalInputPin, int _x, int _y, int _w, int _h, int _padding){ // channel number, x/y location, height, width

        digitalInputPin = _digitalInputPin;
        digitalInputString = str(digitalInputPin);
        digitalInputVal = 0;
        isOn = true;

        if (digitalInputPin == 11) {
            dot1Fill = channelColors[0];
        } else if (digitalInputPin == 12) {
            dot1Fill = channelColors[1];
        } else if (digitalInputPin == 13) {
            dot1Fill = channelColors[2];
        } else if (digitalInputPin == 17) {
            dot1Fill = channelColors[3];
        } else { // 18
            dot1Fill = channelColors[4];
        }

        dotX = _x;
        dotY = _y;
        dotWidth = _w;
        dotHeight = _h;
        padding = _padding;

        digitalValue = new TextBox("", dotX, dotY);
        digitalValue.textColor = color(val0Fill);
        digitalValue.alignH = CENTER;
        digitalValue.alignV = CENTER;
        drawDigitalValue = true;

        digitalPin = new TextBox("D" + digitalInputString, dotX, dotY - dotWidth);
        digitalPin.textColor = color(bgColor);
        digitalPin.alignH = CENTER;
    }

    public void update(){
        //update the voltage values
        if (digitalInputPin == 11) {
            digitalInputVal = (hub.validAccelValues[0] & 0xFF00) >> 8;
        } else if (digitalInputPin == 12) {
            digitalInputVal = hub.validAccelValues[0] & 0xFF;
        } else if (digitalInputPin == 13) {
            digitalInputVal = (hub.validAccelValues[1] & 0xFF00) >> 8;
        } else if (digitalInputPin == 17) {
            digitalInputVal = hub.validAccelValues[1] & 0xFF;
        } else { // 18
            digitalInputVal = hub.validAccelValues[2];
        }

        digitalValue.string = String.format("%d", digitalInputVal);
    }

    public void draw(){
        pushStyle();

        if (digitalInputVal == 1) {
            fill(dot1Fill);
            digitalValue.textColor = val1Fill;
        } else {
            fill(dot0Fill);
            digitalValue.textColor = val0Fill;
        }
        stroke(dotStroke);
        ellipse(dotX, dotY, dotWidth, dotHeight);

        if(drawDigitalValue){
            digitalValue.draw();
            digitalPin.draw();
        }

        popStyle();
    }

    public int getDigitalReadVal() {
        return digitalInputVal;
    }

    public void screenResized(int _x, int _y, int _w, int _h){
        dotX = _x;
        dotY = _y;
        dotWidth = _w;
        dotHeight = _h;
        dotCorner = (sqrt(2)*dotWidth/2)/2;

        digitalPin.x = dotX;
        digitalPin.y = dotY - PApplet.parseInt(dotWidth/2.0f);

        digitalValue.x = dotX;
        digitalValue.y = dotY;
    }
};
/////////////////////////////////////////////////////////////////////////////////
//
//  Emg_Widget is used to visiualze EMG data by channel, and to trip events
//
//  Created: Colin Fausnaught, December 2016 (with a lot of reworked code from Tao)
//
//  Custom widget to visiualze EMG data. Features dragable thresholds, serial
//  out communication, channel configuration, digital and analog events.
//
//  KNOWN ISSUES: Cannot resize with window dragging events
//
//  TODO: Add dynamic threshold functionality
////////////////////////////////////////////////////////////////////////////////

public void SmoothEMG(int n){

    float samplesPerSecond;
    if(eegDataSource == DATASOURCE_GANGLION){
        samplesPerSecond = 200;
    } else {
        samplesPerSecond = 250;
    }

    for(int i = 0 ; i < w_emg.motorWidgets.length; i++){
        if(n == 0){
            w_emg.motorWidgets[i].averagePeriod = samplesPerSecond * 0.01f;
        }
        if(n == 1){
            w_emg.motorWidgets[i].averagePeriod = samplesPerSecond * 0.1f;
        }
        if(n == 2){
            w_emg.motorWidgets[i].averagePeriod = samplesPerSecond * 0.15f;
        }
        if(n == 3){
            w_emg.motorWidgets[i].averagePeriod = samplesPerSecond * 0.25f;
        }
        if(n == 4){
            w_emg.motorWidgets[i].averagePeriod = samplesPerSecond * 0.5f;
        }
        if(n == 5){
            w_emg.motorWidgets[i].averagePeriod = samplesPerSecond * 0.75f;
        }
        if(n == 6){
            w_emg.motorWidgets[i].averagePeriod = samplesPerSecond * 1.0f;
        }
        if(n == 7){
            w_emg.motorWidgets[i].averagePeriod = samplesPerSecond * 2.0f;
        }
    }
    settings.emgSmoothingSave = n;
    closeAllDropdowns();
}

public void uVLimit(int n){
    for(int i = 0 ; i < w_emg.motorWidgets.length; i++){
        if(n == 0){
            w_emg.motorWidgets[i].acceptableLimitUV = 50.0f;
        }
        if(n == 1){
            w_emg.motorWidgets[i].acceptableLimitUV = 100.0f;
        }
        if(n == 2){
            w_emg.motorWidgets[i].acceptableLimitUV = 200.0f;
        }
        if(n == 3){
            w_emg.motorWidgets[i].acceptableLimitUV = 400.0f;
        }
    }
    settings.emguVLimSave = n;
    closeAllDropdowns();
}

public void CreepSpeed(int n){
    for(int i = 0 ; i < w_emg.motorWidgets.length; i++){
        if(n == 0){
            w_emg.motorWidgets[i].creepSpeed = 0.9f;
        }
        if(n == 1){
            w_emg.motorWidgets[i].creepSpeed = 0.95f;
        }
        if(n == 2){
            w_emg.motorWidgets[i].creepSpeed = 0.98f;
        }
        if(n == 3){
            w_emg.motorWidgets[i].creepSpeed = 0.99f;
        }
        if(n == 4){
            w_emg.motorWidgets[i].creepSpeed = 0.999f;
        }
    }
    settings.emgCreepSave = n;
    closeAllDropdowns();
}

public void minUVRange(int n){
    for(int i = 0 ; i < w_emg.motorWidgets.length; i++){
        if(n == 0){
            w_emg.motorWidgets[i].minRange = 10.0f;
        }
        if(n == 1){
            w_emg.motorWidgets[i].minRange = 20.0f;
        }
        if(n == 2){
            w_emg.motorWidgets[i].minRange = 40.0f;
        }
        if(n == 3){
            w_emg.motorWidgets[i].minRange = 80.0f;
        }
    }
    settings.emgMinDeltauVSave = n;
    closeAllDropdowns();
}

class W_emg extends Widget {
    Motor_Widget[] motorWidgets;
    TripSlider[] tripSliders;
    TripSlider[] untripSliders;
    List<String> baudList;
    List<String> serList;
    List<String> channelList;
    boolean[] events;
    int currChannel;
    int theBaud;
    Button connectButton;
    Serial serialOutEMG;
    String theSerial;

    Boolean emgAdvanced = false;

    PApplet parent;

    W_emg (PApplet _parent) {
        super(_parent); //calls the parent CONSTRUCTOR method of Widget (DON'T REMOVE)
        parent = _parent;

        //EMG settings
        settings.emgSmoothingSave = 4;
        settings.emguVLimSave = 2;
        settings.emgCreepSave = 3;
        settings.emgMinDeltauVSave = 1;

        //Add dropdowns
        addDropdown("SmoothEMG", "Smooth", Arrays.asList("0.01 s", "0.1 s", "0.15 s", "0.25 s", "0.5 s", "0.75 s", "1.0 s", "2.0 s"), settings.emgSmoothingSave);
        addDropdown("uVLimit", "uV Limit", Arrays.asList("50 uV", "100 uV", "200 uV", "400 uV"), settings.emguVLimSave);
        addDropdown("CreepSpeed", "Creep", Arrays.asList("0.9", "0.95", "0.98", "0.99", "0.999"), settings.emgCreepSave);
        addDropdown("minUVRange", "Min \u0394uV", Arrays.asList("10 uV", "20 uV", "40 uV", "80 uV"), settings.emgMinDeltauVSave);

        updateEMGMotorWidgets(nchan);

        if (emgAdvanced) {
            channelList = new ArrayList<String>();
            baudList = new ArrayList<String>();
            serList = new ArrayList<String>();
            for (int i = 0; i < nchan; i++) {
                channelList.add(Integer.toString(i + 1));
            }

            currChannel = 0;
            theBaud = 230400;

            baudList.add("NONE");
            baudList.add(Integer.toString(230400));
            baudList.add(Integer.toString(115200));
            baudList.add(Integer.toString(57600));
            baudList.add(Integer.toString(38400));
            baudList.add(Integer.toString(28800));
            baudList.add(Integer.toString(19200));
            baudList.add(Integer.toString(14400));
            baudList.add(Integer.toString(9600));
            baudList.add(Integer.toString(7200));
            baudList.add(Integer.toString(4800));
            baudList.add(Integer.toString(3600));

            String[] serialPorts = Serial.list();
            serList.add("NONE");
            for (int i = 0; i < serialPorts.length; i++) {
                String tempPort = serialPorts[(serialPorts.length - 1) - i];
                if (!tempPort.equals(openBCI_portName)) serList.add(tempPort);
            }

            addDropdown("SerialSelection", "Output", serList, 0);
            addDropdown("ChannelSelection", "Channel", channelList, 0);
            addDropdown("EventType", "Event Type", Arrays.asList("Digital", "Analog"), 0);
            addDropdown("BaudRate", "Baud Rate", baudList, 0);
            tripSliders = new TripSlider[nchan];
            untripSliders = new TripSlider[nchan];

            initSliders(w, h);
        }
    }

    //Initalizes the threshold
    public void initSliders(int rw, int rh) {
        //Stole some logic from the rectangle drawing in draw()
        int rowNum = 4;
        int colNum = motorWidgets.length / rowNum;
        int index = 0;

        float rowOffset = rh / rowNum;
        float colOffset = rw / colNum;

        for (int i = 0; i < rowNum; i++) {
            for (int j = 0; j < colNum; j++) {

                println("ROW: " + (4*rowOffset/8));
                tripSliders[index] = new TripSlider(PApplet.parseInt((5*colOffset/8) * 0.498f), PApplet.parseInt((2 * rowOffset / 8) * 0.384f), (4*rowOffset/8) * 0.408f, PApplet.parseInt((3*colOffset/32) * 0.489f), 2, tripSliders, true, motorWidgets[index]);
                untripSliders[index] = new TripSlider(PApplet.parseInt((5*colOffset/8) * 0.498f), PApplet.parseInt((2 * rowOffset / 8) * 0.384f), (4*rowOffset/8) * 0.408f, PApplet.parseInt((3*colOffset/32) * 0.489f), 2, tripSliders, false, motorWidgets[index]);
                tripSliders[index].setStretchPercentage(motorWidgets[index].tripThreshold);
                untripSliders[index].setStretchPercentage(motorWidgets[index].untripThreshold);
                index++;
            }
        }
    }

    public void updateEMGMotorWidgets(int _nchan) {
        //setup EMG motor widgets using the number of channels selected
        motorWidgets = new Motor_Widget[_nchan];
        for (int i = 0; i < _nchan; i++) {
            motorWidgets[i] = new Motor_Widget();
            motorWidgets[i].ourChan = i;
            if(eegDataSource == DATASOURCE_GANGLION){
                motorWidgets[i].averagePeriod = 200 * 0.5f;
            } else {
                motorWidgets[i].averagePeriod = 250 * 0.5f;
            }
        }
        events = new boolean[_nchan];
        for (int i = 0; i < _nchan; i++) {
            events[i] = true;
        }
    }

    public void update() {
        super.update(); //calls the parent update() method of Widget (DON'T REMOVE)
        process(yLittleBuff_uV, dataBuffY_uV, dataBuffY_filtY_uV, fftBuff);
    }

    public void draw() {
        super.draw(); //calls the parent draw() method of Widget (DON'T REMOVE)

        pushStyle();
        noStroke();
        fill(255);
        rect(x, y, w, h);

        if (emgAdvanced) {
            if (connectButton != null) connectButton.draw();
            else connectButton = new Button(PApplet.parseInt(x) + 2, PApplet.parseInt(y) - navHeight + 2, 100, navHeight - 6, "Connect", fontInfo.buttonLabel_size);

            stroke(1, 18, 41, 125);

            if (connectButton != null && connectButton.wasPressed) {
                fill(0, 255, 0);
                ellipse(x + 120, y - navHeight/2, 16, 16);
            } else if (connectButton != null && !connectButton.wasPressed) {
                fill(255, 0, 0);
                ellipse(x + 120, y - navHeight/2, 16, 16);
            }
        }

        float rx = x, ry = y, rw = w, rh = h;
        float scaleFactor = 1.0f;
        float scaleFactorJaw = 1.5f;
        int rowNum = 4;
        int colNum = motorWidgets.length / rowNum;
        float rowOffset = rh / rowNum;
        float colOffset = rw / colNum;
        int index = 0;
        float currx, curry;

        for (int i = 0; i < rowNum; i++) {
            for (int j = 0; j < colNum; j++) {

                pushMatrix();
                currx = rx + j * colOffset;
                curry = ry + i * rowOffset; //never name variables on an empty stomach
                translate(currx, curry);

                //realtime
                fill(red(channelColors[index%8]), green(channelColors[index%8]), blue(channelColors[index%8]), 200);
                noStroke();
                ellipse(2*colOffset/8, rowOffset / 2, scaleFactor * motorWidgets[i * colNum + j].myAverage, scaleFactor * motorWidgets[i * colNum + j].myAverage);

                //circle for outer threshold
                noFill();
                strokeWeight(1);
                stroke(red(bgColor), green(bgColor), blue(bgColor), 150);
                ellipse(2*colOffset/8, rowOffset / 2, scaleFactor * motorWidgets[i * colNum + j].upperThreshold, scaleFactor * motorWidgets[i * colNum + j].upperThreshold);

                //circle for inner threshold
                stroke(red(bgColor), green(bgColor), blue(bgColor), 150);
                ellipse(2*colOffset/8, rowOffset / 2, scaleFactor * motorWidgets[i * colNum + j].lowerThreshold, scaleFactor * motorWidgets[i * colNum + j].lowerThreshold);

                int _x = PApplet.parseInt(5*colOffset/8);
                int _y = PApplet.parseInt(2 * rowOffset / 8);
                int _w = PApplet.parseInt(5*colOffset/32);
                int _h = PApplet.parseInt(4*rowOffset/8);

                //draw normalized bar graph of uV w/ matching channel color
                noStroke();
                fill(red(channelColors[index%8]), green(channelColors[index%8]), blue(channelColors[index%8]), 200);
                rect(_x, 3*_y + 1, _w, map(motorWidgets[i * colNum + j].output_normalized, 0, 1, 0, (-1) * PApplet.parseInt((4*rowOffset/8))));

                //draw background bar container for mapped uV value indication
                strokeWeight(1);
                stroke(red(bgColor), green(bgColor), blue(bgColor), 150);
                noFill();
                rect(_x, _y, _w, _h);

                //draw trip & untrip threshold bars
                if (emgAdvanced) {
                    tripSliders[index].update(currx, curry);
                    tripSliders[index].display(_x, _y, _w, _h);
                    untripSliders[index].update(currx, curry);
                    untripSliders[index].display(_x, _y, _w, _h);
                }

                //draw channel number at upper left corner of row/column cell
                pushStyle();
                stroke(0);
                fill(bgColor);
                int _chan = index+1;
                textFont(p5, 12);
                text(_chan + "", 10, 20);
                popStyle();

                index++;
                popMatrix();
            }
        }

        popStyle();
    }

    public void screenResized() {
        super.screenResized(); //calls the parent screenResized() method of Widget (DON'T REMOVE)

        if (emgAdvanced) {
            connectButton.setPos(PApplet.parseInt(x) + 2, PApplet.parseInt(y) - navHeight + 2);

            for (int i = 0; i < tripSliders.length; i++) {
                //update slider positions
            }
        }
    }

    public void mousePressed() {
        super.mousePressed(); //calls the parent mousePressed() method of Widget (DON'T REMOVE)

        if (emgAdvanced) {
            if (connectButton.isMouseHere()) {
                connectButton.setIsActive(true);
                println("Connect pressed");
            } else connectButton.setIsActive(false);
        }
    }

    public void mouseReleased() {
        super.mouseReleased(); //calls the parent mouseReleased() method of Widget (DON'T REMOVE)

        if (emgAdvanced) {
            if (connectButton != null && connectButton.isMouseHere()) {
                //do some function

                try {
                    serialOutEMG = new Serial(parent, theSerial, theBaud);
                    connectButton.wasPressed = true;
                    verbosePrint("Connected");
                    output("Connected to " + theSerial);
                }
                catch (Exception e) {
                    connectButton.wasPressed = false;
                    verbosePrint("Could not connect!");
                    output("Could not connect. Confirm that your Serial/COM port is correct and active.");
                }

                connectButton.setIsActive(false);
            }

            for (int i = 0; i<nchan; i++) {
                tripSliders[i].releaseEvent();
                untripSliders[i].releaseEvent();
            }
        }
    }

    public void process(
        float[][] data_newest_uV, //holds raw EEG data that is new since the last call
        float[][] data_long_uV, //holds a longer piece of buffered EEG data, of same length as will be plotted on the screen
        float[][] data_forDisplay_uV, //this data has been filtered and is ready for plotting on the screen
        FFT[] fftData) {              //holds the FFT (frequency spectrum) of the latest data

        //for example, you could loop over each EEG channel to do some sort of time-domain processing
        //using the sample values that have already been filtered, as will be plotted on the display
        //float EEG_value_uV;

        //looping over channels and analyzing input data
        for (Motor_Widget cfc : motorWidgets) {
            cfc.myAverage = 0.0f;
            for (int i = data_forDisplay_uV[cfc.ourChan].length - PApplet.parseInt(cfc.averagePeriod); i < data_forDisplay_uV[cfc.ourChan].length; i++) {
                if (abs(data_forDisplay_uV[cfc.ourChan][i]) <= cfc.acceptableLimitUV) { //prevent BIG spikes from effecting the average
                    cfc.myAverage += abs(data_forDisplay_uV[cfc.ourChan][i]);  //add value to average ... we will soon divide by # of packets
                } else {
                    cfc.myAverage += cfc.acceptableLimitUV; //if it's greater than the limit, just add the limit
                }
            }
            cfc.myAverage = cfc.myAverage / cfc.averagePeriod; // float(cfc.averagePeriod); //finishing the average

            if (cfc.myAverage >= cfc.upperThreshold && cfc.myAverage <= cfc.acceptableLimitUV) { //
                cfc.upperThreshold = cfc.myAverage;
            }
            if (cfc.myAverage <= cfc.lowerThreshold) {
                cfc.lowerThreshold = cfc.myAverage;
            }
            if (cfc.upperThreshold >= (cfc.myAverage + cfc.minRange)) {  //minRange = 15
                cfc.upperThreshold *= cfc.creepSpeed; //adjustmentSpeed
            }
            if (cfc.lowerThreshold <= 1){
                cfc.lowerThreshold = 1.0f;
            }
            if (cfc.lowerThreshold <= cfc.myAverage) {
                cfc.lowerThreshold *= (1)/(cfc.creepSpeed); //adjustmentSpeed
            }
            if (cfc.upperThreshold <= (cfc.lowerThreshold + cfc.minRange)){
                cfc.upperThreshold = cfc.lowerThreshold + cfc.minRange;
            }

            cfc.output_normalized = map(cfc.myAverage, cfc.lowerThreshold, cfc.upperThreshold, 0, 1);
            if(cfc.output_normalized < 0){
                cfc.output_normalized = 0; //always make sure this value is >= 0
            }
            cfc.output_adjusted = ((-0.1f/(cfc.output_normalized*255.0f)) + 255.0f);

            //=============== TRIPPIN ==================
            //= Just calls all the trip events         =
            //==========================================

            switch(cfc.ourChan) {

            case 0:
                if (events[0]) digitalEventChan0(cfc);
                else analogEventChan0(cfc);
                break;
            case 1:
                if (events[1]) digitalEventChan1(cfc);
                else analogEventChan1(cfc);
                break;
            case 2:
                if (events[2]) digitalEventChan2(cfc);
                else analogEventChan2(cfc);
                break;
            case 3:
                if (events[3]) digitalEventChan3(cfc);
                else analogEventChan3(cfc);
                break;
            case 4:
                if (events[4]) digitalEventChan4(cfc);
                else analogEventChan4(cfc);
                break;
            case 5:
                if (events[5]) digitalEventChan5(cfc);
                else  analogEventChan5(cfc);
                break;
            case 6:
                if (events[6]) digitalEventChan6(cfc);
                else analogEventChan6(cfc);
                break;
            case 7:
                if (events[7]) digitalEventChan7(cfc);
                else analogEventChan7(cfc);
                break;
            case 8:
                if (events[8]) digitalEventChan8(cfc);
                else analogEventChan8(cfc);
                break;
            case 9:
                if (events[9]) digitalEventChan9(cfc);
                else analogEventChan9(cfc);
                break;
            case 10:
                if (events[10]) digitalEventChan10(cfc);
                else analogEventChan10(cfc);
                break;
            case 11:
                if (events[11]) digitalEventChan11(cfc);
                else analogEventChan11(cfc);
                break;
            case 12:
                if (events[12]) digitalEventChan12(cfc);
                else analogEventChan12(cfc);
                break;
            case 13:
                if (events[13]) digitalEventChan13(cfc);
                else analogEventChan13(cfc);
                break;
            case 14:
                if (events[14]) digitalEventChan14(cfc);
                else analogEventChan14(cfc);
                break;
            case 15:
                if (events[15]) digitalEventChan15(cfc);
                else analogEventChan15(cfc);
                break;
            default:
                break;
            }
        }
        //=================== OpenBionics switch example ==============================

        if (millis() - motorWidgets[0].timeOfLastTrip >= 2000 && serialOutEMG != null) {
            //println("Counter: " + motorWidgets[0].switchCounter);
            switch(motorWidgets[0].switchCounter) {
            case 1:
                serialOutEMG.write("G0");
                break;
            }
            motorWidgets[0].switchCounter = 0;
        }

        //----------------- Leftover from Tou Code, what does this do? ----------------------------
        //OR, you could loop over each EEG channel and do some sort of frequency-domain processing from the FFT data
        float FFT_freq_Hz, FFT_value_uV;
        for (int Ichan=0; Ichan < nchan; Ichan++) {
            //loop over each new sample
            for (int Ibin=0; Ibin < fftBuff[Ichan].specSize(); Ibin++) {
                FFT_freq_Hz = fftData[Ichan].indexToFreq(Ibin);
                FFT_value_uV = fftData[Ichan].getBand(Ibin);
            }
        }
        //---------------------------------------------------------------------------------
    }

    class Motor_Widget {
        //variables
        boolean isTriggered = false;
        float upperThreshold = 25;        //default uV upper threshold value ... this will automatically change over time
        float lowerThreshold = 0;         //default uV lower threshold value ... this will automatically change over time
        int thresholdPeriod = 1250;       //number of packets
        int ourChan = 0;                  //channel being monitored ... "3 - 1" means channel 3 (with a 0 index)
        float myAverage = 0.0f;            //this will change over time ... used for calculations below
        //prez related
        boolean switchTripped = false;
        int switchCounter = 0;
        float timeOfLastTrip = 0;
        float tripThreshold = 0.75f;
        float untripThreshold = 0.5f;
        //if writing to a serial port
        int output = 0;                   //value between 0-255 that is the relative position of the current uV average between the rolling lower and upper uV thresholds
        float output_normalized = 0;      //converted to between 0-1
        float output_adjusted = 0;        //adjusted depending on range that is expected on the other end, ie 0-255?
        boolean analogBool = true;        //Analog events?
        boolean digitalBool = true;       //Digital events?

        //these are the 4 variables affected by the dropdown menus
        float averagePeriod; // = 125;          //number of data packets to average over (250 = 1 sec)
        float acceptableLimitUV = 200.0f;    //uV values above this limit are excluded, as a result of them almost certainly being noise...
        float creepSpeed = 0.99f;
        float minRange = 20.0f;

    };

    //============= TripSlider =============
    //=  Class for moving thresholds. Can  =
    //=  be dragged up and down, but lower =
    //=  thresholds cannot go above upper  =
    //=  thresholds (and visa versa).      =
    //======================================
    class TripSlider {
        //Fields
        int lx, ly;
        int boxx, boxy;
        int stretch;
        int wid;
        int len;
        int boxLen;
        boolean over;
        boolean press;
        boolean locked = false;
        boolean otherslocked = false;
        boolean trip;
        boolean drawHand;
        TripSlider[] others;
        int current_color = color(255, 255, 255);
        Motor_Widget parent;

        //Constructor
        TripSlider(int ix, int iy, float il, int iwid, int ilen, TripSlider[] o, boolean wastrip, Motor_Widget p) {
            lx = ix;
            ly = iy;
            boxLen = PApplet.parseInt(il);
            wid = iwid;
            len = ilen;
            boxx = lx - wid/2;
            //boxx = lx;
            boxy = ly-stretch - len/2;
            //boxy = ly;
            others = o;
            trip = wastrip;  //Boolean to distinguish between trip and untrip thresholds
            parent = p;
            //boxLen = 31;
        }

        //Called whenever thresholds are dragged
        public void update(float tx, float ty) {
            // println("testing...");
            boxx = lx;
            //boxy = (wid + (ly/2)) - int(((wid + (ly/2)) - ly) * (float(stretch) / float(wid)));
            //boxy = ly + (ly - int( ly * (float(stretch) / float(wid)))) ;
            boxy = PApplet.parseInt(ly + stretch); //- stretch;

            for (int i=0; i<others.length; i++) {
                if (others[i].locked == true) {
                    otherslocked = true;
                    break;
                } else {
                    otherslocked = false;
                }
            }

            if (otherslocked == false) {
                overEvent(tx, ty);
                pressEvent();
            }

            if (press) {
                //Some of this may need to be refactored in order to support window resizing
                int mappedVal = PApplet.parseInt(mouseY - (ty+ly));
                if (!trip) stretch = lock(mappedVal, PApplet.parseInt(parent.untripThreshold * (boxLen)), boxLen);
                else stretch =  lock(mappedVal, 0, PApplet.parseInt(parent.tripThreshold * (boxLen)));

                if (mappedVal > boxLen && !trip) parent.tripThreshold = 1;
                else if (mappedVal > boxLen && trip) parent.untripThreshold = 1;
                else if (mappedVal < 0 && !trip) parent.tripThreshold = 0;
                else if (mappedVal < 0 && trip) parent.untripThreshold = 0;
                else if (!trip) parent.tripThreshold = PApplet.parseFloat(mappedVal) / (boxLen);
                else if (trip) parent.untripThreshold = PApplet.parseFloat(mappedVal) / (boxLen);
            }
        }

        //Checks if mouse is here
        public void overEvent(float tx, float ty) {
            if (overRect(PApplet.parseInt(boxx + tx), PApplet.parseInt(boxy + ty), wid, len)) {
                over = true;
            } else {
                over = false;
            }
        }

        //Checks if mouse is pressed
        public void pressEvent() {
            if (over && mousePressed || locked) {
                press = true;
                locked = true;
            } else {
                press = false;
            }
        }

        //Mouse was released
        public void releaseEvent() {
            locked = false;
        }

        //Color selector and cursor setter
        public void setColor() {
            if (over) {
                current_color = color(127, 134, 143);
                if (!drawHand) {
                    cursor(HAND);
                    drawHand = true;
                }
            } else {

                if (trip) {
                    current_color = color(0, 255, 0); //trip switch bar color
                } else {
                    current_color = color(255, 0, 0); //untrip switch bar color
                }

                if (drawHand) {
                    cursor(ARROW);
                    drawHand = false;
                }
            }
        }

        //Helper function to make setting default threshold values easier.
        //Expects a float as input (0.25 is 25%)
        public void setStretchPercentage(float val) {
            stretch = lock(PApplet.parseInt(boxLen - ((boxLen) * val)), 0, boxLen);
        }

        //Displays the thresholds %%%%%
        public void display(float tx, float ty, float tw, float tl) {
            lx = PApplet.parseInt(tx);
            ly = PApplet.parseInt(ty);
            wid = PApplet.parseInt(tw);
            boxLen = PApplet.parseInt(tl);

            fill(255);
            strokeWeight(1);
            stroke(bgColor);
            setColor();
            fill(current_color);
            rect(boxx, boxy, wid, len);

            // rect(lx, ly, wid, len);
        }

        //Check if the mouse is here
        public boolean overRect(int lx, int ly, int twidth, int theight) {
            if (mouseX >= lx && mouseX <= lx+twidth &&
                mouseY >= ly && mouseY <= ly+theight) {

                return true;
            } else {
                return false;
            }
        }

        //Locks the threshold in place
        public int lock(int val, int minv, int maxv) {
            return  min(max(val, minv), maxv);
        }
    };

    //===================== DIGITAL EVENTS =============================
    //=  Digital Events work by tripping certain thresholds, and then  =
    //=  untripping said thresholds. In order to use digital events    =
    //=  you will need to observe the switchCounter field in any       =
    //=  given channel. Check out the OpenBionics Switch Example       =
    //=  in the process() function above to get an idea of how to do   =
    //=  this. It is important that your observation of switchCounter  =
    //=  is done in the process() function AFTER the Digital Events    =
    //=  are evoked.                                                   =
    //=                                                                =
    //=  This system supports both digital and analog events           =
    //=  simultaneously and seperated.                                 =
    //==================================================================

    //Channel 1 Event
    public void digitalEventChan0(Motor_Widget cfc) {
        //Local instances of Motor_Widget fields
        float output_normalized = cfc.output_normalized;
        float tripThreshold = cfc.tripThreshold;
        float untripThreshold = cfc.untripThreshold;
        boolean switchTripped = cfc.switchTripped;
        float timeOfLastTrip = cfc.timeOfLastTrip;

        //Custom waiting threshold
        int timeToWaitThresh = 750;

        if (output_normalized >= tripThreshold && !switchTripped && millis() - timeOfLastTrip >= timeToWaitThresh) {
            //Tripped
            cfc.switchTripped = true;
            cfc.timeOfLastTrip = millis();
            cfc.switchCounter++;
        }
        if (switchTripped && output_normalized <= untripThreshold) {
            //Untripped
            cfc.switchTripped = false;
        }
    }

    //Channel 2 Event
    public void digitalEventChan1(Motor_Widget cfc) {
        //Local instances of Motor_Widget fields
        float output_normalized = cfc.output_normalized;
        float tripThreshold = cfc.tripThreshold;
        float untripThreshold = cfc.untripThreshold;
        boolean switchTripped = cfc.switchTripped;
        float timeOfLastTrip = cfc.timeOfLastTrip;

        //Custom waiting threshold
        int timeToWaitThresh = 750;

        if (output_normalized >= tripThreshold && !switchTripped && millis() - timeOfLastTrip >= timeToWaitThresh) {
            //Tripped
            cfc.switchTripped = true;
            cfc.timeOfLastTrip = millis();
            cfc.switchCounter++;
        }
        if (switchTripped && output_normalized <= untripThreshold) {
            //Untripped
            cfc.switchTripped = false;
        }
    }

    //Channel 3 Event
    public void digitalEventChan2(Motor_Widget cfc) {
        //Local instances of Motor_Widget fields
        float output_normalized = cfc.output_normalized;
        float tripThreshold = cfc.tripThreshold;
        float untripThreshold = cfc.untripThreshold;
        boolean switchTripped = cfc.switchTripped;
        float timeOfLastTrip = cfc.timeOfLastTrip;

        //Custom waiting threshold
        int timeToWaitThresh = 750;

        if (output_normalized >= tripThreshold && !switchTripped && millis() - timeOfLastTrip >= timeToWaitThresh) {
            //Tripped
            cfc.switchTripped = true;
            cfc.timeOfLastTrip = millis();
            cfc.switchCounter++;
        }
        if (switchTripped && output_normalized <= untripThreshold) {
            //Untripped
            cfc.switchTripped = false;
        }
    }

    //Channel 4 Event
    public void digitalEventChan3(Motor_Widget cfc) {
        //Local instances of Motor_Widget fields
        float output_normalized = cfc.output_normalized;
        float tripThreshold = cfc.tripThreshold;
        float untripThreshold = cfc.untripThreshold;
        boolean switchTripped = cfc.switchTripped;
        float timeOfLastTrip = cfc.timeOfLastTrip;

        //Custom waiting threshold
        int timeToWaitThresh = 750;

        if (output_normalized >= tripThreshold && !switchTripped && millis() - timeOfLastTrip >= timeToWaitThresh) {
            //Tripped
            cfc.switchTripped = true;
            cfc.timeOfLastTrip = millis();
            cfc.switchCounter++;
        }
        if (switchTripped && output_normalized <= untripThreshold) {
            //Untripped
            cfc.switchTripped = false;
        }
    }

    //Channel 5 Event
    public void digitalEventChan4(Motor_Widget cfc) {
        //Local instances of Motor_Widget fields
        float output_normalized = cfc.output_normalized;
        float tripThreshold = cfc.tripThreshold;
        float untripThreshold = cfc.untripThreshold;
        boolean switchTripped = cfc.switchTripped;
        float timeOfLastTrip = cfc.timeOfLastTrip;

        //Custom waiting threshold
        int timeToWaitThresh = 750;

        if (output_normalized >= tripThreshold && !switchTripped && millis() - timeOfLastTrip >= timeToWaitThresh) {
            //Tripped
            cfc.switchTripped = true;
            cfc.timeOfLastTrip = millis();
            cfc.switchCounter++;
        }
        if (switchTripped && output_normalized <= untripThreshold) {
            //Untripped
            cfc.switchTripped = false;
        }
    }

    //Channel 6 Event
    public void digitalEventChan5(Motor_Widget cfc) {
        //Local instances of Motor_Widget fields
        float output_normalized = cfc.output_normalized;
        float tripThreshold = cfc.tripThreshold;
        float untripThreshold = cfc.untripThreshold;
        boolean switchTripped = cfc.switchTripped;
        float timeOfLastTrip = cfc.timeOfLastTrip;

        //Custom waiting threshold
        int timeToWaitThresh = 750;

        if (output_normalized >= tripThreshold && !switchTripped && millis() - timeOfLastTrip >= timeToWaitThresh) {
            //Tripped
            cfc.switchTripped = true;
            cfc.timeOfLastTrip = millis();
            cfc.switchCounter++;
        }
        if (switchTripped && output_normalized <= untripThreshold) {
            //Untripped
            cfc.switchTripped = false;
        }
    }

    //Channel 7 Event
    public void digitalEventChan6(Motor_Widget cfc) {
        //Local instances of Motor_Widget fields
        float output_normalized = cfc.output_normalized;
        float tripThreshold = cfc.tripThreshold;
        float untripThreshold = cfc.untripThreshold;
        boolean switchTripped = cfc.switchTripped;
        float timeOfLastTrip = cfc.timeOfLastTrip;

        //Custom waiting threshold
        int timeToWaitThresh = 750;

        if (output_normalized >= tripThreshold && !switchTripped && millis() - timeOfLastTrip >= timeToWaitThresh) {
            //Tripped
            cfc.switchTripped = true;
            cfc.timeOfLastTrip = millis();
            cfc.switchCounter++;
        }
        if (switchTripped && output_normalized <= untripThreshold) {
            //Untripped
            cfc.switchTripped = false;
        }
    }

    //Channel 8 Event
    public void digitalEventChan7(Motor_Widget cfc) {
        //Local instances of Motor_Widget fields
        float output_normalized = cfc.output_normalized;
        float tripThreshold = cfc.tripThreshold;
        float untripThreshold = cfc.untripThreshold;
        boolean switchTripped = cfc.switchTripped;
        float timeOfLastTrip = cfc.timeOfLastTrip;

        //Custom waiting threshold
        int timeToWaitThresh = 750;

        if (output_normalized >= tripThreshold && !switchTripped && millis() - timeOfLastTrip >= timeToWaitThresh) {
            //Tripped
            cfc.switchTripped = true;
            cfc.timeOfLastTrip = millis();
            cfc.switchCounter++;
        }
        if (switchTripped && output_normalized <= untripThreshold) {
            //Untripped
            cfc.switchTripped = false;
        }
    }

    //Channel 9 Event
    public void digitalEventChan8(Motor_Widget cfc) {
        //Local instances of Motor_Widget fields
        float output_normalized = cfc.output_normalized;
        float tripThreshold = cfc.tripThreshold;
        float untripThreshold = cfc.untripThreshold;
        boolean switchTripped = cfc.switchTripped;
        float timeOfLastTrip = cfc.timeOfLastTrip;

        //Custom waiting threshold
        int timeToWaitThresh = 750;

        if (output_normalized >= tripThreshold && !switchTripped && millis() - timeOfLastTrip >= timeToWaitThresh) {
            //Tripped
            cfc.switchTripped = true;
            cfc.timeOfLastTrip = millis();
            cfc.switchCounter++;
        }
        if (switchTripped && output_normalized <= untripThreshold) {
            //Untripped
            cfc.switchTripped = false;
        }
    }

    //Channel 10 Event
    public void digitalEventChan9(Motor_Widget cfc) {
        //Local instances of Motor_Widget fields
        float output_normalized = cfc.output_normalized;
        float tripThreshold = cfc.tripThreshold;
        float untripThreshold = cfc.untripThreshold;
        boolean switchTripped = cfc.switchTripped;
        float timeOfLastTrip = cfc.timeOfLastTrip;

        //Custom waiting threshold
        int timeToWaitThresh = 750;

        if (output_normalized >= tripThreshold && !switchTripped && millis() - timeOfLastTrip >= timeToWaitThresh) {
            //Tripped
            cfc.switchTripped = true;
            cfc.timeOfLastTrip = millis();
            cfc.switchCounter++;
        }
        if (switchTripped && output_normalized <= untripThreshold) {
            //Untripped
            cfc.switchTripped = false;
        }
    }

    //Channel 11 Event
    public void digitalEventChan10(Motor_Widget cfc) {
        //Local instances of Motor_Widget fields
        float output_normalized = cfc.output_normalized;
        float tripThreshold = cfc.tripThreshold;
        float untripThreshold = cfc.untripThreshold;
        boolean switchTripped = cfc.switchTripped;
        float timeOfLastTrip = cfc.timeOfLastTrip;

        //Custom waiting threshold
        int timeToWaitThresh = 750;

        if (output_normalized >= tripThreshold && !switchTripped && millis() - timeOfLastTrip >= timeToWaitThresh) {
            //Tripped
            cfc.switchTripped = true;
            cfc.timeOfLastTrip = millis();
            cfc.switchCounter++;
        }
        if (switchTripped && output_normalized <= untripThreshold) {
            //Untripped
            cfc.switchTripped = false;
        }
    }

    //Channel 12 Event
    public void digitalEventChan11(Motor_Widget cfc) {
        //Local instances of Motor_Widget fields
        float output_normalized = cfc.output_normalized;
        float tripThreshold = cfc.tripThreshold;
        float untripThreshold = cfc.untripThreshold;
        boolean switchTripped = cfc.switchTripped;
        float timeOfLastTrip = cfc.timeOfLastTrip;

        //Custom waiting threshold
        int timeToWaitThresh = 750;

        if (output_normalized >= tripThreshold && !switchTripped && millis() - timeOfLastTrip >= timeToWaitThresh) {
            //Tripped
            cfc.switchTripped = true;
            cfc.timeOfLastTrip = millis();
            cfc.switchCounter++;
        }
        if (switchTripped && output_normalized <= untripThreshold) {
            //Untripped
            cfc.switchTripped = false;
        }
    }

    //Channel 13 Event
    public void digitalEventChan12(Motor_Widget cfc) {
        //Local instances of Motor_Widget fields
        float output_normalized = cfc.output_normalized;
        float tripThreshold = cfc.tripThreshold;
        float untripThreshold = cfc.untripThreshold;
        boolean switchTripped = cfc.switchTripped;
        float timeOfLastTrip = cfc.timeOfLastTrip;

        //Custom waiting threshold
        int timeToWaitThresh = 750;

        if (output_normalized >= tripThreshold && !switchTripped && millis() - timeOfLastTrip >= timeToWaitThresh) {
            //Tripped
            cfc.switchTripped = true;
            cfc.timeOfLastTrip = millis();
            cfc.switchCounter++;
        }
        if (switchTripped && output_normalized <= untripThreshold) {
            //Untripped
            cfc.switchTripped = false;
        }
    }

    //Channel 14 Event
    public void digitalEventChan13(Motor_Widget cfc) {
        //Local instances of Motor_Widget fields
        float output_normalized = cfc.output_normalized;
        float tripThreshold = cfc.tripThreshold;
        float untripThreshold = cfc.untripThreshold;
        boolean switchTripped = cfc.switchTripped;
        float timeOfLastTrip = cfc.timeOfLastTrip;

        //Custom waiting threshold
        int timeToWaitThresh = 750;

        if (output_normalized >= tripThreshold && !switchTripped && millis() - timeOfLastTrip >= timeToWaitThresh) {
            //Tripped
            cfc.switchTripped = true;
            cfc.timeOfLastTrip = millis();
            cfc.switchCounter++;
        }
        if (switchTripped && output_normalized <= untripThreshold) {
            //Untripped
            cfc.switchTripped = false;
        }
    }

    //Channel 15 Event
    public void digitalEventChan14(Motor_Widget cfc) {
        //Local instances of Motor_Widget fields
        float output_normalized = cfc.output_normalized;
        float tripThreshold = cfc.tripThreshold;
        float untripThreshold = cfc.untripThreshold;
        boolean switchTripped = cfc.switchTripped;
        float timeOfLastTrip = cfc.timeOfLastTrip;

        //Custom waiting threshold
        int timeToWaitThresh = 750;

        if (output_normalized >= tripThreshold && !switchTripped && millis() - timeOfLastTrip >= timeToWaitThresh) {
            //Tripped
            cfc.switchTripped = true;
            cfc.timeOfLastTrip = millis();
            cfc.switchCounter++;
        }
        if (switchTripped && output_normalized <= untripThreshold) {
            //Untripped
            cfc.switchTripped = false;
        }
    }

    //Channel 16 Event
    public void digitalEventChan15(Motor_Widget cfc) {

        //Local instances of Motor_Widget fields
        float output_normalized = cfc.output_normalized;
        float tripThreshold = cfc.tripThreshold;
        float untripThreshold = cfc.untripThreshold;
        boolean switchTripped = cfc.switchTripped;
        float timeOfLastTrip = cfc.timeOfLastTrip;

        //Custom waiting threshold
        int timeToWaitThresh = 750;

        if (output_normalized >= tripThreshold && !switchTripped && millis() - timeOfLastTrip >= timeToWaitThresh) {
            //Tripped
            cfc.switchTripped = true;
            cfc.timeOfLastTrip = millis();
            cfc.switchCounter++;
        }
        if (switchTripped && output_normalized <= untripThreshold) {
            //Untripped
            cfc.switchTripped = false;
        }
    }

    //===================== ANALOG EVENTS ===========================
    //=  Analog events are a big more complicated than digital      =
    //=  events. In order to use analog events you must map the     =
    //=  output_normalized value to whatver minimum and maximum     =
    //=  you'd like and then write that to the serialOutEMG.        =
    //=                                                             =
    //=  Check out analogEventChan0() for the OpenBionics analog    =
    //=  event example to get an idea of how to use analog events.  =
    //===============================================================

    //Channel 1 Event
    public void analogEventChan0(Motor_Widget cfc) {

        float output_normalized = cfc.output_normalized;
        float tripThreshold = cfc.tripThreshold;
        float untripThreshold = cfc.untripThreshold;
        boolean switchTripped = cfc.switchTripped;
        float timeOfLastTrip = cfc.timeOfLastTrip;


        //================= OpenBionics Analog Movement Example =======================
        if (serialOutEMG != null) {
            //println("Output normalized: " + int(map(output_normalized, 0, 1, 0, 100)));
            if (PApplet.parseInt(map(output_normalized, 0, 1, 0, 100)) > 10) {
                serialOutEMG.write("G0P" + PApplet.parseInt(map(output_normalized, 0, 1, 0, 100)));
                delay(10);
            } else serialOutEMG.write("G0P0");
        }
    }

    //Channel 2 Event
    public void analogEventChan1(Motor_Widget cfc) {

        float output_normalized = cfc.output_normalized;
        float tripThreshold = cfc.tripThreshold;
        float untripThreshold = cfc.untripThreshold;
        boolean switchTripped = cfc.switchTripped;
        float timeOfLastTrip = cfc.timeOfLastTrip;
    }

    //Channel 3 Event
    public void analogEventChan2(Motor_Widget cfc) {

        float output_normalized = cfc.output_normalized;
        float tripThreshold = cfc.tripThreshold;
        float untripThreshold = cfc.untripThreshold;
        boolean switchTripped = cfc.switchTripped;
        float timeOfLastTrip = cfc.timeOfLastTrip;
    }

    //Channel 4 Event
    public void analogEventChan3(Motor_Widget cfc) {

        float output_normalized = cfc.output_normalized;
        float tripThreshold = cfc.tripThreshold;
        float untripThreshold = cfc.untripThreshold;
        boolean switchTripped = cfc.switchTripped;
        float timeOfLastTrip = cfc.timeOfLastTrip;
    }

    //Channel 5 Event
    public void analogEventChan4(Motor_Widget cfc) {

        float output_normalized = cfc.output_normalized;
        float tripThreshold = cfc.tripThreshold;
        float untripThreshold = cfc.untripThreshold;
        boolean switchTripped = cfc.switchTripped;
        float timeOfLastTrip = cfc.timeOfLastTrip;
    }

    //Channel 6 Event
    public void analogEventChan5(Motor_Widget cfc) {

        float output_normalized = cfc.output_normalized;
        float tripThreshold = cfc.tripThreshold;
        float untripThreshold = cfc.untripThreshold;
        boolean switchTripped = cfc.switchTripped;
        float timeOfLastTrip = cfc.timeOfLastTrip;
    }

    //Channel 7 Event
    public void analogEventChan6(Motor_Widget cfc) {

        float output_normalized = cfc.output_normalized;
        float tripThreshold = cfc.tripThreshold;
        float untripThreshold = cfc.untripThreshold;
        boolean switchTripped = cfc.switchTripped;
        float timeOfLastTrip = cfc.timeOfLastTrip;
    }

    //Channel 8 Event
    public void analogEventChan7(Motor_Widget cfc) {

        float output_normalized = cfc.output_normalized;
        float tripThreshold = cfc.tripThreshold;
        float untripThreshold = cfc.untripThreshold;
        boolean switchTripped = cfc.switchTripped;
        float timeOfLastTrip = cfc.timeOfLastTrip;
    }

    //Channel 9 Event
    public void analogEventChan8(Motor_Widget cfc) {

        float output_normalized = cfc.output_normalized;
        float tripThreshold = cfc.tripThreshold;
        float untripThreshold = cfc.untripThreshold;
        boolean switchTripped = cfc.switchTripped;
        float timeOfLastTrip = cfc.timeOfLastTrip;
    }

    //Channel 10 Event
    public void analogEventChan9(Motor_Widget cfc) {

        float output_normalized = cfc.output_normalized;
        float tripThreshold = cfc.tripThreshold;
        float untripThreshold = cfc.untripThreshold;
        boolean switchTripped = cfc.switchTripped;
        float timeOfLastTrip = cfc.timeOfLastTrip;
    }

    //Channel 11 Event
    public void analogEventChan10(Motor_Widget cfc) {

        float output_normalized = cfc.output_normalized;
        float tripThreshold = cfc.tripThreshold;
        float untripThreshold = cfc.untripThreshold;
        boolean switchTripped = cfc.switchTripped;
        float timeOfLastTrip = cfc.timeOfLastTrip;
    }

    //Channel 12 Event
    public void analogEventChan11(Motor_Widget cfc) {

        float output_normalized = cfc.output_normalized;
        float tripThreshold = cfc.tripThreshold;
        float untripThreshold = cfc.untripThreshold;
        boolean switchTripped = cfc.switchTripped;
        float timeOfLastTrip = cfc.timeOfLastTrip;
    }

    //Channel 13 Event
    public void analogEventChan12(Motor_Widget cfc) {

        float output_normalized = cfc.output_normalized;
        float tripThreshold = cfc.tripThreshold;
        float untripThreshold = cfc.untripThreshold;
        boolean switchTripped = cfc.switchTripped;
        float timeOfLastTrip = cfc.timeOfLastTrip;
    }

    //Channel 14 Event
    public void analogEventChan13(Motor_Widget cfc) {

        float output_normalized = cfc.output_normalized;
        float tripThreshold = cfc.tripThreshold;
        float untripThreshold = cfc.untripThreshold;
        boolean switchTripped = cfc.switchTripped;
        float timeOfLastTrip = cfc.timeOfLastTrip;
    }

    //Channel 15 Event
    public void analogEventChan14(Motor_Widget cfc) {

        float output_normalized = cfc.output_normalized;
        float tripThreshold = cfc.tripThreshold;
        float untripThreshold = cfc.untripThreshold;
        boolean switchTripped = cfc.switchTripped;
        float timeOfLastTrip = cfc.timeOfLastTrip;
    }

    //Channel 16 Event
    public void analogEventChan15(Motor_Widget cfc) {

        float output_normalized = cfc.output_normalized;
        float tripThreshold = cfc.tripThreshold;
        float untripThreshold = cfc.untripThreshold;
        boolean switchTripped = cfc.switchTripped;
        float timeOfLastTrip = cfc.timeOfLastTrip;
    }
};

public void ChannelSelection(int n) {
    w_emg.currChannel = n;
    closeAllDropdowns();
}

public void EventType(int n) {
    if (n == 0) w_emg.events[w_emg.currChannel] = true;
    else if (n == 1) w_emg.events[w_emg.currChannel] = false;
    closeAllDropdowns();
}

public void BaudRate(int n) {
    if (!w_emg.baudList.get(n).equals("NONE")) w_emg.theBaud = Integer.parseInt(w_emg.baudList.get(n));
    closeAllDropdowns();
}

public void SerialSelection(int n) {
    if (!w_emg.serList.get(n).equals("NONE")) w_emg.theSerial = w_emg.serList.get(n);
    closeAllDropdowns();
}

////////////////////////////////////////////////////
//
// This class creates an FFT Plot
// It extends the Widget class
//
// Conor Russomanno, November 2016
//
// Requires the plotting library from grafica ...
// replacing the old gwoptics (which is now no longer supported)
//
///////////////////////////////////////////////////

FFT[] fftBuff = new FFT[nchan];    //from the minim library
boolean isFFTFiltered = true; //yes by default ... this is used in dataProcessing.pde to determine which uV array feeds the FFT calculation

class W_fft extends Widget {
    GPlot fft_plot; //create an fft plot for each active channel
    GPointsArray[] fft_points;  //create an array of points for each channel of data (4, 8, or 16)
    int[] lineColor = {
        (int)color(129, 129, 129),
        (int)color(124, 75, 141),
        (int)color(54, 87, 158),
        (int)color(49, 113, 89),
        (int)color(221, 178, 13),
        (int)color(253, 94, 52),
        (int)color(224, 56, 45),
        (int)color(162, 82, 49),
        (int)color(129, 129, 129),
        (int)color(124, 75, 141),
        (int)color(54, 87, 158),
        (int)color(49, 113, 89),
        (int)color(221, 178, 13),
        (int)color(253, 94, 52),
        (int)color(224, 56, 45),
        (int)color(162, 82, 49)
    };

    int[] xLimOptions = {20, 40, 60, 100, 120, 250, 500, 800};
    int[] yLimOptions = {10, 50, 100, 1000};

    int xLim = xLimOptions[2];  //maximum value of x axis ... in this case 20 Hz, 40 Hz, 60 Hz, 120 Hz
    int xMax = xLimOptions[xLimOptions.length-1];   //maximum possible frequency in FFT
    int FFT_indexLim = PApplet.parseInt(1.0f*xMax*(getNfftSafe()/getSampleRateSafe()));   // maxim value of FFT index
    int yLim = yLimOptions[2];  //maximum value of y axis ... 100 uV


    W_fft(PApplet _parent){
        super(_parent); //calls the parent CONSTRUCTOR method of Widget (DON'T REMOVE)

        //Default FFT plot settings
        settings.fftMaxFrqSave = 2;
        settings.fftMaxuVSave = 2;
        settings.fftLogLinSave = 0;
        settings.fftSmoothingSave = 3;
        settings.fftFilterSave = 0;

        //This is the protocol for setting up dropdowns.
        //Note that these 3 dropdowns correspond to the 3 global functions below
        //You just need to make sure the "id" (the 1st String) has the same name as the corresponding function
        addDropdown("MaxFreq", "Max Freq", Arrays.asList(settings.fftMaxFrqArray), settings.fftMaxFrqSave);
        addDropdown("VertScale", "Max uV", Arrays.asList(settings.fftVertScaleArray), settings.fftMaxuVSave);
        addDropdown("LogLin", "Log/Lin", Arrays.asList(settings.fftLogLinArray), settings.fftLogLinSave);
        addDropdown("Smoothing", "Smooth", Arrays.asList(settings.fftSmoothingArray), smoothFac_ind); //smoothFac_ind is a global variable at the top of W_HeadPlot.pde
        addDropdown("UnfiltFilt", "Filters?", Arrays.asList(settings.fftFilterArray), settings.fftFilterSave);

        fft_points = new GPointsArray[nchan];
        // println("fft_points.length: " + fft_points.length);
        initializeFFTPlot(_parent);

    }

    public void initializeFFTPlot(PApplet _parent) {
        //setup GPlot for FFT
        fft_plot = new GPlot(_parent, x, y-navHeight, w, h+navHeight); //based on container dimensions
        fft_plot.setAllFontProperties("Arial", 0, 14);
        fft_plot.getXAxis().setAxisLabelText("Frequency (Hz)");
        fft_plot.getYAxis().setAxisLabelText("Amplitude (uV)");
        fft_plot.setMar(60, 70, 40, 30); //{ bot=60, left=70, top=40, right=30 } by default
        fft_plot.setLogScale("y");

        fft_plot.setYLim(0.1f, yLim);
        int _nTicks = PApplet.parseInt(yLim/10 - 1); //number of axis subdivisions
        fft_plot.getYAxis().setNTicks(_nTicks);  //sets the number of axis divisions...
        fft_plot.setXLim(0.1f, xLim);
        fft_plot.getYAxis().setDrawTickLabels(true);
        fft_plot.setPointSize(2);
        fft_plot.setPointColor(0);

        //setup points of fft point arrays
        for (int i = 0; i < fft_points.length; i++) {
            fft_points[i] = new GPointsArray(FFT_indexLim);
        }

        //fill fft point arrays
        for (int i = 0; i < fft_points.length; i++) { //loop through each channel
            for (int j = 0; j < FFT_indexLim; j++) {
                GPoint temp = new GPoint(j, 0);
                fft_points[i].set(j, temp);
            }
        }

        //map fft point arrays to fft plots
        fft_plot.setPoints(fft_points[0]);
    }

    public void update(){

        super.update(); //calls the parent update() method of Widget (DON'T REMOVE)
        float sr = getSampleRateSafe();
        int nfft = getNfftSafe();

        //update the points of the FFT channel arrays
        //update fft point arrays
        for (int i = 0; i < fft_points.length; i++) {
            for (int j = 0; j < FFT_indexLim + 2; j++) {  //loop through frequency domain data, and store into points array
                GPoint powerAtBin = new GPoint((1.0f*sr/nfft)*j, fftBuff[i].getBand(j));
                fft_points[i].set(j, powerAtBin);
            }
        }
        //remap fft point arrays to fft plots
        fft_plot.setPoints(fft_points[0]);

    }

    public void draw(){
        super.draw(); //calls the parent draw() method of Widget (DON'T REMOVE)

        //remember to refer to x,y,w,h which are the positioning variables of the Widget class
        pushStyle();

        //draw FFT Graph w/ all plots
        noStroke();
        fft_plot.beginDraw();
        fft_plot.drawBackground();
        fft_plot.drawBox();
        fft_plot.drawXAxis();
        fft_plot.drawYAxis();
        fft_plot.drawGridLines(2);
        //here is where we will update points & loop...
        for (int i = 0; i < fft_points.length; i++) {
            fft_plot.setLineColor(lineColor[i]);
            fft_plot.setPoints(fft_points[i]);
            fft_plot.drawLines();
        }
        fft_plot.endDraw();

        //for this widget need to redraw the grey bar, bc the FFT plot covers it up...
        fill(200, 200, 200);
        rect(x, y - navHeight, w, navHeight); //button bar

        popStyle();

    }

    public void screenResized(){
        super.screenResized(); //calls the parent screenResized() method of Widget (DON'T REMOVE)

        //update position/size of FFT plot
        fft_plot.setPos(x, y-navHeight);//update position
        fft_plot.setOuterDim(w, h+navHeight);//update dimensions
    }

    public void mousePressed(){
        super.mousePressed(); //calls the parent mousePressed() method of Widget (DON'T REMOVE)
    }

    public void mouseReleased(){
        super.mouseReleased(); //calls the parent mouseReleased() method of Widget (DON'T REMOVE)
    }
};

//These functions need to be global! These functions are activated when an item from the corresponding dropdown is selected
//triggered when there is an event in the MaxFreq. Dropdown
public void MaxFreq(int n) {
    /* request the selected item based on index n */
    w_fft.fft_plot.setXLim(0.1f, w_fft.xLimOptions[n]); //update the xLim of the FFT_Plot
    settings.fftMaxFrqSave = n; //save the xLim to variable for save/load settings
    closeAllDropdowns();
}

//triggered when there is an event in the VertScale Dropdown
public void VertScale(int n) {

    w_fft.fft_plot.setYLim(0.1f, w_fft.yLimOptions[n]); //update the yLim of the FFT_Plot
    settings.fftMaxuVSave = n; //save the yLim to variable for save/load settings
    closeAllDropdowns();
}

//triggered when there is an event in the LogLin Dropdown
public void LogLin(int n) {
    if (n==0) {
        w_fft.fft_plot.setLogScale("y");
        //store the current setting to save
        settings.fftLogLinSave = 0;
    } else {
        w_fft.fft_plot.setLogScale("");
        //store the current setting to save
        settings.fftLogLinSave = 1;
    }
    closeAllDropdowns();
}

//triggered when there is an event in the Smoothing Dropdown
public void Smoothing(int n) {
    smoothFac_ind = n;
    settings.fftSmoothingSave = n;
    //since this function is called by both the BandPower and FFT Widgets the dropdown needs to be updated in both
    w_fft.cp5_widget.getController("Smoothing").getCaptionLabel().setText(settings.fftSmoothingArray[n]);
    w_bandPower.cp5_widget.getController("Smoothing").getCaptionLabel().setText(settings.fftSmoothingArray[n]);
    closeAllDropdowns();

}

//triggered when there is an event in the UnfiltFilt Dropdown
public void UnfiltFilt(int n) {
    if (n==0) {
        //have FFT use filtered data -- default
        isFFTFiltered = true;
    } else {
        //have FFT use unfiltered data
        isFFTFiltered = false;
    }
    //since this function is called by both the BandPower and FFT Widgets the dropdown needs to be updated in both
    w_fft.cp5_widget.getController("UnfiltFilt").getCaptionLabel().setText(settings.fftFilterArray[n]);
    w_bandPower.cp5_widget.getController("UnfiltFilt").getCaptionLabel().setText(settings.fftFilterArray[n]);
    closeAllDropdowns();
}

////////////////////////////////////////////////////
//
//    W_focus.pde (ie "Focus Widget")
//
//    This widget helps you visualize the alpha and beta value and the calculated focused state
//    You can ask a robot to press Up Arrow key stroke whenever you are focused.
//    You can also send the focused state to Arduino
//
//    Created by: Wangshu Sun, August 2016
//
///////////////////////////////////////////////////,





// color enums
public enum FocusColors {
    GREEN, CYAN, ORANGE
}

class W_Focus extends Widget {
    //to see all core variables/methods of the Widget class, refer to Widget.pde
    Robot robot;    // a key-stroking robot waiting for focused state
    boolean enableKey = false;  // enable key stroke by the robot
    int keyNum = 0; // 0 - up arrow, 1 - Spacebar
    boolean enableSerial = false; // send the Focused state to Arduino

    // output values
    float alpha_avg = 0, beta_avg = 0;
    boolean isFocused;

    // alpha, beta threshold default values
    float alpha_thresh = 0.7f, beta_thresh = 0.7f, alpha_upper = 2, beta_upper = 2;

    // drawing parameters
    boolean showAbout = false;
    PFont myfont = createFont("fonts/Raleway-SemiBold.otf", 12);
    PFont f = f1; //for widget title

    FocusColors focusColors = FocusColors.GREEN;

    int cBack, cDark, cMark, cFocus, cWave, cPanel;

    // float x, y, w, h;  //widget topleft xy, width and height
    float xc, yc, wc, hc; // crystal ball center xy, width and height
    float wg, hg;  //graph width, graph height
    float wl;  // line width
    float xg1, yg1;  //graph1 center xy
    float xg2, yg2;  //graph1 center xy
    float rp;  // padding radius
    float rb;  // button radius
    float xb, yb; // button center xy

    // two sliders for alpha and one slider for beta
    FocusSlider sliderAlphaMid, sliderBetaMid;
    FocusSlider_Static sliderAlphaTop;
    Button infoButton;
    int infoButtonSize = 18;

    W_Focus(PApplet _parent){
        super(_parent); //calls the parent CONSTRUCTOR method of Widget (DON'T REMOVE)

        // initialize graphics parameters
        onColorChange();
        update_graphic_parameters();

        // sliders
        sliderAlphaMid = new FocusSlider(x + xg1 + wg * 0.8f, y + yg1 + hg/2, y + yg1 - hg/2, alpha_thresh / alpha_upper);
        sliderAlphaTop = new FocusSlider_Static(x + xg1 + wg * 0.8f, y + yg1 + hg/2, y + yg1 - hg/2);
        sliderBetaMid = new FocusSlider(x + xg2 + wg * 0.8f, y + yg2 + hg/2, y + yg2 - hg/2, beta_thresh / beta_upper);

        ///Focus widget settings
        settings.focusThemeSave = 0;
        settings.focusKeySave = 0;

        //Dropdowns.
        addDropdown("ChooseFocusColor", "Theme", Arrays.asList("Green", "Orange", "Cyan"), settings.focusThemeSave);
        addDropdown("StrokeKeyWhenFocused", "KeyPress", Arrays.asList("OFF", "UP", "SPACE"), settings.focusKeySave);

        //More info button
        infoButton = new Button(x + w - dropdownWidth * 2 - infoButtonSize - 10, y - navH + 2, infoButtonSize, infoButtonSize, "?", 14);
        infoButton.setCornerRoundess((int)(navHeight-6));
        infoButton.setFont(p5,12);
        infoButton.setColorNotPressed(color(57,128,204));
        infoButton.setFontColorNotActive(color(255));
        infoButton.setHelpText("Click this button to view details on the Focus Widget.");
        infoButton.hasStroke(false);

        // prepare simulate keystroking
        try {
            robot = new Robot();
        } catch (AWTException e) {
            e.printStackTrace();
            exit();
        }

    }

    public void onColorChange() {
        switch(focusColors) {
            case GREEN:
                cBack = 0xffffffff;   //white
                cDark = 0xff3068a6;   //medium/dark blue
                cMark = 0xff4d91d9;    //lighter blue
                cFocus = 0xffb8dc69;   //theme green
                cWave = 0xffffdd3a;    //yellow
                cPanel = 0xfff5f5f5;   //little grey
                break;
            case ORANGE:
                cBack = 0xffffffff;   //white
                cDark = 0xff377bc4;   //medium/dark blue
                cMark = 0xff5e9ee2;    //lighter blue
                cFocus = 0xfffcce51;   //orange
                cWave = 0xffffdd3a;    //yellow
                cPanel = 0xfff5f5f5;   //little grey
                break;
            case CYAN:
                cBack = 0xffffffff;   //white
                cDark = 0xff377bc4;   //medium/dark blue
                cMark = 0xff5e9ee2;    //lighter blue
                cFocus = 0xff91f4fc;   //cyan
                cWave = 0xffffdd3a;    //yellow
                cPanel = 0xfff5f5f5;   //little grey
                break;
        }
    }

    public void update(){
        super.update(); //calls the parent update() method of Widget (DON'T REMOVE)
        updateFocusState(); // focus calculation
        invokeKeyStroke();  // robot keystroke

        // update sliders
        sliderAlphaMid.update();
        sliderAlphaTop.update();
        sliderBetaMid.update();

        // update threshold values
        alpha_thresh = alpha_upper * sliderAlphaMid.getVal();
        beta_thresh = beta_upper * sliderBetaMid.getVal();

        alpha_upper = sliderAlphaTop.getVal() * 2;
        beta_upper = alpha_upper;

        sliderAlphaMid.setVal(alpha_thresh / alpha_upper);
        sliderBetaMid.setVal(beta_thresh / beta_upper);
    }

    public void updateFocusState() {
        // focus detection algorithm based on Jordan's clean mind: focus == high alpha average && low beta average
        float FFT_freq_Hz, FFT_value_uV;
        int alpha_count = 0, beta_count = 0;

        for (int Ichan=0; Ichan < 2; Ichan++) {  // only consider first two channels
            for (int Ibin=0; Ibin < fftBuff[Ichan].specSize(); Ibin++) {
                FFT_freq_Hz = fftBuff[Ichan].indexToFreq(Ibin);
                FFT_value_uV = fftBuff[Ichan].getBand(Ibin);

                if (FFT_freq_Hz >= 7.5f && FFT_freq_Hz <= 12.5f) { //FFT bins in alpha range
                    alpha_avg += FFT_value_uV;
                    alpha_count ++;
                }
                else if (FFT_freq_Hz > 12.5f && FFT_freq_Hz <= 30) {  //FFT bins in beta range
                    beta_avg += FFT_value_uV;
                    beta_count ++;
                }
            }
        }

        alpha_avg = alpha_avg / alpha_count;  // average uV per bin
        beta_avg = beta_avg / beta_count;  // average uV per bin

        // version 1
        if (alpha_avg > alpha_thresh && alpha_avg < alpha_upper && beta_avg < beta_thresh) {
            isFocused = true;
        } else {
            isFocused = false;
        }
    }

    public void invokeKeyStroke() {
        // robot keystroke
        if (enableKey) {
            if (keyNum == 0) {
                if (isFocused) {
                    robot.keyPress(KeyEvent.VK_UP);    //if you want to change to other key, google "java keyEvent" to see the full list
                }
                else {
                    robot.keyRelease(KeyEvent.VK_UP);
                }
            }
            else if (keyNum == 1) {
                if (isFocused) {
                    robot.keyPress(KeyEvent.VK_SPACE);    //if you want to change to other key, google "java keyEvent" to see the full list
                }
                else {
                    robot.keyRelease(KeyEvent.VK_SPACE);
                }
            }
        }
    }

    public void draw(){
        super.draw(); //calls the parent draw() method of Widget (DON'T REMOVE)

        //remember to refer to x,y,w,h which are the positioning variables of the Widget class
        pushStyle();

        //----------------- presettings before drawing Focus Viz --------------
        translate(x, y);
        textAlign(CENTER, CENTER);
        textFont(myfont);

        //----------------- draw background rectangle and panel -----------------
        fill(cBack);
        noStroke();
        rect(0, 0, w, h);

        fill(cPanel);
        noStroke();
        rect(rp, rp, w-rp*2, h-rp*2);

        //----------------- draw focus crystalball -----------------
        noStroke();
        if (isFocused) {
            fill(cFocus);
            stroke(cFocus);
        } else {
            fill(cDark);
        }
        ellipse(xc, yc, wc, hc);
        noStroke();
        // draw focus label
        if (isFocused) {
            fill(cFocus);
            text("focused!", xc, yc + hc/2 + 16);
        } else {
            fill(cMark);
            text("not focused", xc, yc + hc/2 + 16);
        }

        //----------------- draw alpha meter -----------------
        noStroke();
        fill(cDark);
        rect(xg1 - wg/2, yg1 - hg/2, wg, hg);

        float hat = map(alpha_thresh, 0, alpha_upper, 0, hg);  // alpha threshold height
        stroke(cMark);
        line(xg1 - wl/2, yg1 + hg/2, xg1 + wl/2, yg1 + hg/2);
        line(xg1 - wl/2, yg1 - hg/2, xg1 + wl/2, yg1 - hg/2);
        line(xg1 - wl/2, yg1 + hg/2 - hat, xg1 + wl/2, yg1 + hg/2 - hat);

        // draw alpha zone and text
        noStroke();
        if (alpha_avg > alpha_thresh && alpha_avg < alpha_upper) {
            fill(cFocus);
        } else {
            fill(cMark);
        }
        rect(xg1 - wg/2, yg1 - hg/2, wg, hg - hat);
        text("alpha", xg1, yg1 + hg/2 + 16);

        // draw connection between two sliders
        stroke(cMark);
        line(xg1 + wg * 0.8f, yg1 - hg/2 + 10, xg1 + wg * 0.8f, yg1 + hg/2 - hat - 10);

        noStroke();
        fill(cMark);
        text(String.format("%.01f", alpha_upper), xg1 - wl/2 - 14, yg1 - hg/2);
        text(String.format("%.01f", alpha_thresh), xg1 - wl/2 - 14, yg1 + hg/2 - hat);
        text("0.0", xg1 - wl/2 - 14, yg1 + hg/2);

        stroke(cWave);
        strokeWeight(4);
        float ha = map(alpha_avg, 0, alpha_upper, 0, hg);  //alpha height
        ha = constrain(ha, 0, hg);
        line(xg1 - wl/2, yg1 + hg/2 - ha, xg1 + wl/2, yg1 + hg/2 - ha);
        strokeWeight(1);

        //----------------- draw beta meter -----------------
        noStroke();
        fill(cDark);
        rect(xg2 - wg/2, yg2 - hg/2, wg, hg);

        float hbt = map(beta_thresh, 0, beta_upper, 0, hg);  // beta threshold height
        stroke(cMark);
        line(xg2 - wl/2, yg2 + hg/2, xg2 + wl/2, yg2 + hg/2);
        line(xg2 - wl/2, yg2 - hg/2, xg2 + wl/2, yg2 - hg/2);
        line(xg2 - wl/2, yg2 + hg/2 - hbt, xg2 + wl/2, yg2 + hg/2 - hbt);

        // draw beta zone and text
        noStroke();
        if (beta_avg < beta_thresh) {
            fill(cFocus);
        } else {
            fill(cMark);
        }
        rect(xg2 - wg/2, yg2 + hg/2 - hbt, wg, hbt);
        text("beta", xg2, yg2 + hg/2 + 16);

        // draw connection between slider and bottom
        stroke(cMark);
        float yt = yg2 + hg/2 - hbt + 10;   // y threshold
        yt = constrain(yt, yg2 - hg/2 + 10, yg2 + hg/2);
        line(xg2 + wg * 0.8f, yg2 + hg/2, xg2 + wg * 0.8f, yt);

        noStroke();
        fill(cMark);
        text(String.format("%.01f", beta_upper), xg2 - wl/2 - 14, yg2 - hg/2);
        text(String.format("%.01f", beta_thresh), xg2 - wl/2 - 14, yg2 + hg/2 - hbt);
        text("0.0", xg2 - wl/2 - 14, yg2 + hg/2);

        stroke(cWave);
        strokeWeight(4);
        float hb = map(beta_avg, 0, beta_upper, 0, hg);  //beta height
        hb = constrain(hb, 0, hg);
        line(xg2 - wl/2, yg2 + hg/2 - hb, xg2 + wl/2, yg2 + hg/2 - hb);
        strokeWeight(1);

        translate(-x, -y);

        //------------------ draw sliders --------------------
        sliderAlphaMid.draw();
        sliderAlphaTop.draw();
        sliderBetaMid.draw();

        //----------------- draw about button -----------------
        translate(x, y);
        if (showAbout) {
            stroke(cDark);
            fill(cBack);

            rect(rp, rp, w-rp*2, h-rp*2);
            textAlign(LEFT, TOP);
            fill(cDark);
            text("This widget recognizes a focused mental state by looking at alpha and beta wave levels on channel 1 & 2. For better result, try setting the smooth at 0.98 in FFT plot.\n\nThe algorithm thinks you are focused when the alpha level is between 0.7~2uV and the beta level is between 0~0.7 uV, otherwise it thinks you are not focused. It is designed based on Jordan Frand’s brainwave and tested on other subjects, and you can playback Jordan's file in W_Focus folder.\n\nYou can turn on KeyPress and use your focus play a game, so whenever you are focused, the specified UP arrow or SPACE key will be pressed down, otherwise it will be released. You can also try out the Arduino output feature, example and instructions are included in W_Focus folder. For more information, contact wangshu.sun@hotmail.com.", rp*1.5f, rp*1.5f, w-rp*3, h-rp*3);
        }
        
        /*
        noStroke();
        fill(cDark);
        ellipse(xb, yb, rb, rb);
        fill(cBack);
        textAlign(CENTER, CENTER);
        if (showAbout) {
            text("x", xb, yb);
        } else {
            text("?", xb, yb);
        }
        */

        //----------------- revert origin point of draw to default -----------------
        translate(-x, -y);
        textAlign(LEFT, BASELINE);
        // draw the button that toggles information
        infoButton.draw();
        popStyle();
    }

    public void screenResized(){
        super.screenResized(); //calls the parent screenResized() method of Widget (DON'T REMOVE)

        infoButton.setPos(x + w - dropdownWidth * 2 - infoButtonSize - 10, y - navH + 2);

        update_graphic_parameters();

        //update sliders...
        sliderAlphaMid.screenResized(x + xg1 + wg * 0.8f, y + yg1 + hg/2, y + yg1 - hg/2);
        sliderAlphaTop.screenResized(x + xg1 + wg * 0.8f, y + yg1 + hg/2, y + yg1 - hg/2);
        sliderBetaMid.screenResized(x + xg2 + wg * 0.8f, y + yg2 + hg/2, y + yg2 - hg/2);
    }

    public void update_graphic_parameters () {
        xc = w/4;
        yc = h/2;
        wc = w/4;
        hc = w/4;
        wg = 0.07f*w;
        hg = 0.64f*h;
        wl = 0.11f*w;
        xg1 = 0.6f*w;
        yg1 = 0.5f*h;
        xg2 = 0.83f*w;
        yg2 = 0.5f*h;
        rp = max(w*0.05f, h*0.05f);
        rb = 20;
        xb = w-rp;
        yb = rp;
    }

    public void mousePressed(){
        super.mousePressed(); //calls the parent mousePressed() method of Widget (DON'T REMOVE)

        //  about button
        if (!this.dropdownIsActive) {
            if (dist(mouseX,mouseY,xb+x,yb+y) <= rb) {
                showAbout = !showAbout;
            }
        }

        if (infoButton.isMouseHere()) {
            infoButton.setIsActive(true);
        }

        // sliders
        sliderAlphaMid.mousePressed();
        sliderAlphaTop.mousePressed();
        sliderBetaMid.mousePressed();
    }

    public void mouseReleased(){
        super.mouseReleased(); //calls the parent mouseReleased() method of Widget (DON'T REMOVE)

        if (infoButton.isActive && infoButton.isMouseHere()) {
            showAbout = !showAbout;
        }
        infoButton.setIsActive(false);

        // sliders
        sliderAlphaMid.mouseReleased();
        sliderAlphaTop.mouseReleased();
        sliderBetaMid.mouseReleased();
    }

};

/* ---------------------- Supporting Slider Classes ---------------------------*/

// abstract basic slider
public abstract class BasicSlider {
    float x, y, w, h;  // center x, y. w, h means width and height of triangle
    float yBot, yTop;   // y range. Notice val of top y is less than bottom y
    boolean isPressed = false;
    int cNormal = 0xffCCCCCC;
    int cPressed = 0xffFF0000;

    BasicSlider(float _x, float _yBot, float _yTop) {
        x = _x;
        yBot = _yBot;
        yTop = _yTop;
        w = 10;
        h = 10;
    }

    // abstract functions

    public abstract void update();
    public abstract void screenResized(float _x, float _yBot, float _yTop);
    public abstract float getVal();
    public abstract void setVal(float _val);

    // shared functions

    public void draw() {
        if (isPressed) fill(cPressed);
        else fill(cNormal);
        noStroke();
        triangle(x-w/2, y, x+w/2, y-h/2, x+w/2, y+h/2);
    }

    public void mousePressed() {
        if (abs(mouseX - (x)) <= w/2 && abs(mouseY - y) <= h/2) {
            isPressed = true;
        }
    }

    public void mouseReleased() {
        if (isPressed) {
            isPressed = false;
        }
    }
}

// middle slider that changes value and move
public class FocusSlider extends BasicSlider {
    private float val = 0;  // val = 0 ~ 1 -> yBot to yTop
    final float valMin = 0;
    final float valMax = 0.90f;
    FocusSlider(float _x, float _yBot, float _yTop, float _val) {
        super(_x, _yBot, _yTop);
        val = constrain(_val, valMin, valMax);
        y = map(val, 0, 1, yBot, yTop);
    }

    public void update() {
        if (isPressed) {
            float newVal = map(mouseY, yBot, yTop, 0, 1);
            val = constrain(newVal, valMin, valMax);
            y = map(val, 0, 1, yBot, yTop);
            println("Focus: " + val);
        }
    }

    public void screenResized(float _x, float _yBot, float _yTop) {
        x = _x;
        yBot = _yBot;
        yTop = _yTop;
        y = map(val, 0, 1, yBot, yTop);
    }

    public float getVal() {
        return val;
    }

    public void setVal(float _val) {
        val = constrain(_val, valMin, valMax);
        y = map(val, 0, 1, yBot, yTop);
    }
}

// top slider that changes value but doesn't move
public class FocusSlider_Static extends BasicSlider {
    private float val = 0;  // val = 0 ~ 1 -> yBot to yTop
    final float valMin = 0.5f;
    final float valMax = 5.0f;
    FocusSlider_Static(float _x, float _yBot, float _yTop) {
        super(_x, _yBot, _yTop);
        val = 1;
        y = yTop;
    }

    public void update() {
        if (isPressed) {
            float diff = map(mouseY, yBot, yTop, -0.07f, 0);
            val = constrain(val + diff, valMin, valMax);
            println("Focus: " + val);
        }
    }

    public void screenResized(float _x, float _yBot, float _yTop) {
        x = _x;
        yBot = _yBot;
        yTop = _yTop;
        y = yTop;
    }

    public float getVal() {
        return val;
    }

    public void setVal(float _val) {
        val = constrain(_val, valMin, valMax);
    }

}

/* ---------------- Global Functions For Menu Entries --------------------*/

// //These functions need to be global! These functions are activated when an item from the corresponding dropdown is selected
public void StrokeKeyWhenFocused(int n){
    // println("Item " + (n+1) + " selected from Dropdown 1");
    if(n==0){
        //do this
        w_focus.enableKey = false;
        //println("The robot ignores focused state and will not press any key.");
    } else if(n==1){
        //do this instead
        w_focus.enableKey = true;
        w_focus.keyNum = 0;
        //println("The robot will keep pressing Arrow Up key when you are focused, and release the key when you lose focus.");
    } else if(n==2){
        //do this instead
        w_focus.enableKey = true;
        w_focus.keyNum = 1;
        //println("The robot will keep pressing Spacebar when you are focused, and release the key when you lose focus.");
    }
    settings.focusKeySave = n;
    closeAllDropdowns(); // do this at the end of all widget-activated functions to ensure proper widget interactivity ... we want to make sure a click makes the menu close
}

public void ChooseFocusColor(int n){
    if(n==0){
        w_focus.focusColors = FocusColors.GREEN;
        w_focus.onColorChange();
    } else if(n==1){
        w_focus.focusColors = FocusColors.ORANGE;
        w_focus.onColorChange();
    } else if(n==2){
        w_focus.focusColors = FocusColors.CYAN;
        w_focus.onColorChange();
    }
    settings.focusThemeSave = n;
    closeAllDropdowns();
}

////////////////////////////////////////////////////
//
//    W_template.pde (ie "Widget Template")
//
//    This is a Template Widget, intended to be used as a starting point for OpenBCI Community members that want to develop their own custom widgets!
//    Good luck! If you embark on this journey, please let us know. Your contributions are valuable to everyone!
//
//    Created by: Conor Russomanno, November 2016
//
///////////////////////////////////////////////////,

class W_GanglionImpedance extends Widget {
    Button startStopCheck;
    int padding = 24;

    W_GanglionImpedance(PApplet _parent){
        super(_parent); //calls the parent CONSTRUCTOR method of Widget (DON'T REMOVE)

        startStopCheck = new Button (x + padding, y + padding, 200, navHeight, "Start Impedance Check", 12);
        startStopCheck.setFont(p4, 14);
    }

    public void update(){
        super.update(); //calls the parent update() method of Widget (DON'T REMOVE)
    }

    public void draw(){
        super.draw(); //calls the parent draw() method of Widget (DON'T REMOVE)

        //remember to refer to x,y,w,h which are the positioning variables of the Widget class
        pushStyle();

        startStopCheck.draw();

        //divide by 2 ... we do this assuming that the D_G (driven ground) electrode is "comprable in impedance" to the electrode being used.
        fill(bgColor);
        textFont(p4, 14);
        for(int i = 0; i < ganglion.impedanceArray.length; i++){
            String toPrint;
            float adjustedImpedance = ganglion.impedanceArray[i]/2.0f;
            if(i == 0){
                toPrint = "Reference Impedance \u2248 " + adjustedImpedance + " k\u2126";
            } else {
                toPrint = "Channel[" + i + "] Impedance \u2248 " + adjustedImpedance + " k\u2126";
            }
            text(toPrint, x + padding + 40, y + padding*2 + 12 + startStopCheck.but_dy + padding*(i));

            pushStyle();
            stroke(bgColor);
            //change the fill color based on the signal quality...
            if(adjustedImpedance <= 0){ //no data yet...
                fill(255);
            } else if(adjustedImpedance > 0 && adjustedImpedance <= 10){ //very good signal quality
                fill(49, 113, 89); //dark green
            } else if(adjustedImpedance > 10 && adjustedImpedance <= 50){ //good signal quality
                fill(184, 220, 105); //yellow green
            } else if(adjustedImpedance > 50 && adjustedImpedance <= 100){ //acceptable signal quality
                fill(221, 178, 13); //yellow
            } else if(adjustedImpedance > 100 && adjustedImpedance <= 150){ //questionable signal quality
                fill(253, 94, 52); //orange
            } else if(adjustedImpedance > 150){ //bad signal quality
                fill(224, 56, 45); //red
            }

            ellipse(x + padding + 10, y + padding*2 + 7 + startStopCheck.but_dy + padding*(i), padding/2, padding/2);
            popStyle();
        }

        if(isHubInitialized && isHubObjectInitialized && eegDataSource == DATASOURCE_GANGLION){
            if(ganglion.isCheckingImpedance()){
                image(loadingGIF_blue, x + padding + startStopCheck.but_dx + 15, y + padding - 8, 40, 40);
            }
        }

        popStyle();
    }

    public void screenResized(){
        super.screenResized(); //calls the parent screenResized() method of Widget (DON'T REMOVE)
        startStopCheck.setPos(x + padding, y + padding);
    }

    public void mousePressed(){
        super.mousePressed(); //calls the parent mousePressed() method of Widget (DON'T REMOVE)
        if(startStopCheck.isMouseHere()){
            startStopCheck.setIsActive(true);
        }
    }

    public void mouseReleased(){
        super.mouseReleased(); //calls the parent mouseReleased() method of Widget (DON'T REMOVE)

        if(startStopCheck.isActive && startStopCheck.isMouseHere()){
            if(isHubInitialized && isHubObjectInitialized && eegDataSource == DATASOURCE_GANGLION){
                if(ganglion.isCheckingImpedance()){
                    //Stop impedance check
                    ganglion.impedanceStop();
                    startStopCheck.but_txt = "Start Impedance Check";
                } else {
                    // if is running... stopRunning and switch the state of the Start/Stop button back to Data Stream stopped
                    stopRunning();
                    topNav.stopButton.setString(stopButton_pressToStart_txt);
                    topNav.stopButton.setColorNotPressed(color(184, 220, 105));
                    println("Starting Ganlgion impedance check...");
                    //Start impedance check
                    ganglion.impedanceStart();
                    startStopCheck.but_txt = "Stop Impedance Check";
                }
            }
        }
        startStopCheck.setIsActive(false);
    }
};

public float convertRawGanglionImpedanceToTarget(float _actual){
    //the following impedance adjustment calculations were derived using empirical values from resistors between 1,2,3,4,REF-->D_G
    float _target;

    //V1 -- more accurate for lower impedances (< 22kOhcm) -> y = 0.0034x^3 - 0.1443x^2 + 3.1324x - 10.59
    if(_actual <= 22){
        // _target = (0.0004)*(pow(_actual,3)) - (0.0262)*(pow(_actual,2)) + (1.8349)*(_actual) - 6.6006;
        _target = (0.0034f)*(pow(_actual,3)) - (0.1443f)*(pow(_actual,2)) + (3.1324f)*(_actual) - 10.59f;
    }
    //V2 -- more accurate for higher impedances (> 22kOhm) -> y = 0.000009x^4 - 0.001x^3 + 0.0409x^2 + 0.6445x - 1
    else {
        _target = (0.000009f)*(pow(_actual,4)) - (0.001f)*pow(_actual,3) + (0.0409f)*(pow(_actual,2)) + (0.6445f)*(pow(_actual,1)) - 1;
    }

    return _target;
}

////////////////////////////////////////////////////
//
//    W_template.pde (ie "Widget Template")
//
//    This is a Template Widget, intended to be used as a starting point for OpenBCI Community members that want to develop their own custom widgets!
//    Good luck! If you embark on this journey, please let us know. Your contributions are valuable to everyone!
//
//    Created by: Conor Russomanno, November 2016
//    Based on code written by: Chip Audette, Oct 2013
//
///////////////////////////////////////////////////,


float[] smoothFac = new float[]{0.0f, 0.5f, 0.75f, 0.9f, 0.95f, 0.98f}; //used by FFT & Headplot
int smoothFac_ind = 3;    //initial index into the smoothFac array = 0.75 to start .. used by FFT & Head Plots

class W_HeadPlot extends Widget {
    HeadPlot headPlot;

    W_HeadPlot(PApplet _parent){
        super(_parent); //calls the parent CONSTRUCTOR method of Widget (DON'T REMOVE)

        //Headplot settings
        settings.hpIntensitySave = 2;
        settings.hpPolaritySave = 0;
        settings.hpContoursSave = 0;
        settings.hpSmoothingSave = 3;
        //This is the protocol for setting up dropdowns.
        //Note that these 3 dropdowns correspond to the 3 global functions below
        //You just need to make sure the "id" (the 1st String) has the same name as the corresponding function
        // addDropdown("Ten20", "Layout", Arrays.asList("10-20", "5-10"), 0);
        // addDropdown("Headset", "Headset", Arrays.asList("None", "Mark II", "Mark III", "Mark IV "), 0);
        addDropdown("Intensity", "Intensity", Arrays.asList("4x", "2x", "1x", "0.5x", "0.2x", "0.02x"), vertScaleFactor_ind);
        addDropdown("Polarity", "Polarity", Arrays.asList("+/-", " + "), settings.hpPolaritySave);
        addDropdown("ShowContours", "Contours", Arrays.asList("ON", "OFF"), settings.hpContoursSave);
        addDropdown("SmoothingHeadPlot", "Smooth", Arrays.asList("0.0", "0.5", "0.75", "0.9", "0.95", "0.98"), smoothFac_ind);
        //Initialize the headplot
        updateHeadPlot(nchan);
    }

    public void updateHeadPlot(int _nchan) {
        headPlot = new HeadPlot(x, y, w, h, win_x, win_y);
        //FROM old Gui_Manager
        headPlot.setIntensityData_byRef(dataProcessing.data_std_uV, is_railed);
        headPlot.setPolarityData_byRef(dataProcessing.polarity);
        setSmoothFac(smoothFac[smoothFac_ind]);
    }

    public void update(){
        super.update(); //calls the parent update() method of Widget (DON'T REMOVE)
        headPlot.update();
    }

    public void draw(){
        super.draw(); //calls the parent draw() method of Widget (DON'T REMOVE)
        headPlot.draw(); //draw the actual headplot
    }

    public void screenResized(){
        super.screenResized(); //calls the parent screenResized() method of Widget (DON'T REMOVE)
        headPlot.hp_x = x;
        headPlot.hp_y = y;
        headPlot.hp_w = w;
        headPlot.hp_h = h;
        headPlot.hp_win_x = x;
        headPlot.hp_win_y = y;

        thread("doHardCalcs");
    }

    public void mousePressed(){
        super.mousePressed(); //calls the parent mousePressed() method of Widget (DON'T REMOVE)
        headPlot.mousePressed();
    }

    public void mouseReleased(){
        super.mouseReleased(); //calls the parent mouseReleased() method of Widget (DON'T REMOVE)
        headPlot.mouseReleased();
    }

    public void mouseDragged(){
        super.mouseDragged(); //calls the parent mouseReleased() method of Widget (DON'T REMOVE)
        headPlot.mouseDragged();
    }

    //add custom class functions here
    public void setSmoothFac(float fac) {
        headPlot.smooth_fac = fac;
    }
};

//triggered when there is an event in the Polarity Dropdown
public void Polarity(int n) {

    if (n==0) {
        w_headPlot.headPlot.use_polarity = true;
    } else {
        w_headPlot.headPlot.use_polarity = false;
    }
    settings.hpPolaritySave = n;
    closeAllDropdowns(); // do this at the end of all widget-activated functions to ensure proper widget interactivity ... we want to make sure a click makes the menu close
}

public void ShowContours(int n){
    if(n==0){
        //turn headplot contours on
        w_headPlot.headPlot.drawHeadAsContours = true;
    } else if(n==1){
        //turn headplot contours off
        w_headPlot.headPlot.drawHeadAsContours = false;
    }
    settings.hpContoursSave = n;
    closeAllDropdowns();
}

//triggered when there is an event in the SmoothingHeadPlot Dropdown
public void SmoothingHeadPlot(int n) {
    w_headPlot.setSmoothFac(smoothFac[n]);
    settings.hpSmoothingSave = n;
    closeAllDropdowns(); // do this at the end of all widget-activated functions to ensure proper widget interactivity ... we want to make sure a click makes the menu close
}

//triggered when there is an event in the UnfiltFiltHeadPlot Dropdown
public void UnfiltFiltHeadPlot(int n) {
    //currently not in use
    closeAllDropdowns(); // do this at the end of all widget-activated functions to ensure proper widget interactivity ... we want to make sure a click makes the menu close
}

public void Intensity(int n){
    vertScaleFactor_ind = n;
    updateVertScale();
    settings.hpIntensitySave = n;
    closeAllDropdowns();
}

// ----- these variable/methods are used for adjusting the intensity factor of the headplot opacity ---------------------------------------------------------------------------------------------------------
float default_vertScale_uV = 200.0f; //this defines the Y-scale on the montage plots...this is the vertical space between traces
float[] vertScaleFactor = { 0.25f, 0.5f, 1.0f, 2.0f, 5.0f, 50.0f};
int vertScaleFactor_ind = 2;
float vertScale_uV = default_vertScale_uV;

public void setVertScaleFactor_ind(int ind) {
    vertScaleFactor_ind = max(0,ind);
    if (ind >= vertScaleFactor.length) vertScaleFactor_ind = 0;
    updateVertScale();
}

public void updateVertScale() {
    vertScale_uV = default_vertScale_uV * vertScaleFactor[vertScaleFactor_ind];
    w_headPlot.headPlot.setMaxIntensity_uV(vertScale_uV);
}

public void doHardCalcs() {
    if (!w_headPlot.headPlot.threadLock) {
        w_headPlot.headPlot.threadLock = true;
        w_headPlot.headPlot.setPositionSize(w_headPlot.headPlot.hp_x, w_headPlot.headPlot.hp_y, w_headPlot.headPlot.hp_w, w_headPlot.headPlot.hp_h, w_headPlot.headPlot.hp_win_x, w_headPlot.headPlot.hp_win_y);
        w_headPlot.headPlot.hardCalcsDone = true;
        w_headPlot.headPlot.threadLock = false;
    }
}

//---------------------------------------------------------------------------------------------------------------------------------------

//////////////////////////////////////////////////////////////
//
// HeadPlot Class
//
// This class creates and manages the head-shaped plot used by the GUI.
// The head includes circles representing the different EEG electrodes.
// The color (brightness) of the electrodes can be adjusted so that the
// electrodes' brightness values dynamically reflect the intensity of the
// EEG signal.  All EEG processing must happen outside of this class.
//
// Created by: Chip Audette 2013
//
///////////////////////////////////////////////////////////////

// Note: This routine uses aliasing to know which data should be used to
// set the brightness of the electrodes.

class HeadPlot {
    private float rel_posX, rel_posY, rel_width, rel_height;
    private int circ_x, circ_y, circ_diam;
    private int earL_x, earL_y, earR_x, earR_y, ear_width, ear_height;
    private int[] nose_x, nose_y;
    private float[][] electrode_xy;
    private float[] ref_electrode_xy;
    private float[][][] electrode_color_weightFac;
    private int[][] electrode_rgb;
    private float[][] headVoltage;
    private int elec_diam;
    PFont font;
    public float[] intensity_data_uV;
    public float[] polarity_data;
    private DataStatus[] is_railed;
    private float intense_min_uV=0.0f, intense_max_uV=1.0f, assumed_railed_voltage_uV=1.0f;
    private float log10_intense_min_uV = 0.0f, log10_intense_max_uV=1.0f;
    PImage headImage;
    private int image_x, image_y;
    public boolean drawHeadAsContours;
    private boolean plot_color_as_log = true;
    public float smooth_fac = 0.0f;
    private boolean use_polarity = true;
    private int mouse_over_elec_index = -1;
    private boolean isDragging = false;
    private float drag_x, drag_y;
    public int hp_win_x = 0;
    public int hp_win_y = 0;
    public int hp_x = 0;
    public int hp_y = 0;
    public int hp_w = 0;
    public int hp_h = 0;
    public boolean hardCalcsDone = false;
    public boolean threadLock = false;

    HeadPlot(int _x, int _y, int _w, int _h, int _win_x, int _win_y) {
        final int n_elec = nchan;  //set number of electrodes using the global nchan variable
        nose_x = new int[3];
        nose_y = new int[3];
        electrode_xy = new float[n_elec][2];   //x-y position of electrodes (pixels?)
        ref_electrode_xy = new float[2];  //x-y position of reference electrode
        electrode_rgb = new int[3][n_elec];  //rgb color for each electrode
        font = p5;
        drawHeadAsContours = true; //set this to be false for slower computers

        hp_x = _x;
        hp_y = _y;
        hp_w = _w;
        hp_h = _h;
        hp_win_x = _win_x;
        hp_win_y = _win_y;
        thread("doHardCalcs");
        setMaxIntensity_uV(200.0f);  //default intensity scaling for electrodes
    }

    public void setPositionSize(int _x, int _y, int _w, int _h, int _win_x, int _win_y) {
        float percentMargin = 0.1f;
        _x = _x + (int)(PApplet.parseFloat(_w)*percentMargin);
        _y = _y + (int)(PApplet.parseFloat(_h)*percentMargin)-navHeight/2;
        _w = (int)(PApplet.parseFloat(_w)-(2*(PApplet.parseFloat(_w)*percentMargin)));
        _h = (int)(PApplet.parseFloat(_h)-(2*(PApplet.parseFloat(_h)*percentMargin)));

        rel_posX = PApplet.parseFloat(_x)/_win_x;
        rel_posY = PApplet.parseFloat(_y)/_win_y;
        rel_width = PApplet.parseFloat(_w)/_win_x;
        rel_height = PApplet.parseFloat(_h)/_win_y;
        setWindowDimensions(_win_x, _win_y);
    }

    public void setIntensityData_byRef(float[] data, DataStatus[] is_rail) {
        intensity_data_uV = data;  //simply alias the data held externally.  DOES NOT COPY THE DATA ITSEF!  IT'S SIMPLY LINKED!
        is_railed = is_rail;
    }

    public void setPolarityData_byRef(float[] data) {
        polarity_data = data;//simply alias the data held externally.  DOES NOT COPY THE DATA ITSEF!  IT'S SIMPLY LINKED!
    }

    public String getUsePolarityTrueFalse() {
        if (use_polarity) {
            return "True";
        } else {
            return "False";
        }
    }

    public void setMaxIntensity_uV(float val_uV) {
        intense_max_uV = val_uV;
        intense_min_uV = intense_max_uV / 200.0f * 5.0f;  //set to 200, get 5
        assumed_railed_voltage_uV = intense_max_uV;

        log10_intense_max_uV = log10(intense_max_uV);
        log10_intense_min_uV = log10(intense_min_uV);
    }

    public void set_plotColorAsLog(boolean state) {
        plot_color_as_log = state;
    }

    //this method defines all locations of all the subcomponents
    public void setWindowDimensions(int win_width, int win_height) {
        final int n_elec = electrode_xy.length;

        //define the head itself
        float nose_relLen = 0.075f;
        float nose_relWidth = 0.05f;
        float nose_relGutter = 0.02f;
        float ear_relLen = 0.15f;
        float ear_relWidth = 0.075f;

        float square_width = min(rel_width*(float)win_width,
            rel_height*(float)win_height);  //choose smaller of the two

        float total_width = square_width;
        float total_height = square_width;
        float nose_width = total_width * nose_relWidth;
        float nose_height = total_height * nose_relLen;
        ear_width = (int)(ear_relWidth * total_width);
        ear_height = (int)(ear_relLen * total_height);
        int circ_width_foo = (int)(total_width - 2.f*((float)ear_width)/2.0f);
        int circ_height_foo = (int)(total_height - nose_height);
        circ_diam = min(circ_width_foo, circ_height_foo);

        //locations: circle center, measured from upper left
        circ_x = (int)((rel_posX+0.5f*rel_width)*(float)win_width);                  //center of head
        circ_y = (int)((rel_posY+0.5f*rel_height)*(float)win_height + nose_height);  //center of head

        //locations: ear centers, measured from upper left
        earL_x = circ_x - circ_diam/2;
        earR_x = circ_x + circ_diam/2;
        earL_y = circ_y;
        earR_y = circ_y;

        //locations nose vertexes, measured from upper left
        nose_x[0] = circ_x - (int)((nose_relWidth/2.f)*(float)win_width);
        nose_x[1] = circ_x + (int)((nose_relWidth/2.f)*(float)win_width);
        nose_x[2] = circ_x;
        nose_y[0] = circ_y - (int)((float)circ_diam/2.0f - nose_relGutter*(float)win_height);
        nose_y[1] = nose_y[0];
        nose_y[2] = circ_y - (int)((float)circ_diam/2.0f + nose_height);


        //define the electrode positions as the relative position [-1.0 +1.0] within the head
        //remember that negative "Y" is up and positive "Y" is down
        float elec_relDiam = 0.12f; //was 0.1425 prior to 2014-03-23
        elec_diam = (int)(elec_relDiam*((float)circ_diam));
        setElectrodeLocations(n_elec, elec_relDiam);

        //define image to hold all of this
        image_x = PApplet.parseInt(round(circ_x - 0.5f*circ_diam - 0.5f*ear_width));
        image_y = nose_y[2];
        headImage = createImage(PApplet.parseInt(total_width), PApplet.parseInt(total_height), ARGB);

        //initialize the image
        for (int Iy=0; Iy < headImage.height; Iy++) {
            for (int Ix = 0; Ix < headImage.width; Ix++) {
                headImage.set(Ix, Iy, color(0, 0, 0, 0));
            }
        }

        //define the weighting factors to go from the electrode voltages
        //outward to the full the contour plot
        if (false) {
            //here is a simple distance-based algorithm that works every time, though
            //is not really physically accurate.  It looks decent enough
            computePixelWeightingFactors();
        } else {
            //here is the better solution that is more physical.  It involves an iterative
            //solution, which could be really slow or could fail.  If it does poorly,
            //switch to using the algorithm above.
            int n_wide_full = PApplet.parseInt(total_width);
            int n_tall_full = PApplet.parseInt(total_height);
            computePixelWeightingFactors_multiScale(n_wide_full, n_tall_full);
        }
    } //end of method


    private void setElectrodeLocations(int n_elec, float elec_relDiam) {
        //try loading the positions from a file
        int n_elec_to_load = n_elec+1;  //load the n_elec plus the reference electrode
        Table elec_relXY = new Table();
        String default_fname = "electrode_positions_default.txt";
        //String default_fname = "electrode_positions_12elec_scalp9.txt";
        try {
            elec_relXY = loadTable(default_fname, "header,csv"); //try loading the default file
        }
        catch (NullPointerException e) {
        };

        //get the default locations if the file didn't exist
        if ((elec_relXY == null) || (elec_relXY.getRowCount() < n_elec_to_load)) {
            println("headPlot: electrode position file not found or was wrong size: " + default_fname);
            println("        : using defaults...");
            elec_relXY = createDefaultElectrodeLocations(default_fname, elec_relDiam);
        }

        //define the actual locations of the electrodes in pixels
        for (int i=0; i < min(electrode_xy.length, elec_relXY.getRowCount()); i++) {
            electrode_xy[i][0] = circ_x+(int)(elec_relXY.getFloat(i, 0)*((float)circ_diam));
            electrode_xy[i][1] = circ_y+(int)(elec_relXY.getFloat(i, 1)*((float)circ_diam));
        }

        //the referenece electrode is last in the file
        ref_electrode_xy[0] = circ_x+(int)(elec_relXY.getFloat(elec_relXY.getRowCount()-1, 0)*((float)circ_diam));
        ref_electrode_xy[1] = circ_y+(int)(elec_relXY.getFloat(elec_relXY.getRowCount()-1, 1)*((float)circ_diam));
    }

    private Table createDefaultElectrodeLocations(String fname, float elec_relDiam) {

        //regular electrodes
        float[][] elec_relXY = new float[16][2];
        elec_relXY[0][0] = -0.125f;
        elec_relXY[0][1] = -0.5f + elec_relDiam*(0.5f+0.2f); //FP1
        elec_relXY[1][0] = -elec_relXY[0][0];
        elec_relXY[1][1] = elec_relXY[0][1]; //FP2

        elec_relXY[2][0] = -0.2f;
        elec_relXY[2][1] = 0f; //C3
        elec_relXY[3][0] = -elec_relXY[2][0];
        elec_relXY[3][1] = elec_relXY[2][1]; //C4

        elec_relXY[4][0] = -0.3425f;
        elec_relXY[4][1] = 0.27f; //T5 (aka P7)
        elec_relXY[5][0] = -elec_relXY[4][0];
        elec_relXY[5][1] = elec_relXY[4][1]; //T6 (aka P8)

        elec_relXY[6][0] = -0.125f;
        elec_relXY[6][1] = +0.5f - elec_relDiam*(0.5f+0.2f); //O1
        elec_relXY[7][0] = -elec_relXY[6][0];
        elec_relXY[7][1] = elec_relXY[6][1];  //O2

        elec_relXY[8][0] = elec_relXY[4][0];
        elec_relXY[8][1] = -elec_relXY[4][1]; //F7
        elec_relXY[9][0] = -elec_relXY[8][0];
        elec_relXY[9][1] = elec_relXY[8][1]; //F8

        elec_relXY[10][0] = -0.18f;
        elec_relXY[10][1] = -0.15f; //C3
        elec_relXY[11][0] = -elec_relXY[10][0];
        elec_relXY[11][1] = elec_relXY[10][1]; //C4

        elec_relXY[12][0] =  -0.5f +elec_relDiam*(0.5f+0.15f);
        elec_relXY[12][1] = 0f; //T3 (aka T7?)
        elec_relXY[13][0] = -elec_relXY[12][0];
        elec_relXY[13][1] = elec_relXY[12][1]; //T4 (aka T8)

        elec_relXY[14][0] = elec_relXY[10][0];
        elec_relXY[14][1] = -elec_relXY[10][1]; //CP3
        elec_relXY[15][0] = -elec_relXY[14][0];
        elec_relXY[15][1] = elec_relXY[14][1]; //CP4

        //reference electrode
        float[] ref_elec_relXY = new float[2];
        ref_elec_relXY[0] = 0.0f;
        ref_elec_relXY[1] = 0.0f;

        //put it all into a table
        Table table_elec_relXY = new Table();
        table_elec_relXY.addColumn("X", Table.FLOAT);
        table_elec_relXY.addColumn("Y", Table.FLOAT);
        for (int I = 0; I < elec_relXY.length; I++) {
            table_elec_relXY.addRow();
            table_elec_relXY.setFloat(I, "X", elec_relXY[I][0]);
            table_elec_relXY.setFloat(I, "Y", elec_relXY[I][1]);
        }

        //last one is the reference electrode
        table_elec_relXY.addRow();
        table_elec_relXY.setFloat(table_elec_relXY.getRowCount()-1, "X", ref_elec_relXY[0]);
        table_elec_relXY.setFloat(table_elec_relXY.getRowCount()-1, "Y", ref_elec_relXY[1]);

        //try writing it to a file
        String full_fname = "Data\\" + fname;
        try {
            saveTable(table_elec_relXY, full_fname, "csv");
        }
        catch (NullPointerException e) {
            println("headPlot: createDefaultElectrodeLocations: could not write file to " + full_fname);
        };

        //return
        return table_elec_relXY;
    } //end of method

    //Here, we do a two-step solution to get the weighting factors.
    //We do a coarse grid first.  We do our iterative solution on the coarse grid.
    //Then, we formulate the full resolution fine grid.  We interpolate these points
    //from the data resulting from the coarse grid.
    private void computePixelWeightingFactors_multiScale(int n_wide_full, int n_tall_full) {
        int n_elec = electrode_xy.length;

        //define the coarse grid data structures and pixel locations
        int decimation = 10;
        int n_wide_small = n_wide_full / decimation + 1;
        int n_tall_small = n_tall_full / decimation + 1;
        float weightFac[][][] = new float[n_elec][n_wide_small][n_tall_small];
        int pixelAddress[][][] = new int[n_wide_small][n_tall_small][2];
        for (int Ix=0; Ix<n_wide_small; Ix++) {
            for (int Iy=0; Iy<n_tall_small; Iy++) {
                pixelAddress[Ix][Iy][0] = Ix*decimation;
                pixelAddress[Ix][Iy][1] = Iy*decimation;
            };
        };

        //compute the weighting factors of the coarse grid
        computePixelWeightingFactors_trueAverage(pixelAddress, weightFac);

        //define the fine grid data structures
        electrode_color_weightFac = new float[n_elec][n_wide_full][n_tall_full];
        headVoltage = new float[n_wide_full][n_tall_full];

        //interpolate to get the fine grid from the coarse grid
        float dx_frac, dy_frac;
        for (int Ix=0; Ix<n_wide_full; Ix++) {
            int Ix_source = Ix/decimation;
            dx_frac = PApplet.parseFloat(Ix - Ix_source*decimation)/PApplet.parseFloat(decimation);
            for (int Iy=0; Iy < n_tall_full; Iy++) {
                int Iy_source = Iy/decimation;
                dy_frac = PApplet.parseFloat(Iy - Iy_source*decimation)/PApplet.parseFloat(decimation);

                for (int Ielec=0; Ielec<n_elec; Ielec++) {
                    //println("    : Ielec = " + Ielec);
                    if ((Ix_source < (n_wide_small-1)) && (Iy_source < (n_tall_small-1))) {
                        //normal 2-D interpolation
                        electrode_color_weightFac[Ielec][Ix][Iy] = interpolate2D(weightFac[Ielec], Ix_source, Iy_source, Ix_source+1, Iy_source+1, dx_frac, dy_frac);
                    } else if (Ix_source < (n_wide_small-1)) {
                        //1-D interpolation in X
                        dy_frac = 0.0f;
                        electrode_color_weightFac[Ielec][Ix][Iy] = interpolate2D(weightFac[Ielec], Ix_source, Iy_source, Ix_source+1, Iy_source, dx_frac, dy_frac);
                    } else if (Iy_source < (n_tall_small-1)) {
                        //1-D interpolation in Y
                        dx_frac = 0.0f;
                        electrode_color_weightFac[Ielec][Ix][Iy] = interpolate2D(weightFac[Ielec], Ix_source, Iy_source, Ix_source, Iy_source+1, dx_frac, dy_frac);
                    } else {
                        //no interpolation, just use the last value
                        electrode_color_weightFac[Ielec][Ix][Iy] = weightFac[Ielec][Ix_source][Iy_source];
                    }  //close the if block selecting the interpolation configuration
                } //close Ielec loop
            } //close Iy loop
        } // close Ix loop

        //clean up the boundaries of our interpolated results to make the look nicer
        int pixelAddress_full[][][] = new int[n_wide_full][n_tall_full][2];
        for (int Ix=0; Ix<n_wide_full; Ix++) {
            for (int Iy=0; Iy<n_tall_full; Iy++) {
                pixelAddress_full[Ix][Iy][0] = Ix;
                pixelAddress_full[Ix][Iy][1] = Iy;
            };
        };
        cleanUpTheBoundaries(pixelAddress_full, electrode_color_weightFac);
    } //end of method


    private float interpolate2D(float[][] weightFac, int Ix1, int Iy1, int Ix2, int Iy2, float dx_frac, float dy_frac) {
        if (Ix1 >= weightFac.length) {
            println("headPlot: interpolate2D: Ix1 = " + Ix1 + ", weightFac.length = " + weightFac.length);
        }
        float foo1 = (weightFac[Ix2][Iy1] - weightFac[Ix1][Iy1])*dx_frac + weightFac[Ix1][Iy1];
        float foo2 = (weightFac[Ix2][Iy2] - weightFac[Ix1][Iy2])*dx_frac + weightFac[Ix1][Iy2];
        return (foo2 - foo1) * dy_frac + foo1;
    }


    //here is the simpler and more robust algorithm.  It's not necessarily physically real, though.
    //but, it will work every time.  So, if the other method fails, go with this one.
    private void computePixelWeightingFactors() {
        int n_elec = electrode_xy.length;
        float dist;
        int withinElecInd = -1;
        float elec_radius = 0.5f*elec_diam;
        int pixel_x, pixel_y;
        float sum_weight_fac = 0.0f;
        float weight_fac[] = new float[n_elec];
        float foo_dist;

        //loop over each pixel
        for (int Iy=0; Iy < headImage.height; Iy++) {
            pixel_y = image_y + Iy;
            for (int Ix = 0; Ix < headImage.width; Ix++) {
                pixel_x = image_x + Ix;

                if (isPixelInsideHead(pixel_x, pixel_y)==false) {
                    for (int Ielec=0; Ielec < n_elec; Ielec++) {
                        //outside of head...no color from electrodes
                        electrode_color_weightFac[Ielec][Ix][Iy]= -1.0f; //a negative value will be a flag that it is outside of the head
                    }
                } else {
                    //inside of head, compute weighting factors

                    //compute distances of this pixel to each electrode
                    sum_weight_fac = 0.0f; //reset for this pixel
                    withinElecInd = -1;    //reset for this pixel
                    for (int Ielec=0; Ielec < n_elec; Ielec++) {
                        //compute distance
                        dist = max(1.0f, calcDistance(pixel_x, pixel_y, electrode_xy[Ielec][0], electrode_xy[Ielec][1]));
                        if (dist < elec_radius) withinElecInd = Ielec;

                        //compute the first part of the weighting factor
                        foo_dist = max(1.0f, abs(dist - elec_radius));  //remove radius of the electrode
                        weight_fac[Ielec] = 1.0f/foo_dist;  //arbitrarily chosen
                        weight_fac[Ielec] = weight_fac[Ielec]*weight_fac[Ielec]*weight_fac[Ielec];  //again, arbitrary
                        sum_weight_fac += weight_fac[Ielec];
                    }

                    //finalize the weight factor
                    for (int Ielec=0; Ielec < n_elec; Ielec++) {
                        //is this pixel within an electrode?
                        if (withinElecInd > -1) {
                            //yes, it is within an electrode
                            if (Ielec == withinElecInd) {
                                //use this signal electrode as the color
                                electrode_color_weightFac[Ielec][Ix][Iy] = 1.0f;
                            } else {
                                //ignore all other electrodes
                                electrode_color_weightFac[Ielec][Ix][Iy] = 0.0f;
                            }
                        } else {
                            //no, this pixel is not in an electrode.  So, use the distance-based weight factor,
                            //after dividing by the sum of the weight factors, resulting in an averaging operation
                            electrode_color_weightFac[Ielec][Ix][Iy] = weight_fac[Ielec]/sum_weight_fac;
                        }
                    }
                }
            }
        }
    } //end of method

    public void computePixelWeightingFactors_trueAverage(int pixelAddress[][][], float weightFac[][][]) {
        int n_wide = pixelAddress.length;
        int n_tall = pixelAddress[0].length;
        int n_elec = electrode_xy.length;
        int withinElectrode[][] = new int[n_wide][n_tall]; //which electrode is this pixel within (-1 means that it is not within any electrode)
        boolean withinHead[][] = new boolean[n_wide][n_tall]; //is the pixel within the head?
        int toPixels[][][][] = new int[n_wide][n_tall][4][2];
        int toElectrodes[][][] = new int[n_wide][n_tall][4];
        //int numConnections[][] = new int[n_wide][n_tall];
        // println("  HeadPlot B 2 0 -- " + millis());

        //find which pixesl are within the head and which pixels are within an electrode
        whereAreThePixels(pixelAddress, withinHead, withinElectrode);
        // println("  HeadPlot B 2 1 -- " + millis());

        //loop over the pixels and make all the connections
        makeAllTheConnections(withinHead, withinElectrode, toPixels, toElectrodes);
        // println("  HeadPlot B 2 3 -- " + millis());

        //compute the pixel values when lighting up each electrode invididually
        for (int Ielec=0; Ielec<n_elec; Ielec++) {
            computeWeightFactorsGivenOneElectrode_iterative(toPixels, toElectrodes, Ielec, weightFac);
        }
        // println("  HeadPlot B 2 4 -- " + millis());

    }

    private void cleanUpTheBoundaries(int pixelAddress[][][], float weightFac[][][]) {
        int n_wide = pixelAddress.length;
        int n_tall = pixelAddress[0].length;
        int n_elec = electrode_xy.length;
        int withinElectrode[][] = new int[n_wide][n_tall]; //which electrode is this pixel within (-1 means that it is not within any electrode)
        boolean withinHead[][] = new boolean[n_wide][n_tall]; //is the pixel within the head?

        //find which pixels are within the head and which pixels are within an electrode
        whereAreThePixels(pixelAddress, withinHead, withinElectrode);

        //loop over the pixels and change the weightFac to reflext where it is
        for (int Ix=0; Ix<n_wide; Ix++) {
            for (int Iy=0; Iy<n_tall; Iy++) {
                if (withinHead[Ix][Iy]==false) {
                    //this pixel is outside of the head
                    for (int Ielec=0; Ielec<n_elec; Ielec++) {
                        weightFac[Ielec][Ix][Iy]=-1.0f;  //this means to ignore this weight
                    }
                } else {
                    //we are within the head...there are a couple of things to clean up

                    //first, is this a legit value?  It should be >= 0.0.  If it isn't, it was a
                    //quantization problem.  let's clean it up.
                    for (int Ielec=0; Ielec<n_elec; Ielec++) {
                        if (weightFac[Ielec][Ix][Iy] < 0.0f) {
                            weightFac[Ielec][Ix][Iy] = getClosestWeightFac(weightFac[Ielec], Ix, Iy);
                        }
                    }

                    //next, is our pixel within an electrode.  If so, ensure it's weights
                    //set the value to be the same as the electrode
                    if (withinElectrode[Ix][Iy] > -1) {
                        //we are!  set the weightFac to reflect this electrode only
                        for (int Ielec=0; Ielec<n_elec; Ielec++) {
                            weightFac[Ielec][Ix][Iy] = 0.0f; //ignore all other electrodes
                            if (Ielec == withinElectrode[Ix][Iy]) {
                                weightFac[Ielec][Ix][Iy] = 1.0f;  //become equal to this electrode
                            }
                        }
                    } //close "if within electrode"
                } //close "if within head"
            } //close Iy
        } // close Ix
    } //close method

    //find the closest legitimate weightFac
    private float getClosestWeightFac(float weightFac[][], int Ix, int Iy) {
        int n_wide = weightFac.length;
        int n_tall = weightFac[0].length;
        float sum = 0.0f;
        int n_sum = 0;
        float new_weightFac=-1.0f;


        int step = 1;
        int Ix_test, Iy_test;
        boolean done = false;
        boolean anyWithinBounds;
        while (!done) {
            anyWithinBounds = false;

            //search the perimeter at this distance
            sum = 0.0f;
            n_sum = 0;

            //along the top
            Iy_test = Iy + step;
            if ((Iy_test >= 0) && (Iy_test < n_tall)) {
                for (Ix_test=Ix-step; Ix_test<=Ix+step; Ix_test++) {
                    if ((Ix_test >=0) && (Ix_test < n_wide)) {
                        anyWithinBounds=true;
                        if (weightFac[Ix_test][Iy_test] >= 0.0f) {
                            sum += weightFac[Ix_test][Iy_test];
                            n_sum++;
                        }
                    }
                }
            }

            //along the right
            Ix_test = Ix + step;
            if ((Ix_test >= 0) && (Ix_test < n_wide)) {
                for (Iy_test=Iy-step; Iy_test<=Iy+step; Iy_test++) {
                    if ((Iy_test >=0) && (Iy_test < n_tall)) {
                        anyWithinBounds=true;
                        if (weightFac[Ix_test][Iy_test] >= 0.0f) {
                            sum += weightFac[Ix_test][Iy_test];
                            n_sum++;
                        }
                    }
                }
            }
            //along the bottom
            Iy_test = Iy - step;
            if ((Iy_test >= 0) && (Iy_test < n_tall)) {
                for (Ix_test=Ix-step; Ix_test<=Ix+step; Ix_test++) {
                    if ((Ix_test >=0) && (Ix_test < n_wide)) {
                        anyWithinBounds=true;
                        if (weightFac[Ix_test][Iy_test] >= 0.0f) {
                            sum += weightFac[Ix_test][Iy_test];
                            n_sum++;
                        }
                    }
                }
            }

            //along the left
            Ix_test = Ix - step;
            if ((Ix_test >= 0) && (Ix_test < n_wide)) {
                for (Iy_test=Iy-step; Iy_test<=Iy+step; Iy_test++) {
                    if ((Iy_test >=0) && (Iy_test < n_tall)) {
                        anyWithinBounds=true;
                        if (weightFac[Ix_test][Iy_test] >= 0.0f) {
                            sum += weightFac[Ix_test][Iy_test];
                            n_sum++;
                        }
                    }
                }
            }

            if (n_sum > 0) {
                //some good pixels were found, so we have our answer
                new_weightFac = sum / n_sum; //complete the averaging process
                done = true; //we're done
            } else {
                //we did not find any good pixels.  Step outward one more pixel and repeat the search
                step++;  //step outwward
                if (anyWithinBounds) {  //did the last iteration have some pixels that were at least within the domain
                    //some pixels were within the domain, so we have space to try again
                    done = false;
                } else {
                    //no pixels were within the domain.  We're out of space.  We're done.
                    done = true;
                }
            }
        }
        return new_weightFac; //good or bad, return our new value
    }

    private void computeWeightFactorsGivenOneElectrode_iterative(int toPixels[][][][], int toElectrodes[][][], int Ielec, float pixelVal[][][]) {
        //Approach: pretend that one electrode is set to 1.0 and that all other electrodes are set to 0.0.
        //Assume all of the pixels start at zero.  Then, begin the simulation as if it were a transient
        //solution where energy is coming in from the connections.  Any excess energy will accumulate
        //and cause the local pixel's value to increase.  Iterate until the pixel values stabalize.

        int n_wide = toPixels.length;
        int n_tall = toPixels[0].length;
        int n_dir = toPixels[0][0].length;
        float prevVal[][] = new float[n_wide][n_tall];
        float total, dVal;
        int Ix_targ, Iy_targ;
        float min_val=0.0f, max_val=0.0f;
        boolean anyConnections = false;
        int pixel_step = 1;

        //initialize all pixels to zero
        //for (int Ix=0; Ix<n_wide;Ix++) { for (int Iy=0; Iy<n_tall;Iy++) { pixelVal[Ielec][Ix][Iy]=0.0f; }; };

        //define the iteration limits
        int lim_iter_count = 2000;  //set to something big enough to get the job done, but not so big that it could take forever
        float dVal_threshold = 0.00001f;  //set to something arbitrarily small
        float change_fac = 0.2f; //must be small enough to keep this iterative solution stable.  Goes unstable above 0.25

        //begin iteration
        int iter_count = 0;
        float max_dVal = 10.0f*dVal_threshold;  //initilize to large value to ensure that it starts
        while ((iter_count < lim_iter_count) && (max_dVal > dVal_threshold)) {
            //increment the counter
            iter_count++;

            //reset our test value to a large value
            max_dVal = 0.0f;

            //reset other values that I'm using for debugging
            min_val = 1000.0f; //init to a big val
            max_val = -1000.f; //init to a small val

            //copy current values
            for (int Ix=0; Ix<n_wide; Ix++) {
                for (int Iy=0; Iy<n_tall; Iy++) {
                    prevVal[Ix][Iy]=pixelVal[Ielec][Ix][Iy];
                };
            };

            //compute the new pixel values
            for (int Ix=0; Ix<n_wide; Ix+=pixel_step) {
                for (int Iy=0; Iy<n_tall; Iy+=pixel_step) {
                    //reset variables related to this one pixel
                    total=0.0f;
                    anyConnections = false;

                    for (int Idir=0; Idir<n_dir; Idir++) {
                        //do we connect to a real pixel?
                        if (toPixels[Ix][Iy][Idir][0] > -1) {
                            Ix_targ = toPixels[Ix][Iy][Idir][0];  //x index of target pixel
                            Iy_targ = toPixels[Ix][Iy][Idir][1];  //y index of target pixel
                            total += (prevVal[Ix_targ][Iy_targ]-prevVal[Ix][Iy]);  //difference relative to target pixel
                            anyConnections = true;
                        }
                        //do we connect to an electrode?
                        if (toElectrodes[Ix][Iy][Idir] > -1) {
                            //do we connect to the electrode that we're stimulating
                            if (toElectrodes[Ix][Iy][Idir] == Ielec) {
                                //yes, this is the active high one
                                total += (1.0f-prevVal[Ix][Iy]);  //difference relative to HIGH electrode
                            } else {
                                //no, this is a low one
                                total += (0.0f-prevVal[Ix][Iy]);  //difference relative to the LOW electrode
                            }
                            anyConnections = true;
                        }
                    }

                    //compute the new pixel value
                    //if (numConnections[Ix][Iy] > 0) {
                    if (anyConnections) {

                        //dVal = change_fac * (total - float(numConnections[Ix][Iy])*prevVal[Ix][Iy]);
                        dVal = change_fac * total;
                        pixelVal[Ielec][Ix][Iy] = prevVal[Ix][Iy] + dVal;

                        //is this our worst change in value?
                        max_dVal = max(max_dVal, abs(dVal));

                        //update our other debugging values, too
                        min_val = min(min_val, pixelVal[Ielec][Ix][Iy]);
                        max_val = max(max_val, pixelVal[Ielec][Ix][Iy]);
                    } else {
                        pixelVal[Ielec][Ix][Iy] = -1.0f; //means that there are no connections
                    }
                }
            }
            //println("headPlot: computeWeightFactor: Ielec " + Ielec + ", iter = " + iter_count + ", max_dVal = " + max_dVal);
        }
        //println("headPlot: computeWeightFactor: Ielec " + Ielec + ", solution complete with " + iter_count + " iterations. min and max vals = " + min_val + ", " + max_val);
        if (iter_count >= lim_iter_count) println("headPlot: computeWeightFactor: Ielec " + Ielec + ", solution complete with " + iter_count + " iterations. max_dVal = " + max_dVal);
    } //end of method

    private void makeAllTheConnections(boolean withinHead[][], int withinElectrode[][], int toPixels[][][][], int toElectrodes[][][]) {

        int n_wide = toPixels.length;
        int n_tall = toPixels[0].length;
        int n_elec = electrode_xy.length;
        int curPixel, Ipix, Ielec;
        int n_pixels = n_wide * n_tall;
        int Ix_try, Iy_try;

        //loop over every pixel in the image
        for (int Iy=0; Iy < n_tall; Iy++) {
            for (int Ix=0; Ix < n_wide; Ix++) {

                //loop over the four connections: left, right, up, down
                for (int Idirection = 0; Idirection < 4; Idirection++) {

                    Ix_try = -1;
                    Iy_try=-1; //nonsense values
                    switch (Idirection) {
                    case 0:
                        Ix_try = Ix-1;
                        Iy_try = Iy; //left
                        break;
                    case 1:
                        Ix_try = Ix+1;
                        Iy_try = Iy; //right
                        break;
                    case 2:
                        Ix_try = Ix;
                        Iy_try = Iy-1; //up
                        break;
                    case 3:
                        Ix_try = Ix;
                        Iy_try = Iy+1; //down
                        break;
                    }

                    //initalize to no connection
                    toPixels[Ix][Iy][Idirection][0] = -1;
                    toPixels[Ix][Iy][Idirection][1] = -1;
                    toElectrodes[Ix][Iy][Idirection] = -1;

                    //does the target pixel exist
                    if ((Ix_try >= 0) && (Ix_try < n_wide)  && (Iy_try >= 0) && (Iy_try < n_tall)) {
                        //is the target pixel an electrode
                        if (withinElectrode[Ix_try][Iy_try] >= 0) {
                            //the target pixel is within an electrode
                            toElectrodes[Ix][Iy][Idirection] = withinElectrode[Ix_try][Iy_try];
                        } else {
                            //the target pixel is not within an electrode.  is it within the head?
                            if (withinHead[Ix_try][Iy_try]) {
                                toPixels[Ix][Iy][Idirection][0] = Ix_try; //save the address of the target pixel
                                toPixels[Ix][Iy][Idirection][1] = Iy_try; //save the address of the target pixel
                            }
                        }
                    }
                } //end loop over direction of the target pixel
            } //end loop over Ix
        } //end loop over Iy
    } // end of method

    private void whereAreThePixels(int pixelAddress[][][], boolean[][] withinHead, int[][] withinElectrode) {
        int n_wide = pixelAddress.length;
        int n_tall = pixelAddress[0].length;
        int n_elec = electrode_xy.length;
        int pixel_x, pixel_y;
        int withinElecInd=-1;
        float dist;
        float elec_radius = 0.5f*elec_diam;

        for (int Iy=0; Iy < n_tall; Iy++) {
            //pixel_y = image_y + Iy;
            for (int Ix = 0; Ix < n_wide; Ix++) {
                //pixel_x = image_x + Ix;

                pixel_x = pixelAddress[Ix][Iy][0]+image_x;
                pixel_y = pixelAddress[Ix][Iy][1]+image_y;

                //is it within the head
                withinHead[Ix][Iy] = isPixelInsideHead(pixel_x, pixel_y);

                //compute distances of this pixel to each electrode
                withinElecInd = -1;    //reset for this pixel
                for (int Ielec=0; Ielec < n_elec; Ielec++) {
                    //compute distance
                    dist = max(1.0f, calcDistance(pixel_x, pixel_y, electrode_xy[Ielec][0], electrode_xy[Ielec][1]));
                    if (dist < elec_radius) withinElecInd = Ielec;
                }
                withinElectrode[Ix][Iy] = withinElecInd;  //-1 means not inside an electrode
            } //close Ix loop
        } //close Iy loop

        //ensure that each electrode is at at least one pixel
        for (int Ielec=0; Ielec<n_elec; Ielec++) {
            //find closest pixel
            float min_dist = 1.0e10f;  //some huge number
            int best_Ix=0, best_Iy=0;
            for (int Iy=0; Iy < n_tall; Iy++) {
                //pixel_y = image_y + Iy;
                for (int Ix = 0; Ix < n_wide; Ix++) {
                    //pixel_x = image_x + Ix;

                    pixel_x = pixelAddress[Ix][Iy][0]+image_x;
                    pixel_y = pixelAddress[Ix][Iy][1]+image_y;

                    dist = calcDistance(pixel_x, pixel_y, electrode_xy[Ielec][0], electrode_xy[Ielec][1]);
                    ;

                    if (dist < min_dist) {
                        min_dist = dist;
                        best_Ix = Ix;
                        best_Iy = Iy;
                    }
                } //close Iy loop
            } //close Ix loop

            //define this closest point to be within the electrode
            withinElectrode[best_Ix][best_Iy] = Ielec;
        } //close Ielec loop
    } //close method


    //step through pixel-by-pixel to update the image
    private void updateHeadImage() {
        for (int Iy=0; Iy < headImage.height; Iy++) {
            for (int Ix = 0; Ix < headImage.width; Ix++) {
                //is this pixel inside the head?
                if (electrode_color_weightFac[0][Ix][Iy] >= 0.0f) { //zero and positive values are inside the head
                    //it is inside the head.  set the color based on the electrodes
                    headImage.set(Ix, Iy, calcPixelColor(Ix, Iy));
                } else {  //negative values are outside of the head
                    //pixel is outside the head.  set to black.
                    headImage.set(Ix, Iy, color(0, 0, 0, 0));
                }
            }
        }
    }

    private void convertVoltagesToHeadImage() {
        for (int Iy=0; Iy < headImage.height; Iy++) {
            for (int Ix = 0; Ix < headImage.width; Ix++) {
                //is this pixel inside the head?
                if (electrode_color_weightFac[0][Ix][Iy] >= 0.0f) { //zero and positive values are inside the head
                    //it is inside the head.  set the color based on the electrodes
                    headImage.set(Ix, Iy, calcPixelColor(headVoltage[Ix][Iy]));
                } else {  //negative values are outside of the head
                    //pixel is outside the head.  set to black.
                    headImage.set(Ix, Iy, color(0, 0, 0, 0));
                }
            }
        }
    }


    private void updateHeadVoltages() {
        for (int Iy=0; Iy < headImage.height; Iy++) {
            for (int Ix = 0; Ix < headImage.width; Ix++) {
                //is this pixel inside the head?
                if (electrode_color_weightFac[0][Ix][Iy] >= 0.0f) { //zero and positive values are inside the head
                    //it is inside the head.  set the voltage based on the electrodes
                    headVoltage[Ix][Iy] = calcPixelVoltage(Ix, Iy, headVoltage[Ix][Iy]);
                } else {  //negative values are outside of the head
                    //pixel is outside the head.
                    headVoltage[Ix][Iy] = -1.0f;
                }
            }
        }
    }

    int count_call=0;
    private float calcPixelVoltage(int pixel_Ix, int pixel_Iy, float prev_val) {
        float weight, elec_volt;
        int n_elec = electrode_xy.length;
        float voltage = 0.0f;
        float low = intense_min_uV;
        float high = intense_max_uV;

        for (int Ielec=0; Ielec<n_elec; Ielec++) {
            weight = electrode_color_weightFac[Ielec][pixel_Ix][pixel_Iy];
            elec_volt = max(low, min(intensity_data_uV[Ielec], high));

            if (use_polarity) elec_volt = elec_volt*polarity_data[Ielec];

            if (is_railed[Ielec].is_railed) elec_volt = assumed_railed_voltage_uV;
            voltage += weight*elec_volt;
        }

        //smooth in time
        if (smooth_fac > 0.0f) voltage = smooth_fac*prev_val + (1.0f-smooth_fac)*voltage;

        return voltage;
    }


    private int calcPixelColor(float pixel_volt_uV) {
        // float new_rgb[] = {255.0, 0.0, 0.0}; //init to red
        //224, 56, 45
        float new_rgb[] = {224.0f, 56.0f, 45.0f}; //init to red
        // float new_rgb[] = {0.0, 255.0, 0.0}; //init to red
        //54, 87, 158
        if (pixel_volt_uV < 0.0f) {
            //init to blue instead
            new_rgb[0]=54.0f;
            new_rgb[1]=87.0f;
            new_rgb[2]=158.0f;
            // new_rgb[0]=0.0;
            // new_rgb[1]=0.0;
            // new_rgb[2]=255.0;
        }
        float val;


        float intensity = constrain(abs(pixel_volt_uV), intense_min_uV, intense_max_uV);
        if (plot_color_as_log) {
            intensity = map(log10(intensity),
                log10_intense_min_uV,
                log10_intense_max_uV,
                0.0f, 1.0f);
        } else {
            intensity = map(intensity,
                intense_min_uV,
                intense_max_uV,
                0.0f, 1.0f);
        }

        //make the intensity fade NOT from black->color, but from white->color
        for (int i=0; i < 3; i++) {
            val = ((float)new_rgb[i]) / 255.f;
            new_rgb[i] = ((val + (1.0f - val)*(1.0f-intensity))*255.f); //adds in white at low intensity.  no white at high intensity
            new_rgb[i] = constrain(new_rgb[i], 0.0f, 255.0f);
        }

        //quantize the color to make contour-style plot?
        if (true) quantizeColor(new_rgb);

        return color(PApplet.parseInt(new_rgb[0]), PApplet.parseInt(new_rgb[1]), PApplet.parseInt(new_rgb[2]), 255);
    }

    private void quantizeColor(float new_rgb[]) {
        int n_colors = 12;
        int ticks_per_color = 256 / (n_colors+1);
        for (int Irgb=0; Irgb<3; Irgb++) new_rgb[Irgb] = min(255.0f, PApplet.parseFloat(PApplet.parseInt(new_rgb[Irgb]/ticks_per_color))*ticks_per_color);
    }


    //compute the color of the pixel given the location
    private int calcPixelColor(int pixel_Ix, int pixel_Iy) {
        float weight;

        //compute the weighted average using the precomputed factors
        float new_rgb[] = {0.0f, 0.0f, 0.0f}; //init to zeros
        for (int Ielec=0; Ielec < electrode_xy.length; Ielec++) {
            //int Ielec = 0;
            weight = electrode_color_weightFac[Ielec][pixel_Ix][pixel_Iy];
            for (int Irgb=0; Irgb<3; Irgb++) {
                new_rgb[Irgb] += weight*electrode_rgb[Irgb][Ielec];
            }
        }

        //quantize the color to make contour-style plot?
        if (true) quantizeColor(new_rgb);

        return color(PApplet.parseInt(new_rgb[0]), PApplet.parseInt(new_rgb[1]), PApplet.parseInt(new_rgb[2]), 255);
    }

    private float calcDistance(int x, int y, float ref_x, float ref_y) {
        float dx = PApplet.parseFloat(x) - ref_x;
        float dy = PApplet.parseFloat(y) - ref_y;
        return sqrt(dx*dx + dy*dy);
    }

    //compute color for the electrode value
    private void updateElectrodeColors() {
        int rgb[] = new int[]{255, 0, 0}; //color for the electrode when fully light
        float intensity;
        float val;
        int new_rgb[] = new int[3];
        float low = intense_min_uV;
        float high = intense_max_uV;
        float log_low = log10_intense_min_uV;
        float log_high = log10_intense_max_uV;
        for (int Ielec=0; Ielec < electrode_xy.length; Ielec++) {
            intensity = constrain(intensity_data_uV[Ielec], low, high);
            if (plot_color_as_log) {
                intensity = map(log10(intensity), log_low, log_high, 0.0f, 1.0f);
            } else {
                intensity = map(intensity, low, high, 0.0f, 1.0f);
            }

            //make the intensity fade NOT from black->color, but from white->color
            for (int i=0; i < 3; i++) {
                val = ((float)rgb[i]) / 255.f;
                new_rgb[i] = (int)((val + (1.0f - val)*(1.0f-intensity))*255.f); //adds in white at low intensity.  no white at high intensity
                new_rgb[i] = constrain(new_rgb[i], 0, 255);
            }

            //change color to dark RED if railed
            if (is_railed[Ielec].is_railed)  new_rgb = new int[]{127, 0, 0};

            //set the electrode color
            electrode_rgb[0][Ielec] = new_rgb[0];
            electrode_rgb[1][Ielec] = new_rgb[1];
            electrode_rgb[2][Ielec] = new_rgb[2];
        }
    }

    private boolean isMouseOverElectrode(int n){
        float elec_mouse_x_dist = electrode_xy[n][0] - mouseX;
        float elec_mouse_y_dist = electrode_xy[n][1] - mouseY;
        return elec_mouse_x_dist * elec_mouse_x_dist + elec_mouse_y_dist * elec_mouse_y_dist < elec_diam * elec_diam / 4;
    }

    private boolean isDraggedElecInsideHead() {
        int dx = mouseX - circ_x;
        int dy = mouseY - circ_y;
        return dx * dx + dy * dy < (circ_diam - elec_diam) * (circ_diam - elec_diam) / 4;
    }

    public void mousePressed() {
        if (mouse_over_elec_index > -1) {
            isDragging = true;
            drag_x = mouseX - electrode_xy[mouse_over_elec_index][0];
            drag_y = mouseY - electrode_xy[mouse_over_elec_index][1];
        } else {
            isDragging = false;
        }
    }

    public void mouseDragged() {
        if (isDragging && mouse_over_elec_index > -1 && isDraggedElecInsideHead()) {
            electrode_xy[mouse_over_elec_index][0] = mouseX - drag_x;
            electrode_xy[mouse_over_elec_index][1] = mouseY - drag_y;
        }
    }

    public void mouseReleased() {
        isDragging = false;
    }

    public boolean isPixelInsideHead(int pixel_x, int pixel_y) {
        int dx = pixel_x - circ_x;
        int dy = pixel_y - circ_y;
        float r = sqrt(PApplet.parseFloat(dx*dx) + PApplet.parseFloat(dy*dy));
        if (r <= 0.5f*circ_diam) {
            return true;
        } else {
            return false;
        }
    }

    public void update() {
        //do this when new data is available

        //update electrode colors
        updateElectrodeColors();

        if (false) {
            //update the head image
            if (drawHeadAsContours) updateHeadImage();
        } else {
            //update head voltages
            if (!threadLock && hardCalcsDone) {
                updateHeadVoltages();
                convertVoltagesToHeadImage();
            }
        }
    }

    public void draw() {

        pushStyle();
        smooth();
        //draw head parts
        fill(255, 255, 255);
        stroke(125, 125, 125);
        triangle(nose_x[0], nose_y[0], nose_x[1], nose_y[1], nose_x[2], nose_y[2]);  //nose
        ellipse(earL_x, earL_y, ear_width, ear_height); //little circle for the ear
        ellipse(earR_x, earR_y, ear_width, ear_height); //little circle for the ear

        //draw head itself
        fill(255, 255, 255, 255);  //fill in a white head
        strokeWeight(1);
        ellipse(circ_x, circ_y, circ_diam, circ_diam); //big circle for the head
        if (drawHeadAsContours) {
            //add the contnours
            image(headImage, image_x, image_y);
            noFill(); //overlay a circle as an outline, but no fill
            strokeWeight(1);
            ellipse(circ_x, circ_y, circ_diam, circ_diam); //big circle for the head
        }

        //draw electrodes on the head
        if (!isDragging) {
            mouse_over_elec_index = -1;
        }
        for (int Ielec=0; Ielec < electrode_xy.length; Ielec++) {
            if (drawHeadAsContours) {
                noFill(); //make transparent to allow color to come through from below
            } else {
                fill(electrode_rgb[0][Ielec], electrode_rgb[1][Ielec], electrode_rgb[2][Ielec]);
            }
            if (!isDragging && isMouseOverElectrode(Ielec)) {
                //electrode with a bigger index gets priority in dragging
                mouse_over_elec_index = Ielec;
                strokeWeight(2);
            } else if (mouse_over_elec_index == Ielec) {
                strokeWeight(2);
            } else{
                strokeWeight(1);
            }
            ellipse(electrode_xy[Ielec][0], electrode_xy[Ielec][1], elec_diam, elec_diam); //electrode circle
        }

        //add labels to electrodes
        fill(0, 0, 0);
        textFont(font);
        textAlign(CENTER, CENTER);
        for (int i=0; i < electrode_xy.length; i++) {
            //text(Integer.toString(i),electrode_xy[i][0], electrode_xy[i][1]);
            text(i+1, electrode_xy[i][0], electrode_xy[i][1]);
        }
        text("R", ref_electrode_xy[0], ref_electrode_xy[1]);

        popStyle();
    } //end of draw method
};

////////////////////////////////////////////////////
//
//  W_MarkerMode is used to put the board into marker mode
//  by Gerrie van Zyl
//  Basd on W_Analogread by AJ Keller
//
//
///////////////////////////////////////////////////,

class W_MarkerMode extends Widget {
    // color boxBG;
    int graphStroke = 0xffd2d2d2;
    int graphBG = 0xfff5f5f5;
    int textColor = 0xff000000;
    int strokeColor;
    int eggshell;
    int xColor;

    // Accelerometer Stuff
    int markerBuffSize = 500; //points registered in accelerometer buff
    int padding = 30;

    // bottom xyz graph
    int markerWindowWidth;
    int markerWindowHeight;
    int markerWindowX;
    int markerWindowY;

    float yMaxMin;

    int[] makerBuffer;
    int lastMarker=0;
    int localValidLastMarker;

    // for the synthetic markers
    float synthTime;
    int synthCount;

    boolean markerModeOn = false;
    Button markerModeButton;

    W_MarkerMode(PApplet _parent){
        super(_parent); //calls the parent CONSTRUCTOR method of Widget (DON'T REMOVE)

        // boxBG = bgColor;
        strokeColor = color(138, 146, 153);

        // Marker Sensor Stuff
        eggshell = color(255, 253, 248);
        xColor = color(224, 56, 45);

        setGraphDimensions();

        // The range of markers
        yMaxMin = 256;

        // XYZ buffer for bottom graph
        makerBuffer = new int[markerBuffSize];

        // for synthesizing values
        synthTime = 0.0f;

        markerModeButton = new Button((int)(x + 3), (int)(y + 3 - navHeight), 128, navHeight - 6, "Turn MarkerMode On", 12);
        markerModeButton.setCornerRoundess((int)(navHeight-6));
        markerModeButton.setFont(p5,12);
        markerModeButton.setColorNotPressed(color(57,128,204));
        markerModeButton.textColorNotActive = color(255);
        markerModeButton.hasStroke(false);
        markerModeButton.setHelpText("Click this button to activate/deactivate the MarkerMode of your Cyton board!");
    }

    public void update(){
        super.update(); //calls the parent update() method of Widget (DON'T REMOVE)

        localValidLastMarker =  hub.validLastMarker;  // make a local copy so it can be manipulated in SYNTHETIC mode
        hub.validLastMarker = 0;

        if (eegDataSource == DATASOURCE_SYNTHETIC) {
            localValidLastMarker = synthesizeMarkerData();
        }
        if (eegDataSource == DATASOURCE_CYTON || eegDataSource == DATASOURCE_SYNTHETIC) {
            if (isRunning && cyton.getBoardMode() == BoardMode.MARKER) {
                if (localValidLastMarker > 0){
                    lastMarker = localValidLastMarker;  // this holds the last marker for the display
                }
                makerBuffer[makerBuffer.length-1] =
                    PApplet.parseInt(map(logScaleMarker(localValidLastMarker), 0, yMaxMin, PApplet.parseFloat(markerWindowY+markerWindowHeight), PApplet.parseFloat(markerWindowY)));
                makerBuffer[makerBuffer.length-1] = constrain(makerBuffer[makerBuffer.length-1], markerWindowY, markerWindowY+markerWindowHeight);

                shiftWave();
            }
        }
    }

    public void draw(){
        super.draw(); //calls the parent draw() method of Widget (DON'T REMOVE)

        pushStyle();
        //remember to refer to x,y,w,h which are the positioning variables of the Widget class
        if (true) {

            fill(50);
            textFont(p4, 14);
            textAlign(CENTER,CENTER);

            fill(graphBG);
            stroke(graphStroke);
            rect(markerWindowX, markerWindowY, markerWindowWidth, markerWindowHeight);
            line(markerWindowX, markerWindowY + markerWindowHeight/2, markerWindowX+markerWindowWidth, markerWindowY + markerWindowHeight/2); //midline

            fill(50);
            textFont(p5, 12);
            textAlign(CENTER,CENTER);
            text((int)yMaxMin, markerWindowX+markerWindowWidth + 12, markerWindowY);
            text((int)16, markerWindowX+markerWindowWidth + 12, markerWindowY + markerWindowHeight/2);
            text("0", markerWindowX+markerWindowWidth + 12, markerWindowY + markerWindowHeight);


            fill(graphBG);  // pulse window background
            stroke(graphStroke);

            stroke(180);

            fill(50);
            textFont(p3, 16);

            if (eegDataSource == DATASOURCE_CYTON && cyton.getBoardMode() != BoardMode.MARKER) {
                markerModeButton.setString("Turn Marker On");
                markerModeButton.draw();
            } else if (eegDataSource == DATASOURCE_SYNTHETIC) {
                markerModeButton.draw();
                drawMarkerValues();
                drawMarkerWave();
            } else if (eegDataSource == DATASOURCE_PLAYBACKFILE) {  // PLAYBACK
                drawMarkerValues();
                drawMarkerWave2();
            } else {
                markerModeButton.setString("Turn Marker Off");
                markerModeButton.draw();
                drawMarkerValues();
                drawMarkerWave();
            }
        }
        popStyle();
    }

    public void setGraphDimensions(){
        markerWindowWidth = w - padding*2;
        markerWindowHeight = PApplet.parseInt((PApplet.parseFloat(h) - PApplet.parseFloat(padding*3)));
        markerWindowX = x + padding;
        markerWindowY = y + h - markerWindowHeight - padding;

    }

    public void screenResized(){
        int prevX = x;
        int prevY = y;
        int prevW = w;
        int prevH = h;

        super.screenResized(); //calls the parent screenResized() method of Widget (DON'T REMOVE)

        int dy = y - prevY;
        println("dy = " + dy);
        println("Acc Widget -- Screen Resized.");

        setGraphDimensions();

        //empty arrays to start redrawing from scratch
        for (int i=0; i<makerBuffer.length; i++) {  // initialize the accelerometer data
            makerBuffer[i] = markerWindowY + markerWindowHeight; // X at 1/4
        }

        markerModeButton.setPos((int)(x + 3), (int)(y + 3 - navHeight));
    }

    public void mousePressed(){
        super.mousePressed(); //calls the parent mousePressed() method of Widget (DON'T REMOVE)

        if (markerModeButton.isMouseHere()) {
            markerModeButton.setIsActive(true);
        }
    }

    public void mouseReleased(){
        super.mouseReleased(); //calls the parent mouseReleased() method of Widget (DON'T REMOVE)

        if(markerModeButton.isActive && markerModeButton.isMouseHere()){
            if((cyton.isPortOpen() && eegDataSource == DATASOURCE_CYTON) || eegDataSource == DATASOURCE_SYNTHETIC) {
                if (cyton.getBoardMode() != BoardMode.MARKER) {
                    cyton.setBoardMode(BoardMode.MARKER);
                    output("Starting to read markers");
                    markerModeButton.setString("Turn Marker Off");
                    w_analogRead.analogReadOn = false;
                    w_pulsesensor.analogReadOn = false;
                    w_digitalRead.digitalReadOn = false;
                } else {
                    cyton.setBoardMode(BoardMode.DEFAULT);
                    output("Starting to read accelerometer");
                    markerModeButton.setString("Turn Marker On");
                    w_analogRead.analogReadOn = false;
                    w_pulsesensor.analogReadOn = false;
                    w_digitalRead.digitalReadOn = false;
                }
                markerModeOn = !markerModeOn;
            } 
        }
        markerModeButton.setIsActive(false);
    }

    //add custom classes functions here
    public void drawMarkerValues() {
        textAlign(LEFT,CENTER);
        textFont(h1,20);
        fill(xColor);
        text("Last Marker = " + lastMarker, x+padding , y + (h/12)*1.5f);
    }

    public void shiftWave() {
        for (int i = 0; i < makerBuffer.length-1; i++) {      // move the pulse waveform by
            makerBuffer[i] = makerBuffer[i+1];
        }
    }

    public void drawMarkerWave() {
        noFill();
        strokeWeight(2);
        beginShape();                                  // using beginShape() renders fast
        stroke(xColor);
        for (int i = 0; i < makerBuffer.length; i++) {
            // int xi = int(map(i, 0, X.length-1, 0, markerWindowWidth-1));
            // vertex(markerWindowX+xi, X[i]);                    //draw a line connecting the data points
            int xi = PApplet.parseInt(map(i, 0, makerBuffer.length-1, 0, markerWindowWidth-1));
            // int yi = int(map(X[i], yMaxMin, -yMaxMin, 0.0, markerWindowHeight-1));
            // int yi = 2;
            vertex(markerWindowX+xi, makerBuffer[i]);                    //draw a line connecting the data points
        }
        endShape();
    }

    public void drawMarkerWave2() {
        noFill();
        strokeWeight(1);
        beginShape();                                  // using beginShape() renders fast
        stroke(xColor);
        for (int i = 0; i < accelerometerBuff[0].length; i++) {
            int x = PApplet.parseInt(map(accelerometerBuff[0][i], -yMaxMin, yMaxMin, PApplet.parseFloat(markerWindowY+markerWindowHeight), PApplet.parseFloat(markerWindowY)));  // ss
            x = constrain(x, markerWindowY, markerWindowY+markerWindowHeight);
            vertex(markerWindowX+i, x);                    //draw a line connecting the data points
        }
        endShape();
    }

    public int synthesizeMarkerData() {
        synthTime += 0.02f;
        int valueMarker;

        if (synthCount++ > 10){
            valueMarker =  PApplet.parseInt((sin(synthTime) +1.0f)*127.f);
            synthCount = 0;
        } else {
            valueMarker = 0;
        }

        return valueMarker;
    }

    public int logScaleMarker( float value ) {
        // this returns log value between 0 and yMaxMin for a value between 0. and 255.
        return PApplet.parseInt(log(PApplet.parseInt(value)+1.0f)*yMaxMin/log(yMaxMin+1));
    }
};
///////////////////////////////////////////////////////////////////////////////
//
//    W_Networking.pde (Networking Widget)
//
//    This widget provides networking capabilities in the OpenBCI GUI.
//    The networking protocols can be used for outputting data
//    from the OpenBCI GUI to any program that can receive UDP, OSC,
//    or LSL input, such as Matlab, MaxMSP, Python, C/C++, etc.
//
//    The protocols included are: UDP, OSC, and LSL.
//
//
//    Created by: Gabriel Ibagon (github.com/gabrielibagon), January 2017
//
///////////////////////////////////////////////////////////////////////////////


class W_Networking extends Widget {

    /* Variables for protocol selection */
    int protocolIndex;
    String protocolMode;

    /* Widget CP5 */
    ControlP5 cp5_networking;
    ControlP5 cp5_networking_dropdowns;
    ControlP5 cp5_networking_baudRate;
    ControlP5 cp5_networking_portName;

    boolean dataDropdownsShouldBeClosed = false;
    // CColor dropdownColors_networking = new CColor();

    // PApplet ourApplet;

    /* UI Organization */
    /* Widget grid */
    int column0;
    int column1;
    int column2;
    int column3;
    int column4;
    int fullColumnWidth;
    int halfWidth;
    int row0;
    int row1;
    int row2;
    int row3;
    int row4;
    int row5;
    int itemWidth = 96;
    private final float datatypeDropdownScaling = .35f;

    /* UI */
    Boolean osc_visible;
    Boolean udp_visible;
    Boolean lsl_visible;
    Boolean serial_visible;
    List<String> dataTypes;
    Button startButton;
    Boolean cp5ElementsAreActive = false;
    Boolean previousCP5State = false;
    Button guideButton;
    Button dataOutputsButton;

    /* Networking */
    Boolean networkActive;

    /* Streams Objects */
    Stream stream1;
    Stream stream2;
    Stream stream3;
    Stream stream4;

    List<String> baudRates;
    List<String> comPorts;
    private int comPortToSave;
    String defaultBaud;
    String[] datatypeNames = {"dataType1","dataType2","dataType3","dataType4"};
    String[] oscTextFieldNames = {
        "OSC_ip1","OSC_port1","OSC_address1",
        "OSC_ip2","OSC_port2","OSC_address2",
        "OSC_ip3","OSC_port3","OSC_address3",
        "OSC_ip4","OSC_port4","OSC_address4"};
    String[] oscTextDefaultVals = {
        "127.0.0.1","12345","/openbci",
        "127.0.0.1","12346","/openbci",
        "127.0.0.1","12347","/openbci",
        "127.0.0.1","12348","/openbci"};
    String[] udpTextFieldNames = {
        "UDP_ip1","UDP_port1",
        "UDP_ip2","UDP_port2",
        "UDP_ip3","UDP_port3"};
    String[] udpTextDefaultVals = {
        "127.0.0.1","12345",
        "127.0.0.1","12346",
        "127.0.0.1","12347",
        "127.0.0.1","12348"};
    String[] lslTextFieldNames = {
        "LSL_name1","LSL_type1","LSL_numchan1",
        "LSL_name2","LSL_type2","LSL_numchan2",
        "LSL_name3","LSL_type3","LSL_numchan3"};
    String[] lslTextDefaultVals = {
        "obci_eeg1","EEG",Integer.toString(nchan),
        "obci_eeg2","EEG",Integer.toString(nchan),
        "obci_eeg3","EEG",Integer.toString(nchan)};
    String networkingGuideURL = "https://openbci.github.io/Documentation/docs/06Software/01-OpenBCISoftware/GUIWidgets#networking";
    String dataOutputsURL = "https://docs.google.com/document/d/e/2PACX-1vR_4DXPTh1nuiOwWKwIZN3NkGP3kRwpP4Hu6fQmy3jRAOaydOuEI1jket6V4V6PG4yIG15H1N7oFfdV/pub";
    boolean configIsVisible = false;
    boolean layoutIsVisible = false;

    HashMap<String, Object> cp5Map = new HashMap<String, Object>();

    W_Networking(PApplet _parent) {
        super(_parent);
        // ourApplet = _parent;

        networkActive = false;
        stream1 = null;
        stream2 = null;
        stream3 = null;
        stream4 = null;

        //default data types for streams 1-4 in Networking widget
        settings.nwDataType1 = 0;
        settings.nwDataType2 = 0;
        settings.nwDataType3 = 0;
        settings.nwDataType4 = 0;
        settings.nwSerialPort = "None";
        settings.nwProtocolSave = protocolIndex; //save default protocol index, or 0, updates in the Protocol() function
        
        dataTypes = new LinkedList<String>(Arrays.asList(settings.nwDataTypesArray)); //Add any new widgets capable of streaming here
        //Only show pulse data type when using Cyton in Live
        if (eegDataSource != DATASOURCE_CYTON) {
            dataTypes.remove("Pulse");
        }
        defaultBaud = "115200";
        baudRates = Arrays.asList(settings.nwBaudRatesArray);
        protocolMode = "Serial"; //default to Serial
        addDropdown("Protocol", "Protocol", Arrays.asList(settings.nwProtocolArray), protocolIndex);
        comPorts = new ArrayList<String>(Arrays.asList(Serial.list()));
        verbosePrint("comPorts = " + comPorts);
        comPortToSave = 0;


        initialize_UI();
        cp5_networking.setAutoDraw(false);
        cp5_networking_dropdowns.setAutoDraw(false);
        cp5_networking_portName.setAutoDraw(false);
        cp5_networking_baudRate.setAutoDraw(false);

        fetchCP5Data();
    }

    //Used to update the Hashmap
    public void fetchCP5Data() {
        for (int i = 0; i < datatypeNames.length; i++) {
            //datatypes
            cp5Map.put(datatypeNames[i], PApplet.parseInt(cp5_networking_dropdowns.get(ScrollableList.class, datatypeNames[i]).getValue()));
            //filter radio buttons
            String filterName = "filter" + (i+1);
            cp5Map.put(filterName, PApplet.parseInt(cp5_networking.get(RadioButton.class, filterName).getValue()));
        }
        //osc textfields
        copyCP5TextToMap(oscTextFieldNames, cp5Map);
        //udp textfields
        copyCP5TextToMap(udpTextFieldNames, cp5Map);
        //lsl textfields
        copyCP5TextToMap(lslTextFieldNames, cp5Map);
        //Serial baud rate and port name
        cp5Map.put("baud_rate", PApplet.parseInt(cp5_networking_baudRate.get(ScrollableList.class, "baud_rate").getValue()));
        String s = cp5_networking_portName.get(ScrollableList.class, "port_name").getItem(comPortToSave).get("name").toString();
        cp5Map.put("port_name", s);
        //println(cp5Map);
    }

    private void copyCP5TextToMap(String[] keys, HashMap m) {
        for (int i = 0; i < keys.length; i++) {
            m.put(keys[i], cp5_networking.get(Textfield.class, keys[i]).getText());
        }
    }

    public Map getCP5Map() {
        return cp5Map;
    }

    /* ----- USER INTERFACE ----- */

    public void update() {
        super.update();
        if (protocolMode.equals("LSL")) {
            if (stream1!=null) {
                stream1.run();
            }
            if (stream2!=null) {
                stream2.run();
            }
            if (stream3!=null) {
                stream3.run();
            }
            //Setting this var here fixes #592 to allow multiple LSL streams
            dataProcessing.newDataToSend = false;
        }

        checkTopNovEvents();

        //ignore top left button interaction when widgetSelector dropdown is active
        ignoreButtonCheck(guideButton);
        ignoreButtonCheck(dataOutputsButton);

        if (dataDropdownsShouldBeClosed) { //this if takes care of the scenario where you select the same widget that is active...
            dataDropdownsShouldBeClosed = false;
        } else {
            openCloseDropdowns();
        }

        if (protocolMode.equals("OSC")) {
            cp5ElementsAreActive = textfieldsAreActive(oscTextFieldNames);
        } else if (protocolMode.equals("UDP")) {
            cp5ElementsAreActive = textfieldsAreActive(udpTextFieldNames);
        } else if (protocolMode.equals("LSL")) {
            cp5ElementsAreActive = textfieldsAreActive(lslTextFieldNames);
        } else {
            //For serial mode, disable fft output by switching to bandpower instead
            this.disableCertainOutputs((int)getCP5Map().get(datatypeNames[0]));
        }

        if (cp5ElementsAreActive != previousCP5State) {
            if (!cp5ElementsAreActive) {
                //Cp5 textfield elements state change from 1 to 0, so save cp5 data
                fetchCP5Data();
            }
            previousCP5State = cp5ElementsAreActive;
        }


    } //end update()

    public Boolean textfieldsAreActive(String[] names) {
        boolean isActive = false;
        for (String name : names) {
            if (cp5_networking.get(Textfield.class, name).isFocus()) {
                isActive = true;
            }
        }
        return isActive;
    }

    public void draw() {
        super.draw();
        pushStyle();

        showCP5();

        cp5_networking.draw();

        //draw dropdown strokes
        pushStyle();
        fill(255);
        if (!protocolMode.equals("Serial")) {
            for (int i = 0; i < datatypeNames.length; i++) {
                rect(cp5_networking_dropdowns.getController(datatypeNames[i]).getPosition()[0] - 1, cp5_networking_dropdowns.getController(datatypeNames[i]).getPosition()[1] - 1, itemWidth + 2, cp5_networking_dropdowns.getController(datatypeNames[i]).getHeight()+2);
            }
        } else {
            rect(cp5_networking_portName.getController("port_name").getPosition()[0] - 1, cp5_networking_portName.getController("port_name").getPosition()[1] - 1, cp5_networking_portName.getController("port_name").getWidth() + 2, cp5_networking_portName.getController("port_name").getHeight()+2);
            cp5_networking_portName.draw();
            rect(cp5_networking_baudRate.getController("baud_rate").getPosition()[0] - 1, cp5_networking_baudRate.getController("baud_rate").getPosition()[1] - 1, cp5_networking_baudRate.getController("baud_rate").getWidth() + 2, cp5_networking_baudRate.getController("baud_rate").getHeight()+2);
            cp5_networking_baudRate.draw();
            rect(cp5_networking_dropdowns.getController("dataType1").getPosition()[0] - 1, cp5_networking_dropdowns.getController("dataType1").getPosition()[1] - 1, cp5_networking_dropdowns.getController("dataType1").getWidth() + 2, cp5_networking_dropdowns.getController("dataType1").getHeight()+2);
        }
        cp5_networking_dropdowns.draw();
        popStyle();

        // cp5_networking_dropdowns.draw();
        int headerFontSize = 18;
        fill(0,0,0);// Background fill: white
        textFont(h1, headerFontSize);

        if (!protocolMode.equals("Serial")) {
            text(" Stream 1",column1,row0);
            text(" Stream 2",column2,row0);
            text(" Stream 3",column3,row0);
        }
        if (protocolMode.equals("OSC")) {
            text(" Stream 4",column4,row0);
        }
        text("Data Type",column0,row1);

        startButton.draw();
        guideButton.draw();
        dataOutputsButton.draw();

        if (protocolMode.equals("OSC")) {
            textFont(f4,40);
            text("OSC", x+20,y+h/8+15);
            textFont(h1,headerFontSize);
            text("IP", column0,row2);
            text("Port", column0,row3);
            text("Address",column0,row4);
            text("Filters",column0,row5);
        } else if (protocolMode.equals("UDP")) {
            textFont(f4,40);
            text("UDP", x+20,y+h/8+15);
            textFont(h1,headerFontSize);
            text("IP", column0,row2);
            text("Port", column0,row3);
            text("Filters",column0,row4);
        } else if (protocolMode.equals("LSL")) {
            textFont(f4,40);
            text("LSL", x+20,y+h/8+15);
            textFont(h1,headerFontSize);
            text("Name", column0,row2);
            text("Type", column0,row3);
            text("# Chan", column0, row4);
        } else if (protocolMode.equals("Serial")) {
            textFont(f4,40);
            text("Serial", x+20,y+h/8+15);
            textFont(h1,headerFontSize);
            text("Baud/Port", column0,row2);
            // text("Port Name", column0,row3);
            text("Filters",column0,row3);
        }
        popStyle();

    }

    public void initialize_UI() {
        cp5_networking = new ControlP5(pApplet);
        cp5_networking_dropdowns = new ControlP5(pApplet);
        cp5_networking_baudRate = new ControlP5(pApplet);
        cp5_networking_portName = new ControlP5(pApplet);

        /* Textfields */
        // OSC
        createTextFields(oscTextFieldNames, oscTextDefaultVals);
        // UDP
        createTextFields(udpTextFieldNames, udpTextDefaultVals);
        // LSL
        createTextFields(lslTextFieldNames, lslTextDefaultVals);

        // Serial
        //grab list of existing serial port options and store into Arrays.list...
        boolean noComPortsFound = comPorts.size() == 0 ? true : false;
        createPortDropdown("port_name", comPorts, noComPortsFound);
        createBaudDropdown("baud_rate", baudRates);
        /* General Elements */

        createRadioButtons("filter1");
        createRadioButtons("filter2");
        createRadioButtons("filter3");
        createRadioButtons("filter4");

        for (int i = 0; i < datatypeNames.length; i++) {
            createDropdown(datatypeNames[i], dataTypes);
        }

        // Start Button
        startButton = new Button(x + w/2 - 70,y+h-40,200,20,"Start",14);
        startButton.setFont(p4,14);
        startButton.setColorNotPressed(color(184,220,105));
        startButton.setHelpText("Click here to Start and Stop the network stream for the chosen protocol.");

        // Networking Guide button
        guideButton = new Button(x0 + 2, y0 + navH + 2, 125, navH - 6,"Networking Guide", 14);
        guideButton.setCornerRoundess((int)(navHeight-6));
        guideButton.setFont(p5,12);
        guideButton.setColorNotPressed(color(57,128,204));
        guideButton.setFontColorNotActive(color(255));
        guideButton.setHelpText("Click to open the Networking Widget Guide in your default browser.");
        guideButton.setURL(networkingGuideURL);
        guideButton.hasStroke(false);

        //Data outputs spreadsheet button
        // Networking Data Type Guide button
        dataOutputsButton = new Button(x0 + 2*2 + guideButton.but_dx, y0 + navH + 2, 100, navH - 6,"Data Outputs", 14);
        dataOutputsButton.setCornerRoundess((int)(navHeight-6));
        dataOutputsButton.setFont(p5,12);
        dataOutputsButton.setColorNotPressed(color(57,128,204));
        dataOutputsButton.setFontColorNotActive(color(255));
        dataOutputsButton.setHelpText("Click to open the Networking Data Outputs Guide in your default browser.");
        dataOutputsButton.setURL(dataOutputsURL);
        dataOutputsButton.hasStroke(false);
    }

    /* Shows and Hides appropriate CP5 elements within widget */
    public void showCP5() {

        osc_visible=false;
        udp_visible=false;
        lsl_visible=false;
        serial_visible=false;

        if (protocolMode.equals("OSC")) {
            osc_visible = true;
        } else if (protocolMode.equals("UDP")) {
            udp_visible = true;
        } else if (protocolMode.equals("LSL")) {
            lsl_visible = true;
        } else if (protocolMode.equals("Serial")) {
            serial_visible = true;
        }

        setTextFieldVisible(oscTextFieldNames, osc_visible);
        setTextFieldVisible(udpTextFieldNames, udp_visible);
        setTextFieldVisible(lslTextFieldNames, lsl_visible);

        cp5_networking_portName.get(ScrollableList.class, "port_name").setVisible(serial_visible);
        cp5_networking_baudRate.get(ScrollableList.class, "baud_rate").setVisible(serial_visible);

        cp5_networking_dropdowns.get(ScrollableList.class, "dataType1").setVisible(true);
        if (!serial_visible) {
            cp5_networking_dropdowns.get(ScrollableList.class, "dataType2").setVisible(true);
            cp5_networking_dropdowns.get(ScrollableList.class, "dataType3").setVisible(true);
        } else{
            cp5_networking_dropdowns.get(ScrollableList.class, "dataType2").setVisible(false);
            cp5_networking_dropdowns.get(ScrollableList.class, "dataType3").setVisible(false);
        }

        //Draw a 4th Data Type dropdown menu if we are using OSC!
        if (protocolMode.equals("OSC")) {
            cp5_networking_dropdowns.get(ScrollableList.class, "dataType4").setVisible(true);
        } else {
            cp5_networking_dropdowns.get(ScrollableList.class, "dataType4").setVisible(false);
        }

        cp5_networking.get(RadioButton.class, "filter1").setVisible(true);
        if (!serial_visible) {
            cp5_networking.get(RadioButton.class, "filter2").setVisible(true);
            cp5_networking.get(RadioButton.class, "filter3").setVisible(true);
        } else {
            cp5_networking.get(RadioButton.class, "filter2").setVisible(false);
            cp5_networking.get(RadioButton.class, "filter3").setVisible(false);
        }
        //Draw a 4th Filter button option if we are using OSC!
        if (protocolMode.equals("OSC")) {
            cp5_networking.get(RadioButton.class, "filter4").setVisible(true);
        } else {
            cp5_networking.get(RadioButton.class, "filter4").setVisible(false);
        }
    }

    public void setTextFieldVisible(String[] textFieldNames, boolean isVisible) {
        for (int i = 0; i < textFieldNames.length; i++) {
            cp5_networking.get(Textfield.class, textFieldNames[i]).setVisible(isVisible);
        }
    }

    //Lock text fields by setting _lock = true, unlock using false
    public void lockTextFields(String[] textFieldNames, boolean _lock) {
        for (int i = 0; i < textFieldNames.length; i++) {
            if (_lock) {
                cp5_networking.get(Textfield.class, textFieldNames[i]).lock();
            } else {
                cp5_networking.get(Textfield.class, textFieldNames[i]).unlock();
            }
        }
    }

    public void createTextFields(String[] textFieldNames, String[] defaultValues) {
        for (int i = 0; i < textFieldNames.length; i++) {
            createTextField(textFieldNames[i], defaultValues[i]);
        }
    }

    /* Create textfields for network parameters */
    public void createTextField(String name, String default_text) {
        cp5_networking.addTextfield(name)
            .align(10,100,10,100)                   // Alignment
            .setSize(120,20)                         // Size of textfield
            .setFont(f2)
            .setFocus(false)                        // Deselects textfield
            .setColor(color(26,26,26))
            .setColorBackground(color(255,255,255)) // text field bg color
            .setColorValueLabel(color(0,0,0))       // text color
            .setColorForeground(color(26,26,26))    // border color when not selected
            .setColorActive(isSelected_color)       // border color when selected
            .setColorCursor(color(26,26,26))
            .setText(default_text)                  // Default text in the field
            .setCaptionLabel("")                    // Remove caption label
            .setVisible(false)                      // Initially hidden
            .setAutoClear(true)                     // Autoclear
            ;
    }

    /* Create radio buttons for filter toggling */
    public void createRadioButtons(String name) {
        String id = name.substring(name.length()-1);
        cp5_networking.addRadioButton(name)
                .setSize(10,10)
                .setColorForeground(color(120))
                .setColorBackground(color(200,200,200)) // text field bg color
                .setColorActive(color(184,220,105))
                .setColorLabel(color(0))
                .setItemsPerRow(2)
                .setSpacingColumn(40)
                .addItem(id + "-Off", 0)
                .addItem(id + "-On", 1)
                // .addItem("Off",0)
                // .addItem("On",1)
                .activate(0)
                .setVisible(false)
                ;
    }

    /* Creating DataType Dropdowns */
    public void createDropdown(String name, List<String> _items) {

        cp5_networking_dropdowns.addScrollableList(name)
                .setOpen(false)

                .setColorBackground(color(31,69,110)) // text field bg color
                .setColorValueLabel(color(255))       // text color
                .setColorCaptionLabel(color(255))
                .setColorForeground(color(125))    // border color when not selected
                .setColorActive(color(150, 170, 200))       // border color when selected
                // .setColorCursor(color(26,26,26))

                .setSize(itemWidth,(_items.size()+1)*(navH-4))// + maxFreqList.size())
                .setBarHeight(navH-4) //height of top/primary bar
                .setItemHeight(navH-4) //height of all item/dropdown bars
                .addItems(_items) // used to be .addItems(maxFreqList)
                .setVisible(false)
                ;
        cp5_networking_dropdowns.getController(name)
            .getCaptionLabel() //the caption label is the text object in the primary bar
            .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
            .setText("None")
            .setFont(h4)
            .setSize(14)
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(4)
            ;
        cp5_networking_dropdowns.getController(name)
            .getValueLabel() //the value label is connected to the text objects in the dropdown item bars
            .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
            .setText("None")
            .setFont(h5)
            .setSize(12) //set the font size of the item bars to 14pt
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(3) //4-pixel vertical offset to center text
            ;
    }

    public void createBaudDropdown(String name, List<String> _items) {
        cp5_networking_baudRate.addScrollableList(name)
                .setOpen(false)

                .setColorBackground(color(31,69,110)) // text field bg color
                .setColorValueLabel(color(255))       // text color
                .setColorCaptionLabel(color(255))
                .setColorForeground(color(125))    // border color when not selected
                .setColorActive(color(150, 170, 200))       // border color when selected
                // .setColorCursor(color(26,26,26))

                .setSize(itemWidth,(_items.size()+1)*(navH-4))// + maxFreqList.size())
                .setBarHeight(navH-4) //height of top/primary bar
                .setItemHeight(navH-4) //height of all item/dropdown bars
                .addItems(_items) // used to be .addItems(maxFreqList)
                .setVisible(false)
                ;
        cp5_networking_baudRate.getController(name)
            .getCaptionLabel() //the caption label is the text object in the primary bar
            .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
            .setText(defaultBaud)
            .setFont(h4)
            .setSize(14)
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(4)
            ;
        cp5_networking_baudRate.getController(name)
            .getValueLabel() //the value label is connected to the text objects in the dropdown item bars
            .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
            .setText("None")
            .setFont(h5)
            .setSize(12) //set the font size of the item bars to 14pt
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(3) //4-pixel vertical offset to center text
            ;
    }

    public void createPortDropdown(String name, List<String> _items, boolean isEmpty) {
        if (isEmpty) _items.add("None"); // Fix #642 and #637
        cp5_networking_portName.addScrollableList(name)
            .setOpen(false)
            .setColorBackground(color(31,69,110)) // text field bg color
            .setColorValueLabel(color(255))       // text color
            .setColorCaptionLabel(color(255))
            .setColorForeground(color(125))    // border color when not selected
            .setColorActive(color(150, 170, 200))       // border color when selected
            // .setColorCursor(color(26,26,26))
            .setSize(itemWidth,(_items.size()+1)*(navH-4))// + maxFreqList.size())
            .setBarHeight(navH-4) //height of top/primary bar
            .setItemHeight(navH-4) //height of all item/dropdown bars
            .addItems(_items) // used to be .addItems(maxFreqList)
            .setVisible(false)
            ;
        cp5_networking_portName.getController(name)
            .getCaptionLabel() //the caption label is the text object in the primary bar
            .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
            .setText("None")
            .setFont(h4)
            .setSize(14)
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(4)
            ;
        cp5_networking_portName.getController(name)
            .getValueLabel() //the value label is connected to the text objects in the dropdown item bars
            .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
            .setText("None")
            .setFont(h5)
            .setSize(12) //set the font size of the item bars to 14pt
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(3) //4-pixel vertical offset to center text
            ;
    }

    public void screenResized() {
        super.screenResized();

        cp5_networking.setGraphics(pApplet, 0,0);
        cp5_networking_dropdowns.setGraphics(pApplet, 0,0);
        cp5_networking_baudRate.setGraphics(pApplet, 0,0);
        cp5_networking_portName.setGraphics(pApplet, 0,0);

        column0 = x+w/22-12;
        int widthd = 46;//This value has been fine-tuned to look proper in windowed mode 1024*768 and fullscreen on 1920x1080
        column1 = x+12*w/widthd-25;//This value has been fine-tuned to look proper in windowed mode 1024*768 and fullscreen on 1920x1080
        column2 = x+(12+9*1)*w/widthd-25;
        column3 = x+(12+9*2)*w/widthd-25;
        column4 = x+(12+9*3)*w/widthd-25;
        halfWidth = (column2+100) - column1;
        fullColumnWidth = (column4+100) - column1;
        row0 = y+h/4+10;
        row1 = y+4*h/10;
        row2 = y+5*h/10;
        row3 = y+6*h/10;
        row4 = y+7*h/10;
        row5 = y+8*h/10;
        int offset = 15;//This value has been fine-tuned to look proper in windowed mode 1024*768 and fullscreen on 1920x1080

        //reset the button positions using new x and y
        startButton.setPos(x + w/2 - 70, y + h - 40 );
        guideButton.setPos(x0 + 2, y0 + navH + 2);
        dataOutputsButton.setPos(x0 + 2*2 + guideButton.but_dx , y0 + navH + 2);

        //scale the item width of all elements in the networking widget
        itemWidth = PApplet.parseInt(map(width, 1024, 1920, 100, 120)) - 4;
        
        int dropdownsItemsToShow = PApplet.parseInt((this.h0 * datatypeDropdownScaling) / (this.navH - 4));
        println("Networking Data Types || show num dropdowns = " + dropdownsItemsToShow);
        int dropdownHeight = (dropdownsItemsToShow + 1) * (this.navH - 4);
        int maxDropdownHeight = (settings.nwDataTypesArray.length + 1) * (this.navH - 4);
        if (dropdownHeight > maxDropdownHeight) dropdownHeight = maxDropdownHeight;

        for (String datatypeName : datatypeNames) {
            cp5_networking_dropdowns.get(ScrollableList.class, datatypeName).setSize(itemWidth, dropdownHeight);
        }

        if (protocolMode.equals("OSC")) {
            for (String textField : oscTextFieldNames) {
                cp5_networking.get(Textfield.class, textField).setWidth(itemWidth);
            }
            cp5_networking.get(Textfield.class, "OSC_ip1").setPosition(column1, row2 - offset);
            cp5_networking.get(Textfield.class, "OSC_port1").setPosition(column1, row3 - offset);
            cp5_networking.get(Textfield.class, "OSC_address1").setPosition(column1, row4 - offset);
            cp5_networking.get(Textfield.class, "OSC_ip2").setPosition(column2, row2 - offset);
            cp5_networking.get(Textfield.class, "OSC_port2").setPosition(column2, row3 - offset);
            cp5_networking.get(Textfield.class, "OSC_address2").setPosition(column2, row4 - offset);
            cp5_networking.get(Textfield.class, "OSC_ip3").setPosition(column3, row2 - offset);
            cp5_networking.get(Textfield.class, "OSC_port3").setPosition(column3, row3 - offset);
            cp5_networking.get(Textfield.class, "OSC_address3").setPosition(column3, row4 - offset);
            cp5_networking.get(Textfield.class, "OSC_ip4").setPosition(column4, row2 - offset);
            cp5_networking.get(Textfield.class, "OSC_port4").setPosition(column4, row3 - offset);
            cp5_networking.get(Textfield.class, "OSC_address4").setPosition(column4, row4 - offset); //adding forth column only for OSC
            cp5_networking.get(RadioButton.class, "filter1").setPosition(column1, row5 - 10);
            cp5_networking.get(RadioButton.class, "filter2").setPosition(column2, row5 - 10);
            cp5_networking.get(RadioButton.class, "filter3").setPosition(column3, row5 - 10);
            cp5_networking.get(RadioButton.class, "filter4").setPosition(column4, row5 - 10);
        } else if (protocolMode.equals("UDP")) {
            for (String textField : udpTextFieldNames) {
                cp5_networking.get(Textfield.class, textField).setWidth(itemWidth);
            }
            cp5_networking.get(Textfield.class, "UDP_ip1").setPosition(column1, row2 - offset);
            cp5_networking.get(Textfield.class, "UDP_port1").setPosition(column1, row3 - offset);
            cp5_networking.get(Textfield.class, "UDP_ip2").setPosition(column2, row2 - offset);
            cp5_networking.get(Textfield.class, "UDP_port2").setPosition(column2, row3 - offset);
            cp5_networking.get(Textfield.class, "UDP_ip3").setPosition(column3, row2 - offset);
            cp5_networking.get(Textfield.class, "UDP_port3").setPosition(column3, row3 - offset);
            cp5_networking.get(RadioButton.class, "filter1").setPosition(column1, row4 - 10);
            cp5_networking.get(RadioButton.class, "filter2").setPosition(column2, row4 - 10);
            cp5_networking.get(RadioButton.class, "filter3").setPosition(column3, row4 - 10);
        } else if (protocolMode.equals("LSL")) {
            for (String textField : lslTextFieldNames) {
                cp5_networking.get(Textfield.class, textField).setWidth(itemWidth);
            }
            cp5_networking.get(Textfield.class, "LSL_name1").setPosition(column1,row2 - offset);
            cp5_networking.get(Textfield.class, "LSL_type1").setPosition(column1,row3 - offset);
            cp5_networking.get(Textfield.class, "LSL_numchan1").setPosition(column1,row4 - offset);
            cp5_networking.get(Textfield.class, "LSL_name2").setPosition(column2,row2 - offset);
            cp5_networking.get(Textfield.class, "LSL_type2").setPosition(column2,row3 - offset);
            cp5_networking.get(Textfield.class, "LSL_numchan2").setPosition(column2,row4 - offset);
            cp5_networking.get(Textfield.class, "LSL_name3").setPosition(column3,row2 - offset);
            cp5_networking.get(Textfield.class, "LSL_type3").setPosition(column3,row3 - offset);
            cp5_networking.get(Textfield.class, "LSL_numchan3").setPosition(column3,row4 - offset);
            cp5_networking.get(RadioButton.class, "filter1").setPosition(column1, row5 - 10);
            cp5_networking.get(RadioButton.class, "filter2").setPosition(column2, row5 - 10);
            cp5_networking.get(RadioButton.class, "filter3").setPosition(column3, row5 - 10);
        } else if (protocolMode.equals("Serial")) {
            //Serial Specific
            cp5_networking_baudRate.get(ScrollableList.class, "baud_rate").setPosition(column1, row2-offset);
            // cp5_networking_portName.get(ScrollableList.class, "port_name").setPosition(column1, row3-offset);
            cp5_networking_portName.get(ScrollableList.class, "port_name").setPosition(column2, row2-offset);
            cp5_networking_baudRate.get(ScrollableList.class, "baud_rate").setSize(itemWidth, (baudRates.size()+1)*(navH-4));
            // cp5_networking_portName.get(ScrollableList.class, "port_name").setSize(fullColumnWidth, (comPorts.size()+1)*(navH-4));
            // cp5_networking_portName.get(ScrollableList.class, "port_name").setSize(fullColumnWidth, (4)*(navH-4)); //
            cp5_networking_portName.get(ScrollableList.class, "port_name").setSize(halfWidth, (5)*(navH-4)); //halfWidth
            cp5_networking.get(RadioButton.class, "filter1").setPosition(column1, row3 - 10);
        }

        cp5_networking_dropdowns.get(ScrollableList.class, "dataType1").setPosition(column1, row1-offset);
        cp5_networking_dropdowns.get(ScrollableList.class, "dataType2").setPosition(column2, row1-offset);
        cp5_networking_dropdowns.get(ScrollableList.class, "dataType3").setPosition(column3, row1-offset);
        cp5_networking_dropdowns.get(ScrollableList.class, "dataType4").setPosition(column4, row1-offset);
    }

    public void mousePressed() {
        super.mousePressed(); //calls the parent mousePressed() method of Widget (DON'T REMOVE)
        if (startButton.isMouseHere()) {
            startButton.setIsActive(true);
        } else if (guideButton.isMouseHere()) {
            guideButton.setIsActive(true);
        } else if (dataOutputsButton.isMouseHere()) {
            dataOutputsButton.setIsActive(true);
        }
    }

    public void mouseReleased() {
        super.mouseReleased(); //calls the parent mouseReleased() method of Widget (DON'T REMOVE)

        // If start button was pressed...
        if (startButton.isActive && startButton.isMouseHere()) {
            if (!networkActive) {
                try {
                    turnOnButton();         // Change appearance of button
                    initializeStreams();    // Establish stream
                    startNetwork();         // Begin streaming
                    output("Network Stream Started");
                } catch (Exception e) {
                    //e.printStackTrace();
                    String exception = e.toString();
                    String [] nwError = split(exception, ':');
                    outputError("Networking Error - Port: " + nwError[2]);
                    shutDown();
                    networkActive = false;
                    return;
                }
            } else {
	                turnOffButton();        // Change apppearance of button
	                stopNetwork();          // Stop streams
	                output("Network Stream Stopped");
            }
        // or if the networking guide button was pressed...
        } else if (guideButton.isActive && guideButton.isMouseHere()) {
            guideButton.goToURL();
            output("Opening Networking Widget Guide using default browser.");
        } else if (dataOutputsButton.isActive && dataOutputsButton.isMouseHere()) {
            dataOutputsButton.goToURL();
            output("Opening Networking Data Outputs Guide using default browser.");
        }
        startButton.setIsActive(false);
        guideButton.setIsActive(false);
        dataOutputsButton.setIsActive(false);
    }

    public void hideAllTextFields(String[] textFieldNames) {
        for (int i = 0; i < textFieldNames.length; i++) {
            cp5_networking.get(Textfield.class, textFieldNames[i]).setVisible(false);
        }
    }

    /* Function call to hide all widget CP5 elements */
    public void hideElements() {
        String[] allTextFields = concat(oscTextFieldNames, udpTextFieldNames);
        allTextFields = concat(allTextFields, lslTextFieldNames);
        hideAllTextFields(allTextFields);

        cp5_networking_dropdowns.get(ScrollableList.class, "dataType1").setVisible(false);
        cp5_networking_dropdowns.get(ScrollableList.class, "dataType2").setVisible(false);
        cp5_networking_dropdowns.get(ScrollableList.class, "dataType3").setVisible(false);
        cp5_networking_dropdowns.get(ScrollableList.class, "dataType4").setVisible(false);
        cp5_networking_portName.get(ScrollableList.class, "port_name").setVisible(false);
        cp5_networking_baudRate.get(ScrollableList.class, "baud_rate").setVisible(false);

        cp5_networking.get(RadioButton.class, "filter1").setVisible(false);
        cp5_networking.get(RadioButton.class, "filter2").setVisible(false);
        cp5_networking.get(RadioButton.class, "filter3").setVisible(false);
        cp5_networking.get(RadioButton.class, "filter4").setVisible(false);

    }

    /* Change appearance of Button to off */
    public void turnOffButton() {
        startButton.setColorNotPressed(color(184,220,105));
        startButton.setString("Start");
    }

    public void turnOnButton() {
        startButton.setColorNotPressed(color(224, 56, 45));
        startButton.setString("Stop");
    }

    public boolean getNetworkActive() {
        return networkActive;
    }

    /* Call to shutdown some UI stuff. Called from W_manager, maybe do this differently.. */
    public void shutDown() {
        hideElements();
        turnOffButton();
    }

    public void initializeStreams() {
        String ip;
        int port;
        String address;
        int filt_pos;
        String name;
        int nChanLSL;
        int baudRate;
        String type;

        String dt1 = settings.nwDataTypesArray[(int)cp5_networking_dropdowns.get(ScrollableList.class, "dataType1").getValue()];
        String dt2 = settings.nwDataTypesArray[(int)cp5_networking_dropdowns.get(ScrollableList.class, "dataType2").getValue()];
        String dt3 = settings.nwDataTypesArray[(int)cp5_networking_dropdowns.get(ScrollableList.class, "dataType3").getValue()];
        String dt4 = settings.nwDataTypesArray[(int)cp5_networking_dropdowns.get(ScrollableList.class, "dataType4").getValue()];
        networkActive = true;

        // Establish OSC Streams
        if (protocolMode.equals("OSC")) {
            if (!dt1.equals("None")) {
                ip = cp5_networking.get(Textfield.class, "OSC_ip1").getText();
                port = Integer.parseInt(cp5_networking.get(Textfield.class, "OSC_port1").getText());
                address = cp5_networking.get(Textfield.class, "OSC_address1").getText();
                filt_pos = (int)cp5_networking.get(RadioButton.class, "filter1").getValue();
                stream1 = new Stream(dt1, ip, port, address, filt_pos, nchan);
            } else {
                stream1 = null;
            }
            if (!dt2.equals("None")) {
                ip = cp5_networking.get(Textfield.class, "OSC_ip2").getText();
                port = Integer.parseInt(cp5_networking.get(Textfield.class, "OSC_port2").getText());
                address = cp5_networking.get(Textfield.class, "OSC_address2").getText();
                filt_pos = (int)cp5_networking.get(RadioButton.class, "filter2").getValue();
                stream2 = new Stream(dt2, ip, port, address, filt_pos, nchan);
            } else {
                stream2 = null;
            }
            if (!dt3.equals("None")) {
                ip = cp5_networking.get(Textfield.class, "OSC_ip3").getText();
                port = Integer.parseInt(cp5_networking.get(Textfield.class, "OSC_port3").getText());
                address = cp5_networking.get(Textfield.class, "OSC_address3").getText();
                filt_pos = (int)cp5_networking.get(RadioButton.class, "filter3").getValue();
                stream3 = new Stream(dt3, ip, port, address, filt_pos, nchan);
            } else {
                stream3 = null;
            }
            if (!dt4.equals("None")) {
                ip = cp5_networking.get(Textfield.class, "OSC_ip4").getText();
                port = Integer.parseInt(cp5_networking.get(Textfield.class, "OSC_port4").getText());
                address = cp5_networking.get(Textfield.class, "OSC_address4").getText();
                filt_pos = (int)cp5_networking.get(RadioButton.class, "filter4").getValue();
                stream4 = new Stream(dt4, ip, port, address, filt_pos, nchan);
            } else {
                stream4 = null;
            }

            // Establish UDP Streams
        } else if (protocolMode.equals("UDP")) {
            if (!dt1.equals("None")) {
                ip = cp5_networking.get(Textfield.class, "UDP_ip1").getText();
                port = Integer.parseInt(cp5_networking.get(Textfield.class, "UDP_port1").getText());
                filt_pos = (int)cp5_networking.get(RadioButton.class, "filter1").getValue();
                stream1 = new Stream(dt1, ip, port, filt_pos, nchan);
            } else {
                stream1 = null;
            }
            if (!dt2.equals("None")) {
                ip = cp5_networking.get(Textfield.class, "UDP_ip2").getText();
                port = Integer.parseInt(cp5_networking.get(Textfield.class, "UDP_port2").getText());
                filt_pos = (int)cp5_networking.get(RadioButton.class, "filter2").getValue();
                stream2 = new Stream(dt2, ip, port, filt_pos, nchan);
            } else {
                stream2 = null;
            }
            if (!dt3.equals("None")) {
                ip = cp5_networking.get(Textfield.class, "UDP_ip3").getText();
                port = Integer.parseInt(cp5_networking.get(Textfield.class, "UDP_port3").getText());
                filt_pos = (int)cp5_networking.get(RadioButton.class, "filter3").getValue();
                stream3 = new Stream(dt3, ip, port, filt_pos, nchan);
            } else {
                stream3 = null;
            }

            // Establish LSL Streams
        } else if (protocolMode.equals("LSL")) {
            if (!dt1.equals("None")) {
                name = cp5_networking.get(Textfield.class, "LSL_name1").getText();
                type = cp5_networking.get(Textfield.class, "LSL_type1").getText();
                nChanLSL = Integer.parseInt(cp5_networking.get(Textfield.class, "LSL_numchan1").getText());
                filt_pos = (int)cp5_networking.get(RadioButton.class, "filter1").getValue();
                stream1 = new Stream(dt1, name, type, nChanLSL, filt_pos, nchan);
            } else {
                stream1 = null;
            }
            if (!dt2.equals("None")) {
                name = cp5_networking.get(Textfield.class, "LSL_name2").getText();
                type = cp5_networking.get(Textfield.class, "LSL_type2").getText();
                nChanLSL = Integer.parseInt(cp5_networking.get(Textfield.class, "LSL_numchan2").getText());
                filt_pos = (int)cp5_networking.get(RadioButton.class, "filter2").getValue();
                stream2 = new Stream(dt2, name, type, nChanLSL, filt_pos, nchan);
            } else {
                stream2 = null;
            }
            if (!dt3.equals("None")) {
                name = cp5_networking.get(Textfield.class, "LSL_name3").getText();
                type = cp5_networking.get(Textfield.class, "LSL_type3").getText();
                nChanLSL = Integer.parseInt(cp5_networking.get(Textfield.class, "LSL_numchan3").getText());
                filt_pos = (int)cp5_networking.get(RadioButton.class, "filter3").getValue();
                stream3 = new Stream(dt3, name, type, nChanLSL, filt_pos, nchan);
            } else {
                stream3 = null;
            }
        } else if (protocolMode.equals("Serial")) {
            // %%%%%
            if (!dt1.equals("None")) {
                name = comPorts.get((int)(cp5_networking_portName.get(ScrollableList.class, "port_name").getValue()));
                println("ComPort: " + name);
                // name = cp5_networking_portName.get(ScrollableList.class, "port_name").getItem((int)cp5_networking_portName.get(ScrollableList.class, "port_name").getValue());
                println("Baudrate: " + Integer.parseInt(baudRates.get((int)(cp5_networking_baudRate.get(ScrollableList.class, "baud_rate").getValue()))));
                baudRate = Integer.parseInt(baudRates.get((int)(cp5_networking_baudRate.get(ScrollableList.class, "baud_rate").getValue())));

                filt_pos = (int)cp5_networking.get(RadioButton.class, "filter1").getValue();
                stream1 = new Stream(dt1, name, baudRate, filt_pos, pApplet, nchan);  //String dataType, String portName, int baudRate, int filter, PApplet _this
            } else {
                stream1 = null;
            }
        }
    }

    /* Start networking */
    public void startNetwork() {
        if (stream1!=null) {
            stream1.start();
        }
        if (stream2!=null) {
            stream2.start();
        }
        if (stream3!=null) {
            stream3.start();
        }
        if (stream4!=null) {
            stream4.start();
        }
    }

    /* Stop networking */
    public void stopNetwork() {
        networkActive = false;

        if (stream1!=null) {
            stream1.quit();
            stream1=null;
        }
        if (stream2!=null) {
            stream2.quit();
            stream2=null;
        }
        if (stream3!=null) {
            stream3.quit();
            stream3=null;
        }
        if (stream4!=null) {
            stream4.quit();
            stream4=null;
        }
    }

    public void clearCP5() {
        //clears all controllers from ControlP5 instance...
        w_networking.cp5_networking.dispose();
        w_networking.cp5_networking_dropdowns.dispose();
        println("clearing cp5_networking...");
    }

    public void closeAllDropdowns() {
        dataDropdownsShouldBeClosed = true;
        w_networking.cp5_networking_dropdowns.get(ScrollableList.class, "dataType1").close();
        w_networking.cp5_networking_dropdowns.get(ScrollableList.class, "dataType2").close();
        w_networking.cp5_networking_dropdowns.get(ScrollableList.class, "dataType3").close();
        w_networking.cp5_networking_dropdowns.get(ScrollableList.class, "dataType4").close();
        w_networking.cp5_networking_baudRate.get(ScrollableList.class, "baud_rate").close();
        w_networking.cp5_networking_portName.get(ScrollableList.class, "port_name").close();
        //since this method is called when items are selected, go ahead and save settings to HashMap via fetchCP5Data
        fetchCP5Data();
    }

    public void openCloseDropdowns() {
        //datatype dropdowns
        for (int i = 0; i < datatypeNames.length; i++) {
            if (cp5_networking_dropdowns.get(ScrollableList.class, datatypeNames[i]).isOpen()) {
                if (!cp5_networking_dropdowns.getController(datatypeNames[i]).isMouseOver()) {
                    cp5_networking_dropdowns.get(ScrollableList.class, datatypeNames[i]).close();
                }
            }
            //If using a TopNav object, objects become locked and won't open
            if (!cp5_networking_dropdowns.get(ScrollableList.class, datatypeNames[i]).isOpen()) {
                if (cp5_networking_dropdowns.getController(datatypeNames[i]).isMouseOver()) {
                    cp5_networking_dropdowns.get(ScrollableList.class, datatypeNames[i]).open();
                }
            }
        }
        if (protocolMode.equals("Serial")) {
            //When using serial mode, lock baud rate dropdown when datatype dropdown is in use
            if (cp5_networking_dropdowns.get(ScrollableList.class, datatypeNames[0]).isOpen()) {
                cp5_networking_baudRate.get(ScrollableList.class, "baud_rate").lock();
            } else {
                if (cp5_networking_baudRate.get(ScrollableList.class, "baud_rate").isLock()) {
                    cp5_networking_baudRate.get(ScrollableList.class, "baud_rate").unlock();
                }
            }
            //baud rate
            if (cp5_networking_baudRate.get(ScrollableList.class, "baud_rate").isOpen()) {
                if (!cp5_networking_baudRate.getController("baud_rate").isMouseOver()) {
                    // println("2");
                    cp5_networking_baudRate.get(ScrollableList.class, "baud_rate").close();
                }
            }
            if (!cp5_networking_baudRate.get(ScrollableList.class, "baud_rate").isOpen()) {
                if (cp5_networking_baudRate.getController("baud_rate").isMouseOver()) {
                    // println("2");
                    cp5_networking_baudRate.get(ScrollableList.class, "baud_rate").open();
                }
            }
            //port name
            if (cp5_networking_portName.get(ScrollableList.class, "port_name").isOpen()) {
                if (!cp5_networking_portName.getController("port_name").isMouseOver()) {
                    // println("2");
                    cp5_networking_portName.get(ScrollableList.class, "port_name").close();
                }
            }
            if (!cp5_networking_portName.get(ScrollableList.class, "port_name").isOpen()) {
                if (cp5_networking_portName.getController("port_name").isMouseOver()) {
                    // println("2");
                    cp5_networking_portName.get(ScrollableList.class, "port_name").open();
                }
            }
        }
    }

    public void checkTopNovEvents() {
        //Check if a change has occured in TopNav
        if ((topNav.configSelector.isVisible != configIsVisible) || (topNav.layoutSelector.isVisible != layoutIsVisible)) {
            //lock/unlock the controllers within networking widget when using TopNav Objects
            if (topNav.configSelector.isVisible || topNav.layoutSelector.isVisible) {
                cp5_networking_dropdowns.get(ScrollableList.class, "dataType1").lock();
                cp5_networking_dropdowns.get(ScrollableList.class, "dataType2").lock();
                cp5_networking_dropdowns.get(ScrollableList.class, "dataType3").lock();
                cp5_networking_dropdowns.get(ScrollableList.class, "dataType4").lock();
                cp5_networking_portName.getController("port_name").lock();
                lockTextFields(oscTextFieldNames, true);
                lockTextFields(udpTextFieldNames, true);
                lockTextFields(lslTextFieldNames, true);
                //println("##LOCKED NETWORKING CP5 CONTROLLERS##");
            } else {
                cp5_networking_dropdowns.get(ScrollableList.class, "dataType1").unlock();
                cp5_networking_dropdowns.get(ScrollableList.class, "dataType2").unlock();
                cp5_networking_dropdowns.get(ScrollableList.class, "dataType3").unlock();
                cp5_networking_dropdowns.get(ScrollableList.class, "dataType4").unlock();
                cp5_networking_portName.getController("port_name").unlock();
                lockTextFields(oscTextFieldNames, false);
                lockTextFields(udpTextFieldNames, false);
                lockTextFields(lslTextFieldNames, false);
            }
            configIsVisible = topNav.configSelector.isVisible;
            layoutIsVisible = topNav.layoutSelector.isVisible;
        }
    }

    public void setComPortToSave(int n) {
        comPortToSave = n;
    }

    public void disableCertainOutputs(int n) {
        //Disable serial fft ouput and display message, it's too much data for serial coms
        if (w_networking.protocolMode.equals("Serial")) {
            if (n == Arrays.asList(settings.nwDataTypesArray).indexOf("FFT")) {
                output("Please use Band Power instead of FFT for Serial Output. Changing data type...");
                println("Networking: Changing data type from FFT to BandPower. FFT data is too large to send over Serial coms.");
                cp5_networking_dropdowns.getController("dataType1").getCaptionLabel().setText("BandPower");
                cp5_networking_dropdowns.get(ScrollableList.class, "dataType1")
                            .setValue(Arrays.asList(settings.nwDataTypesArray).indexOf("BandPower"));
            };
        }
    }
}; //End of w_networking class

////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////

class Stream extends Thread {
    String protocol;
    String dataType;
    String ip;
    int port;
    String address;
    int filter;
    String streamType;
    String streamName;
    int nChanLSL;
    int numChan = 0;

    Boolean isStreaming;
    Boolean newData = false;
    // Data buffers set dynamically in updateNumChan()
    int start;
    float[] dataToSend;

    //OSC Objects
    OscP5 osc;
    NetAddress netaddress;
    OscMessage msg;
    //UDP Objects
    UDP udp;
    ByteBuffer buffer;
    // LSL objects
    LSL.StreamInfo info_data;
    LSL.StreamOutlet outlet_data;
    LSL.StreamInfo info_aux;
    LSL.StreamOutlet outlet_aux;

    // Serial objects %%%%%
    Serial serial_networking;
    String portName;
    int baudRate;
    String serialMessage = "";

    PApplet pApplet;

    private void updateNumChan(int _numChan) {
        numChan = _numChan;
        println("Stream update numChan to " + numChan);
        dataToSend = new float[numChan * nPointsPerUpdate];
        println("nPointsPerUpdate " + nPointsPerUpdate);
        println("dataToSend len: " + numChan * nPointsPerUpdate);
	
	  // Bug #638: ArrayOutOfBoundsException was thrown if 
	  // nPointsPerUpdate was larger than 10, as start was
	  // set to dataBuffY_filtY_uV[0].length - 10.
        start = dataBuffY_filtY_uV[0].length - nPointsPerUpdate;
    }

    /* OSC Stream */
    Stream(String dataType, String ip, int port, String address, int filter, int _nchan) {
        this.protocol = "OSC";
        this.dataType = dataType;
        this.ip = ip;
        this.port = port;
        this.address = address;
        this.filter = filter;
        this.isStreaming = false;
        updateNumChan(_nchan);
        try {
            closeNetwork(); //make sure everything is closed!
        } catch (Exception e) {
        }
    }
    /*UDP Stream */
    Stream(String dataType, String ip, int port, int filter, int _nchan) {
        this.protocol = "UDP";
        this.dataType = dataType;
        this.ip = ip;
        this.port = port;
        this.filter = filter;
        this.isStreaming = false;
        updateNumChan(_nchan);
        if (this.dataType.equals("TimeSeries")) {
            buffer = ByteBuffer.allocate(4*numChan);
        } else {
            buffer = ByteBuffer.allocate(4*126);
        }
        try {
            closeNetwork(); //make sure everything is closed!
        } catch (Exception e) {
        }
    }
    /* LSL Stream */
    Stream(String dataType, String streamName, String streamType, int nChanLSL, int filter, int _nchan) {
        this.protocol = "LSL";
        this.dataType = dataType;
        this.streamName = streamName;
        this.streamType = streamType;
        this.nChanLSL = nChanLSL;
        this.filter = filter;
        this.isStreaming = false;
        updateNumChan(_nchan);
        try {
            closeNetwork(); //make sure everything is closed!
        } catch (Exception e) {
        }
    }

    // Serial Stream %%%%%
    Stream(String dataType, String portName, int baudRate, int filter, PApplet _this, int _nchan) {
        // %%%%%
        this.protocol = "Serial";
        this.dataType = dataType;
        this.portName = portName;
        this.baudRate = baudRate;
        this.filter = filter;
        this.isStreaming = false;
        this.pApplet = _this;
        updateNumChan(_nchan);
        if (this.dataType.equals("TimeSeries")) {
            buffer = ByteBuffer.allocate(4*numChan);
        } else {
            buffer = ByteBuffer.allocate(4*126);
        }

        try {
            closeNetwork();
        } catch (Exception e) {
            //nothing
        }
    }

    public void start() {
        this.isStreaming = true;
        if (!this.protocol.equals("LSL")) {
            super.start();
        } else {
            openNetwork();
        }
    }

    public void run() {
        if (!this.protocol.equals("LSL")) {
            openNetwork();
            while(this.isStreaming) {
                if (!isRunning) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException e) {
                        println(e.getMessage());
                    }
                } else {
                        if (checkForData()) {
                            if (this.dataType.equals("TimeSeries")) {
                                sendTimeSeriesData();
                            } else if (this.dataType.equals("FFT")) {
                                sendFFTData();
                            } else if (this.dataType.equals("EMG")) {
                                sendEMGData();
                            } else if (this.dataType.equals("BandPower")) {
                                sendPowerBandData();
                            } else if (this.dataType.equals("Accel/Aux")) {
                                if (eegDataSource == DATASOURCE_CYTON) {
                                    if (cyton.getBoardMode() == BoardMode.ANALOG) {
                                        sendAnalogReadData();
                                    } else if (cyton.getBoardMode() == BoardMode.DIGITAL) {
                                        sendDigitalReadData();
                                    } else {
                                        sendAccelerometerData();
                                    }
                                } else {
                                    sendAccelerometerData();
                                }
                            } else if (this.dataType.equals("Focus")) {
                                sendFocusData();
                            } else if (this.dataType.equals("Pulse")) {
                                sendPulseData();
                            } else if (this.dataType.equals("SSVEP")) {
                                sendSSVEPData();
                            }
                            setDataFalse();
                        } else {
                            try {
                                Thread.sleep(1);
                            } catch (InterruptedException e) {
                                println(e.getMessage());
                            }
                        }
                    }
                }
        } else if (this.protocol.equals("LSL")) {
            if (!isRunning) {
                try {
                    Thread.sleep(1);
                } catch (InterruptedException e) {
                    println(e.getMessage());
                }
            } else {
                if (checkForData()) {
                    if (this.dataType.equals("TimeSeries")) {
                        sendTimeSeriesData();
                    } else if (this.dataType.equals("FFT")) {
                        sendFFTData();
                    } else if (this.dataType.equals("EMG")) {
                        sendEMGData();
                    } else if (this.dataType.equals("BandPower")) {
                        sendPowerBandData();
                    } else if (this.dataType.equals("Accel/Aux")) {
                        if (eegDataSource == DATASOURCE_CYTON) {
                            if (cyton.getBoardMode() == BoardMode.ANALOG) {
                                sendAnalogReadData();
                            } else if (cyton.getBoardMode() == BoardMode.DIGITAL) {
                                sendDigitalReadData();
                            } else {
                                sendAccelerometerData();
                            }
                        } else {
                            sendAccelerometerData();
                        }
                    } else if (this.dataType.equals("Focus")) {
                        sendFocusData();
                    } else if (this.dataType.equals("Pulse")) {
                        sendPulseData();
                    } else if (this.dataType.equals("SSVEP")) {
                        sendSSVEPData();
                    }
                    //setDataFalse(); //Wait until all streams are done, Fixes 592
                }
            }
        }
    }

    public Boolean checkForData() {
        if (this.dataType.equals("TimeSeries")) {
            return dataProcessing.newDataToSend;
        } else if (this.dataType.equals("FFT")) {
            return dataProcessing.newDataToSend;
        } else if (this.dataType.equals("EMG")) {
            return dataProcessing.newDataToSend;
        } else if (this.dataType.equals("BandPower")) {
            return dataProcessing.newDataToSend;
        } else if (this.dataType.equals("Accel/Aux")) {
            return dataProcessing.newDataToSend;
        } else if (this.dataType.equals("Focus")) {
            return dataProcessing.newDataToSend;
        } else if (this.dataType.equals("Pulse")) {
            return dataProcessing.newDataToSend;
        } else if (this.dataType.equals("SSVEP")) {
            return dataProcessing.newDataToSend;
        }
        return false;
    }

    public void setDataFalse() {
        if (this.dataType.equals("TimeSeries")) {
            dataProcessing.newDataToSend = false;
        } else if (this.dataType.equals("FFT")) {
            dataProcessing.newDataToSend = false;
        } else if (this.dataType.equals("EMG")) {
            dataProcessing.newDataToSend = false;
        } else if (this.dataType.equals("BandPower")) {
            dataProcessing.newDataToSend = false;
        } else if (this.dataType.equals("Accel/Aux")) {
            dataProcessing.newDataToSend = false;
        } else if (this.dataType.equals("Focus")) {
            dataProcessing.newDataToSend = false;
        } else if (this.dataType.equals("Pulse")) {
            dataProcessing.newDataToSend = false;
        } else if (this.dataType.equals("SSVEP")) {
            dataProcessing.newDataToSend = false;
        }
    }

    /* This method contains all of the policies for sending data types */
    public void sendTimeSeriesData() {

        // TIME SERIES UNFILTERED
        if (filter==0) {
            // OSC
            if (this.protocol.equals("OSC")) {
                for (int i=0;i<nPointsPerUpdate;i++) {
                    msg.clearArguments();
                    for (int j=0;j<numChan;j++) {
                        msg.add(yLittleBuff_uV[j][i]);
                    }
                    try {
                        this.osc.send(msg,this.netaddress);
                    } catch (Exception e) {
                        println(e.getMessage());
                    }
                }
                // UDP
            } else if (this.protocol.equals("UDP")) {
                for (int i=0;i<nPointsPerUpdate;i++) {
                    String outputter = "{\"type\":\"eeg\",\"data\":[";
                    for (int j = 0; j < numChan; j++) {
                        outputter += str(yLittleBuff_uV[j][i]);
                        if (j != numChan - 1) {
                            outputter += ",";
                        } else {
                            outputter += "]}\r\n";
                        }
                    }
                    try {
                        this.udp.send(outputter, this.ip, this.port);
                    } catch (Exception e) {
                        println(e.getMessage());
                    }
                }
                // LSL
            } else if (this.protocol.equals("LSL")) {
                for (int i=0; i<nPointsPerUpdate;i++) {
                    for (int j=0;j<numChan;j++) {
                        dataToSend[j+numChan*i] = yLittleBuff_uV[j][i];
                    }
                }
                // Add timestamp to LSL Stream
                // From LSLLink Library: The time stamps of other samples are automatically derived based on the sampling rate of the stream.
                outlet_data.push_chunk(dataToSend, System.currentTimeMillis());
                // SERIAL
            } else if (this.protocol.equals("Serial")) {         // Serial Output unfiltered
                for (int i=0;i<nPointsPerUpdate;i++) {
                    serialMessage = "["; //clear message
                    for (int j=0;j<numChan;j++) {
                        float chan_uV = yLittleBuff_uV[j][i];//get chan uV float value and truncate to 3 decimal places
                        String chan_uV_3dec = String.format("%.3f", chan_uV);
                        serialMessage += chan_uV_3dec;//  serialMesage += //add 3 decimal float chan uV value as string to serialMessage
                        if (j < numChan-1) {
                            serialMessage += ",";  //add a comma to serialMessage to separate chan values, as long as it isn't last value...
                        }
                    }
                    serialMessage += "]";  //close the message w/ "]"
                    try {
                        //  println(serialMessage);
                        this.serial_networking.write(serialMessage);          //write message to serial
                    } catch (Exception e) {
                        println(e.getMessage());
                    }
                }
            }


        // TIME SERIES FILTERED
        } else if (filter==1) {
            if (this.protocol.equals("OSC")) {
                for (int i=0;i<nPointsPerUpdate;i++) {
                    msg.clearArguments();
                    for (int j=0;j<numChan;j++) {
                        msg.add(dataBuffY_filtY_uV[j][start+i]);
                    }
                    try {
                        this.osc.send(msg,this.netaddress);
                    } catch (Exception e) {
                        println(e.getMessage());
                    }
                }
            } else if (this.protocol.equals("UDP")) {
                for (int i=0;i<nPointsPerUpdate;i++) {
                    String outputter = "{\"type\":\"eeg\",\"data\":[";
                    for (int j = 0; j < numChan; j++) {
                        outputter += str(dataBuffY_filtY_uV[j][start+i]);
                        if (j != numChan - 1) {
                            outputter += ",";
                        } else {
                            outputter += "]}\r\n";
                        }
                    }
                    try {
                        this.udp.send(outputter, this.ip, this.port);
                    } catch (Exception e) {
                        println(e.getMessage());
                    }
                }
            } else if (this.protocol.equals("LSL")) {
                for (int i=0; i<nPointsPerUpdate;i++) {
                    for (int j=0;j<numChan;j++) {
                        dataToSend[j+numChan*i] = dataBuffY_filtY_uV[j][i];
                    }
                }
                // Add timestamp to LSL Stream
                outlet_data.push_chunk(dataToSend, System.currentTimeMillis());
            } else if (this.protocol.equals("Serial")) {
                for (int i=0;i<nPointsPerUpdate;i++) {
                    serialMessage = "["; //clear message
                    for (int j=0;j<numChan;j++) {
                        float chan_uV_filt = dataBuffY_filtY_uV[j][start+i];//get chan uV float value and truncate to 3 decimal places
                        String chan_uV_filt_3dec = String.format("%.3f", chan_uV_filt);
                        serialMessage += chan_uV_filt_3dec;//  serialMesage += //add 3 decimal float chan uV value as string to serialMessage
                        if (j < numChan-1) {
                            serialMessage += ",";  //add a comma to serialMessage to separate chan values, as long as it isn't last value...
                        }
                    }
                    serialMessage += "]";  //close the message w/ "]"
                    try {
                        //  println(serialMessage);
                        this.serial_networking.write(serialMessage);          //write message to serial
                    } catch (Exception e) {
                        println(e.getMessage());
                    }
                }
            }
        }
    }

    public void sendFFTData() {
        // UNFILTERED, for now, maybe this should be changed -RW
        //EEG/FFT readings above 125Hz don't typically travel through the skull
        //So for now, only send out 0-125Hz with 1 bin per Hz
        //Bin 10 == 10Hz frequency range
        if (this.filter==0 || this.filter==1) {
            // OSC
            if (this.protocol.equals("OSC")) {
                for (int i=0;i<numChan;i++) {
                    msg.clearArguments();
                    msg.add(i+1);
                    for (int j=0;j<125;j++) {
                        msg.add(fftBuff[i].getBand(j));
                    }
                    try {
                        this.osc.send(msg,this.netaddress);
                    } catch (Exception e) {
                        println(e.getMessage());
                    }
                }
                // UDP
            } else if (this.protocol.equals("UDP")) {
                String outputter = "{\"type\":\"fft\",\"data\":[[";
                for (int i = 0;i < numChan; i++) {
                    for (int j = 0; j < 125; j++) {
                        outputter += str(fftBuff[i].getBand(j));
                        if (j != 125 - 1) {
                            outputter += ",";
                        }
                    }
                    if (i != numChan - 1) {
                        outputter += "],[";
                    } else {
                        outputter += "]]}\r\n";
                    }
                }
                try {
                    this.udp.send(outputter, this.ip, this.port);
                } catch (Exception e) {
                    println(e.getMessage());
                }
                // LSL
            } else if (this.protocol.equals("LSL")) {
                float[] _dataToSend = new float[numChan * 125];
                for (int i = 0; i < numChan; i++) {
                    for (int j = 0; j < 125; j++) {
                        _dataToSend[j+125*i] = fftBuff[i].getBand(j);
                    }
                }
                // Add timestamp to LSL Stream
                // From LSLLink Library: The time stamps of other samples are automatically derived based on the sampling rate of the stream.
                outlet_data.push_chunk(_dataToSend, System.currentTimeMillis());
            } else if (this.protocol.equals("Serial")) {
                /////////////////////////////////THIS OUTPUT IS DISABLED
                // Send FFT Data over Serial ... 
                /*
                for (int i=0;i<numChan;i++) {
                    serialMessage = "[" + (i+1) + ","; //clear message
                    for (int j=0;j<125;j++) {
                        float fft_band = fftBuff[i].getBand(j);
                        String fft_band_3dec = String.format("%.3f", fft_band);
                        serialMessage += fft_band_3dec;
                        if (j < 125-1) {
                            serialMessage += ",";  //add a comma to serialMessage to separate chan values, as long as it isn't last value...
                        }
                    }
                    serialMessage += "]";
                    try {
                        // println(serialMessage);
                        this.serial_networking.write(serialMessage);
                    } catch (Exception e) {
                        println(e.getMessage());
                    }
                }
                */
            }
        }
    }

    public void sendPowerBandData() {
        // UNFILTERED & FILTERED ... influenced globally by the FFT filters dropdown ... just like the FFT data
        int numBandPower = 5; //DELTA, THETA, ALPHA, BETA, GAMMA

        if (this.filter==0 || this.filter==1) {
            // OSC
            if (this.protocol.equals("OSC")) {
                for (int i=0;i<numChan;i++) {
                    msg.clearArguments();
                    msg.add(i+1);
                    for (int j=0;j<numBandPower;j++) {
                        msg.add(dataProcessing.avgPowerInBins[i][j]); // [CHAN][BAND]
                    }
                    try {
                        this.osc.send(msg,this.netaddress);
                    } catch (Exception e) {
                        println(e.getMessage());
                    }
                }
            // UDP
            } else if (this.protocol.equals("UDP")) {
                // DELTA, THETA, ALPHA, BETA, GAMMA
                String outputter = "{\"type\":\"bandPower\",\"data\":[[";
                for (int i = 0;i < numChan; i++) {
                    for (int j=0;j<numBandPower;j++) {
                        outputter += str(dataProcessing.avgPowerInBins[i][j]); //[CHAN][BAND]
                        if (j != numBandPower - 1) {
                            outputter += ",";
                        }
                    }
                    if (i != numChan - 1) {
                        outputter += "],[";
                    } else {
                        outputter += "]]}\r\n";
                    }
                }
                try {
                    this.udp.send(outputter, this.ip, this.port);
                } catch (Exception e) {
                    println(e.getMessage());
                }
                // LSL
            } else if (this.protocol.equals("LSL")) {

                float[] avgPowerLSL = new float[numChan*numBandPower];
                for (int i=0; i<numChan;i++) {
                    for (int j=0;j<numBandPower;j++) {
                        dataToSend[j+numBandPower*i] = dataProcessing.avgPowerInBins[i][j];
                    }
                }
                // Add timestamp to LSL Stream
                outlet_data.push_chunk(dataToSend, System.currentTimeMillis());
            } else if (this.protocol.equals("Serial")) {
                for (int i=0;i<numChan;i++) {
                    serialMessage = "[" + (i+1) + ","; //clear message
                    for (int j=0;j<numBandPower;j++) {
                        float power_band = dataProcessing.avgPowerInBins[i][j];
                        String power_band_3dec = String.format("%.3f", power_band);
                        serialMessage += power_band_3dec;
                        if (j < numBandPower-1) {
                            serialMessage += ",";  //add a comma to serialMessage to separate chan values, as long as it isn't last value...
                        }
                    }
                    serialMessage += "]";
                    try {
                        // println(serialMessage);
                        this.serial_networking.write(serialMessage);
                    } catch (Exception e) {
                        println(e.getMessage());
                    }
                }
            }
        }
    }

    public void sendEMGData() {
        // UNFILTERED & FILTERED ... influenced globally by the FFT filters dropdown ... just like the FFT data
        if (this.filter==0 || this.filter==1) {
            // OSC
            if (this.protocol.equals("OSC")) {
                for (int i=0;i<numChan;i++) {
                    msg.clearArguments();
                    msg.add(i+1);
                    //ADD NORMALIZED EMG CHANNEL DATA
                    msg.add(w_emg.motorWidgets[i].output_normalized);
                    // println(i + " | " + w_emg.motorWidgets[i].output_normalized);
                    try {
                        this.osc.send(msg,this.netaddress);
                    } catch (Exception e) {
                        println(e.getMessage());
                    }
                }
            // UDP
            } else if (this.protocol.equals("UDP")) {
                String outputter = "{\"type\":\"emg\",\"data\":[";
                for (int i = 0;i < numChan; i++) {
                    outputter += str(w_emg.motorWidgets[i].output_normalized);
                    if (i != numChan - 1) {
                        outputter += ",";
                    } else {
                        outputter += "]}\r\n";
                    }
                }
                try {
                    this.udp.send(outputter, this.ip, this.port);
                } catch (Exception e) {
                    println(e.getMessage());
                }
                // LSL
            } else if (this.protocol.equals("LSL")) {
                if (filter==0) {
                    for (int j=0;j<numChan;j++) {
                        dataToSend[j] = w_emg.motorWidgets[j].output_normalized;
                    }
                    // Add timestamp to LSL Stream
                    outlet_data.push_sample(dataToSend, System.currentTimeMillis());
                }
            } else if (this.protocol.equals("Serial")) {     // Send NORMALIZED EMG CHANNEL Data over Serial ... %%%%%
                serialMessage = "";
                for (int i=0;i<numChan;i++) {
                    float emg_normalized = w_emg.motorWidgets[i].output_normalized;
                    String emg_normalized_3dec = String.format("%.3f", emg_normalized);
                    serialMessage += emg_normalized_3dec;
                    if (i != numChan - 1) {
                        serialMessage += ",";
                    } else {
                        serialMessage += "\n";
                    }
                }
                try {
                    println(serialMessage);
                    this.serial_networking.write(serialMessage);
                } catch (Exception e) {
                    println(e.getMessage());
                }
            }
        }
    }


    public void sendAccelerometerData() {
        // UNFILTERED & FILTERED, Accel data is not affected by filters anyways
        if (this.filter==0 || this.filter==1) {
            // OSC
            if (this.protocol.equals("OSC")) {
                for (int i = 0; i < NUM_ACCEL_DIMS; i++) {
                    msg.clearArguments();
                    msg.add(i+1);
                    //ADD Accelerometer data
                    msg.add(w_accelerometer.getCurrentAccelVal(i));
                    // println(i + " | " + w_accelerometer.getCurrentAccelVal(i));
                    try {
                        this.osc.send(msg,this.netaddress);
                    } catch (Exception e) {
                        println(e.getMessage());
                    }
                }
            // UDP
            } else if (this.protocol.equals("UDP")) {
                String outputter = "{\"type\":\"accelerometer\",\"data\":[";
                for (int i = 0; i < NUM_ACCEL_DIMS; i++) {
                    float accelData = w_accelerometer.getCurrentAccelVal(i);
                    String accelData_3dec = String.format("%.3f", accelData);
                    outputter += accelData_3dec;
                    if (i != NUM_ACCEL_DIMS - 1) {
                        outputter += ",";
                    } else {
                        outputter += "]}\r\n";
                    }
                }
                try {
                    this.udp.send(outputter, this.ip, this.port);
                } catch (Exception e) {
                    println(e.getMessage());
                }
                // LSL
            } else if (this.protocol.equals("LSL")) {
                for (int i = 0; i < NUM_ACCEL_DIMS; i++) {
                    dataToSend[i] = w_accelerometer.getCurrentAccelVal(i);
                }
                // Add timestamp to LSL Stream
                outlet_data.push_sample(dataToSend, System.currentTimeMillis());
            } else if (this.protocol.equals("Serial")) {
                // Data Format: +0.900,-0.042,+0.254\n
                // 7 chars per axis, including \n char for Z
                serialMessage = "";
                for (int i = 0; i < NUM_ACCEL_DIMS; i++) {
                    float accelData = w_accelerometer.getCurrentAccelVal(i);
                    String accelData_3dec = String.format("%.3f", accelData);
                    if (accelData >= 0) serialMessage += "+";
                    serialMessage += accelData_3dec;
                    if (i != NUM_ACCEL_DIMS - 1) {
                        serialMessage += ",";
                    } else {
                        serialMessage += "\n";
                    }
                }
                try {
                    //println(serialMessage);
                    this.serial_networking.write(serialMessage);
                } catch (Exception e) {
                    println(e.getMessage());
                }
            }
        }
    }

    public void sendAnalogReadData() {
        final int NUM_ANALOG_READS = w_analogRead.getNumAnalogReads();
        // UNFILTERED & FILTERED, Aux data is not affected by filters anyways
        if (this.filter==0 || this.filter==1) {
            // OSC
            if (this.protocol.equals("OSC")) {
                for (int i = 0; i < NUM_ANALOG_READS; i++) {
                    msg.clearArguments();
                    msg.add(i+1);
                    //ADD Accelerometer data
                    msg.add(hub.validAccelValues[i]);
                    // println(i + " | " + hub.validAccelValues[i]);
                    try {
                        this.osc.send(msg,this.netaddress);
                    } catch (Exception e) {
                        println(e.getMessage());
                    }
                }
            // UDP
            } else if (this.protocol.equals("UDP")) {
                String outputter = "{\"type\":\"auxiliary\",\"data\":[";
                for (int i = 0; i < NUM_ANALOG_READS; i++) {
                    int auxData = hub.validAccelValues[i];
                    String auxData_formatted = String.format("%04d", auxData);
                    outputter += auxData_formatted;
                    if (i != NUM_ANALOG_READS - 1) {
                        outputter += ",";
                    } else {
                        outputter += "]}\r\n";
                    }
                }
                try {
                    this.udp.send(outputter, this.ip, this.port);
                } catch (Exception e) {
                    println(e.getMessage());
                }
                // LSL
            } else if (this.protocol.equals("LSL")) {
                for (int i = 0; i < NUM_ANALOG_READS; i++) {
                    dataToSend[i] = hub.validAccelValues[i];
                }
                // Add timestamp to LSL Stream
                outlet_data.push_sample(dataToSend, System.currentTimeMillis());
            } else if (this.protocol.equals("Serial")) {
                // Data Format: 0001,0002,0003\n or 0001,0002\n depending if Wifi Shield is used
                // 5 chars per pin, including \n char for Z
                serialMessage = "";
                for (int i = 0; i < NUM_ANALOG_READS; i++) {
                    int auxData = hub.validAccelValues[i];
                    String auxData_formatted = String.format("%04d", auxData);
                    serialMessage += auxData_formatted;
                    if (i != NUM_ANALOG_READS - 1) {
                        serialMessage += ",";
                    } else {
                        serialMessage += "\n";
                    }
                }
                try {
                    //println(serialMessage);
                    this.serial_networking.write(serialMessage);
                } catch (Exception e) {
                    println(e.getMessage());
                }
            }
        }
    }

    public void sendDigitalReadData() {
        final int NUM_DIGITAL_READS = w_digitalRead.getNumDigitalReads();
        // UNFILTERED & FILTERED, Aux data is not affected by filters anyways
        if (this.filter==0 || this.filter==1) {
            // OSC
            if (this.protocol.equals("OSC")) {
                for (int i = 0; i < NUM_DIGITAL_READS; i++) {
                    msg.clearArguments();
                    msg.add(i+1);
                    //ADD Accelerometer data
                    msg.add(w_digitalRead.digitalReadDots[i].getDigitalReadVal());
                    // println(i + " | " + hub.validAccelValues[i]);
                    try {
                        this.osc.send(msg,this.netaddress);
                    } catch (Exception e) {
                        println(e.getMessage());
                    }
                }
            // UDP
            } else if (this.protocol.equals("UDP")) {
                String outputter = "{\"type\":\"auxiliary\",\"data\":[";
                for (int i = 0; i < NUM_DIGITAL_READS; i++) {
                    int auxData = w_digitalRead.digitalReadDots[i].getDigitalReadVal();
                    String auxData_formatted = String.format("%d", auxData);
                    outputter += auxData_formatted;
                    if (i != NUM_DIGITAL_READS - 1) {
                        outputter += ",";
                    } else {
                        outputter += "]}\r\n";
                    }
                }
                try {
                    this.udp.send(outputter, this.ip, this.port);
                } catch (Exception e) {
                    println(e.getMessage());
                }
                // LSL
            } else if (this.protocol.equals("LSL")) {
                for (int i = 0; i < NUM_DIGITAL_READS; i++) {
                    dataToSend[i] = w_digitalRead.digitalReadDots[i].getDigitalReadVal();
                }
                // Add timestamp to LSL Stream
                outlet_data.push_sample(dataToSend, System.currentTimeMillis());
            } else if (this.protocol.equals("Serial")) {
                // Data Format: 0,1,0,1,0\n or 0,1,0\n depending if WiFi Shield is used
                // 2 chars per pin, including \n char last pin
                serialMessage = "";
                for (int i = 0; i < NUM_DIGITAL_READS; i++) {
                    int auxData = w_digitalRead.digitalReadDots[i].getDigitalReadVal();
                    String auxData_formatted = String.format("%d", auxData);
                    serialMessage += auxData_formatted;
                    if (i != NUM_DIGITAL_READS - 1) {
                        serialMessage += ",";
                    } else {
                        serialMessage += "\n";
                    }
                }
                try {
                    //println(serialMessage);
                    this.serial_networking.write(serialMessage);
                } catch (Exception e) {
                    println(e.getMessage());
                }
            }
        }
    }

    public void sendFocusData() {
        // UNFILTERED & FILTERED ... influenced globally by the FFT filters dropdown ... just like the FFT data
        if (this.filter==0 || this.filter==1) {
            // OSC
            if (this.protocol.equals("OSC")) {
                msg.clearArguments();
                //ADD Focus Data
                msg.add(w_focus.isFocused);
                try {
                    this.osc.send(msg,this.netaddress);
                } catch (Exception e) {
                    println(e.getMessage());
                }
            // UDP
            } else if (this.protocol.equals("UDP")) {
                String outputter = "{\"type\":\"focus\",\"data\":";
                outputter += str(w_focus.isFocused ? 1.0f : 0.0f);
                outputter += "]}\r\n";
                try {
                    this.udp.send(outputter, this.ip, this.port);
                } catch (Exception e) {
                    println(e.getMessage());
                }
            // LSL
            } else if (this.protocol.equals("LSL")) {
                // convert boolean to float and only sends the first data
                float temp = w_focus.isFocused ? 1.0f : 0.0f;
                dataToSend[0] = temp;
                // Add timestamp to LSL Stream
                outlet_data.push_sample(dataToSend, System.currentTimeMillis());
            // Serial
            } else if (this.protocol.equals("Serial")) {     // Send NORMALIZED EMG CHANNEL Data over Serial ... %%%%%
                serialMessage = ""; //clear message
                String isFocused = Boolean.toString(w_focus.isFocused);
                serialMessage += isFocused;
                serialMessage += "\n";
                try {
                    //println("SerialMessage: " + serialMessage);
                    this.serial_networking.write(serialMessage);
                } catch (Exception e) {
                    println("SerialMessage: Focus Error");
                    println(e.getMessage());
                }
            }
        }
    }
    //////////////////////////////////////Stream SSVEP data from W_SSVEP
    public void sendSSVEPData() {
        // UNFILTERED & FILTERED ... influenced globally by the FFT filters dropdown ... just like the FFT data
        if (this.filter==0 || this.filter==1){
            // OSC
            if (this.protocol.equals("OSC")){
                for (int i=0;i<w_ssvep.ssvepData.length;i++) {
                    msg.clearArguments();
                    msg.add(i+1);
                    //ADD NORMALIZED EMG CHANNEL DATA
                    msg.add(w_ssvep.ssvepData[i]);
                    // println(i + " | " + w_emg.motorWidgets[i].output_normalized);
                    try {
                        this.osc.send(msg,this.netaddress);
                    } catch (Exception e) {
                        println(e.getMessage());
                    }
                }
            // UDP
            } else if (this.protocol.equals("UDP")){
                String outputter = "{\"type\":\"SSVEP\",\"data\":";
                for (int i = 0; i < w_ssvep.ssvepData.length; i++) {
                    outputter += str(w_ssvep.ssvepData[i]);
                    outputter += ",";
                }
                outputter += "]}\r\n";
                try {
                    this.udp.send(outputter, this.ip, this.port);
                } catch (Exception e) {
                    println(e.getMessage());
                }
            // LSL
            } else if (this.protocol.equals("LSL")){
                for (int i = 0; i < w_ssvep.ssvepData.length; i++) {
                    dataToSend[i] = w_ssvep.ssvepData[i];
                }
                // Add timestamp to LSL Stream
                outlet_data.push_sample(dataToSend, System.currentTimeMillis());
            // Serial
            } else if (this.protocol.equals("Serial")){     // Send SSVEP Data over Serial ...
                serialMessage = ""; //clear message
                for (int i = 0; i < w_ssvep.ssvepData.length; i++) {
                    serialMessage += String.format("%.3f", w_ssvep.ssvepData[i]);
                    if (i != w_ssvep.ssvepData.length - 1) {
                        serialMessage += ",";
                    } else {
                        serialMessage += "\n";
                    }
                }
                try {
                    //println("SerialMessage: SSVEP = " + serialMessage);
                    this.serial_networking.write(serialMessage);
                } catch (Exception e){
                    println("SerialMessage: Focus Error");
                    println(e.getMessage());
                }
            }
        }
    }
    ////////////////////////////////////// Stream pulse data from W_PulseSensor
    public void sendPulseData() {
        if (this.filter==0 || this.filter==1) {
            // OSC
            if (this.protocol.equals("OSC")) {
                //ADD BPM Data (BPM, Signal, IBI)
                for (int i = 0; i < (w_pulsesensor.PulseWaveY.length); i++) {//This works
                    msg.clearArguments(); //This belongs here
                    msg.add(w_pulsesensor.BPM); //Add BPM first
                    msg.add(w_pulsesensor.PulseWaveY[i]); //Add Raw Signal second
                    msg.add(w_pulsesensor.IBI); //Add IBI third
                    //Message received in Max via OSC is a list of three integers without commas: 75 512 600 : BPM Signal IBI
                    //println(" " + this.port + " ~~~~ " + w_pulsesensor.BPM + "," +  w_pulsesensor.PulseWaveY[i] + "," + w_pulsesensor.IBI);
                    try {
                        this.osc.send(msg,this.netaddress);
                    } catch (Exception e) {
                        println(e.getMessage());
                    }
                }
            // UDP
            } else if (this.protocol.equals("UDP")) { //////////////////This needs to be checked
                String outputter = "{\"type\":\"pulse\",\"data\":";
                for (int i = 0; i < (w_pulsesensor.PulseWaveY.length); i++) {
                    outputter += str(w_pulsesensor.BPM) + ",";  //Comma separated string output (BPM,Raw Signal,IBI)
                    outputter += str(w_pulsesensor.PulseWaveY[i]) + ",";
                    outputter += str(w_pulsesensor.IBI);
                    outputter += "]}\r\n";
                    try {
                        this.udp.send(outputter, this.ip, this.port);
                    } catch (Exception e) {
                        println(e.getMessage());
                    }
                }
            // LSL
            } else if (this.protocol.equals("LSL")) { ///////////////////This needs to be checked
                for (int i = 0; i < (w_pulsesensor.PulseWaveY.length); i++) {
                    dataToSend[0] = w_pulsesensor.BPM;  //Array output
                    dataToSend[1] = w_pulsesensor.PulseWaveY[i];
                    dataToSend[2] = w_pulsesensor.IBI;
                }
                // Add timestamp to LSL Stream
                outlet_data.push_chunk(dataToSend, System.currentTimeMillis());
            // Serial
            } else if (this.protocol.equals("Serial")) {     // Send Pulse Data (BPM,Signal,IBI) over Serial
                for (int i = 0; i < (w_pulsesensor.PulseWaveY.length); i++) {
                    serialMessage = ""; //clear message
                    int BPM = (w_pulsesensor.BPM);
                    int Signal = (w_pulsesensor.PulseWaveY[i]);
                    int IBI = (w_pulsesensor.IBI);
                    serialMessage += BPM + ","; //Comma separated string output (BPM,Raw Signal,IBI)
                    serialMessage += Signal + ",";
                    serialMessage += IBI;
                    try {
                        println(serialMessage);
                        this.serial_networking.write(serialMessage);
                    } catch (Exception e) {
                        println(e.getMessage());
                    }
                }
            }
        }
    }//End sendPulseData

    //// Add new stream function here (ex. sendWidgetData) in the same format as above

    public void quit() {
        this.isStreaming=false;
        closeNetwork();
        interrupt();
    }

    public void closeNetwork() {
        if (this.protocol.equals("OSC")) {
            try {
                this.osc.stop();
            } catch (Exception e) {
                println(e.getMessage());
            }
        } else if (this.protocol.equals("UDP")) {
            this.udp.close();
        } else if (this.protocol.equals("LSL")) {
            outlet_data.close();
        } else if (this.protocol.equals("Serial")) {
            //Close Serial Port %%%%%
            try {
                serial_networking.clear();
                serial_networking.stop();
                println("Successfully closed SERIAL/COM port " + this.portName);
            } catch (Exception e) {
                println("Failed to close SERIAL/COM port " + this.portName);
            }
        }
    }

    public void openNetwork() {
        println("Networking: " + getAttributes());
        if (this.protocol.equals("OSC")) {
            //Possibly enter a nice custom exception here
            //try {
                this.osc = new OscP5(this,this.port + 1000);
                this.netaddress = new NetAddress(this.ip,this.port);
                this.msg = new OscMessage(this.address);
            //} catch (Exception e) {
            //}
        } else if (this.protocol.equals("UDP")) {
            this.udp = new UDP(this);
            this.udp.setBuffer(20000);
            this.udp.listen(false);
            this.udp.log(false);
            output("UDP successfully connected");
        } else if (this.protocol.equals("LSL")) {
            String stream_id = "openbcieeg12345";
            info_data = new LSL.StreamInfo(
                        this.streamName,
                        this.streamType,
                        this.nChanLSL,
                        getSampleRateSafe(),
                        LSL.ChannelFormat.float32,
                        stream_id
                    );
            outlet_data = new LSL.StreamOutlet(info_data);
        } else if (this.protocol.equals("Serial")) {
            //Open Serial Port! %%%%%
            try {
                serial_networking = new Serial(this.pApplet, this.portName, this.baudRate);
                serial_networking.clear();
                verbosePrint("Successfully opened SERIAL/COM: " + this.portName);
                output("Successfully opened SERIAL/COM (" + this.baudRate + "): " + this.portName );
            } catch (Exception e) {
                verbosePrint("W_Networking.pde: could not open SERIAL PORT: " + this.portName);
                println("Error: " + e);
            }
        }
    }

    //used only to print attributes to the screen
    public StringList getAttributes() {
        StringList attributes = new StringList();
        if (this.protocol.equals("OSC")) {
            attributes.append(this.dataType);
            attributes.append(this.ip);
            attributes.append(str(this.port));
            attributes.append(this.address);
            attributes.append(str(this.filter));
        } else if (this.protocol.equals("UDP")) {
            attributes.append(this.dataType);
            attributes.append(this.ip);
            attributes.append(str(this.port));
            attributes.append(str(this.filter));
        } else if (this.protocol.equals("LSL")) {
            attributes.append(this.dataType);
            attributes.append(this.streamName);
            attributes.append(this.streamType);
            attributes.append(str(this.nChanLSL));
            attributes.append(str(this.filter));
        } else if (this.protocol.equals("Serial")) {
            // Add Serial Port Attributes %%%%%
        }
        return attributes;
    }
}

/* Dropdown Menu Callback Functions */
/**
  * @description Sets the selected protocol mode from the widget's dropdown menu
  * @param `n` {int} - Index of protocol item selected in menu
  */
public void Protocol(int protocolIndex) {
    settings.nwProtocolSave = protocolIndex;
    if (protocolIndex==3) {
        w_networking.protocolMode = "OSC";
    } else if (protocolIndex==2) {
        w_networking.protocolMode = "UDP";
    } else if (protocolIndex==1) {
        w_networking.protocolMode = "LSL";
    } else if (protocolIndex==0) {
        w_networking.protocolMode = "Serial";
        w_networking.disableCertainOutputs((int)w_networking.cp5_networking_dropdowns.get(ScrollableList.class, "dataType1").getValue());
    }
    println("Networking: Protocol mode set to " + w_networking.protocolMode);
    w_networking.screenResized();
    w_networking.showCP5();
    closeAllDropdowns();
}

public void dataType1(int n) {
    w_networking.closeAllDropdowns();
}
public void dataType2(int n) {
    w_networking.closeAllDropdowns();
}
public void dataType3(int n) {
    w_networking.closeAllDropdowns();
}
public void dataType4(int n) {
    w_networking.closeAllDropdowns();
}
public void port_name(int n) {
    w_networking.setComPortToSave(n);
    w_networking.closeAllDropdowns();
}
public void baud_rate(int n) {
    w_networking.closeAllDropdowns();
}
public void filter1(int n) {
    w_networking.closeAllDropdowns();
}
public void filter2(int n) {
    w_networking.closeAllDropdowns();
}
public void filter3(int n) {
    w_networking.closeAllDropdowns();
}
public void filter4(int n) {
    w_networking.closeAllDropdowns();
}

////////////////////////////////////////////////////
//
//    W_template.pde (ie "Widget Template")
//
//    This is a Template Widget, intended to be used as a starting point for OpenBCI Community members that want to develop their own custom widgets!
//    Good luck! If you embark on this journey, please let us know. Your contributions are valuable to everyone!
//
//    Created by: Conor Russomanno, November 2016
//
///////////////////////////////////////////////////,

class W_openBionics extends Widget {

    //to see all core variables/methods of the Widget class, refer to Widget.pde
    //put your custom variables here...
    PApplet parent;

    Serial OpenBionicsHand;
    PFont f = createFont("Arial Bold", 24); //for "FFT Plot" Widget Title
    PFont f2 = createFont("Arial", 18); //for dropdown name titles (above dropdown widgets)

    int parentContainer = 9; //which container is it mapped to by default?
    boolean thumbPressed,indexPressed,middlePressed,ringPressed,littlePressed,palmPressed = false;
    boolean researchMode = false;


    PImage hand;
    PImage thumb;
    PImage index;
    PImage middle;
    PImage ring;
    PImage little;
    PImage palm;
    int last_command;

    Button configClose;
    Button configConfirm;
    Button connect;
    MenuList obChanList;

    ControlP5 configP5;
    String obName;
    String obBaud;
    List serialListOB;
    List baudListOB;
    int drawConfig;
    int[] fingerChans;

    boolean wasConnected;


    W_openBionics(PApplet _parent){
        super(_parent); //calls the parent CONSTRUCTOR method of Widget (DON'T REMOVE)

        //This is the protocol for setting up dropdowns.
        //Note that these 3 dropdowns correspond to the 3 global functions below
        //You just need to make sure the "id" (the 1st String) has the same name as the corresponding function

        configP5 = new ControlP5(_parent);
        wasConnected = false;


        parent = _parent;
        baudListOB = Arrays.asList("NONE","230400","115200","57600","38400","28800","19200","14400","9600","7200","4800","3600","2400","1800","1200","600","300");
        drawConfig = -1;
        fingerChans = new int[6];
        for(int i = 0; i<6; i++) fingerChans[i] = -1;

        hand = loadImage("hand.png");
        thumb = loadImage("thumb_over.png");
        index = loadImage("index_over.png");
        middle = loadImage("middle_over.png");
        ring = loadImage("ring_over.png");
        little = loadImage("little_over.png");
        palm = loadImage("palm_over.png");

        String[] serialPortsLocal = Serial.list();
        serialListOB = new ArrayList();
        serialListOB.add("NONE");
        for (int i = 0; i < serialPortsLocal.length; i++) {
            String tempPort = serialPortsLocal[(serialPortsLocal.length-1) - i]; //list backwards... because usually our port is at the bottom
            if(!tempPort.equals(openBCI_portName)) serialListOB.add(tempPort);
        }

        configClose = new Button(PApplet.parseInt(x) + w/4,PApplet.parseInt(y) + 3*navHeight,PApplet.parseInt(w/25.3f),PApplet.parseInt(w/25.3f),"X",fontInfo.buttonLabel_size);
        configConfirm = new Button(PApplet.parseInt(x) + w/2 + w/7,PApplet.parseInt(y) + 12*navHeight,PApplet.parseInt(w/10.12f),PApplet.parseInt(w/25.3f),"OKAY",fontInfo.buttonLabel_size);
        connect = new Button(PApplet.parseInt(x) + w - (w/7), PApplet.parseInt(y) + 10*navHeight, PApplet.parseInt(w/8), PApplet.parseInt(w/25.3f), "CONNECT", fontInfo.buttonLabel_size);

        obChanList = new MenuList(configP5, "obChanList", 100, 120, f2);
        obChanList.setPosition(x+w/3 + w/12, y + h/3 + h/16);
        obChanList.addItem(makeItem("NONE"));
        obChanList.activeItem = 0;
        for(int i = 0; i < nchan; i++) obChanList.addItem(makeItem("" + (i+1)));

        addDropdown("OpenBionicsSerialOut", "Serial Output", serialListOB, 0);
        addDropdown("BaudList", "Baud List", baudListOB, 0);
        configP5.get(MenuList.class, "obChanList").setVisible(false);
        // addDropdown("Dropdown3", "Drop 3", Arrays.asList("F", "G", "H", "I"), 3);

    }
    public void process(){
        int output_normalized;
        StringBuilder researchCommand = new StringBuilder();

        if(OpenBionicsHand != null ){
                if(!researchMode){
                    OpenBionicsHand.write("A10\n");
                    researchMode = true;
                }
                byte inByte = PApplet.parseByte(OpenBionicsHand.read());

                println("inByte = " + inByte);
        }

        if(fingerChans[5] == -1){

                if(OpenBionicsHand != null){


                for(int i = 0; i<5; i++){
                    //================= OpenBionics Analog Movement =======================
                    if(fingerChans[i] == -1) output_normalized = 0;
                    else output_normalized = PApplet.parseInt(map(w_emg.motorWidgets[fingerChans[i]].output_normalized, 0, 1, 0, 1023));

                    if(i == 4) researchCommand.append(output_normalized + "\n");
                    else researchCommand.append(output_normalized + ",");

                }
                OpenBionicsHand.write(researchCommand.toString());
            }
        }
        else {

            if(OpenBionicsHand != null){

                output_normalized = PApplet.parseInt(map(w_emg.motorWidgets[fingerChans[5]].output_normalized, 0, 1, 0, 100));
                OpenBionicsHand.write("G0P" + output_normalized + "\n");

            }

        }
    }

    public void update(){
        super.update(); //calls the parent update() method of Widget (DON'T REMOVE)
        process();
    }

    public void draw(){
        super.draw(); //calls the parent draw() method of Widget (DON'T REMOVE)

        //remember to refer to x,y,w,h which are the positioning variables of the Widget class
        pushStyle();

        //configP5.setVisible(true);

        //draw FFT Graph w/ all plots
        noStroke();
        fill(255);
        rect(x, y, w, h);

        obChanList.setPosition(x+w/3 + w/12, y + h/3 + h/16);

        switch(drawConfig){
            case -1:
                image(hand,x + w/4,y+2*navHeight + 2, w/2,h/2 + h/3 );

                if(overThumb()) image(thumb,x + w/4,y+2*navHeight + 2, w/2,h/2 + h/3 );
                else if(overIndex()) image(index,x + w/4,y+2*navHeight + 2, w/2,h/2 + h/3 );
                else if(overMiddle()) image(middle,x + w/4,y+2*navHeight + 2, w/2,h/2 + h/3 );
                else if(overRing()) image(ring,x + w/4,y+2*navHeight + 2, w/2,h/2 + h/3 );
                else if(overLittle()) image(little,x + w/4,y+2*navHeight + 2, w/2,h/2 + h/3 );
                else if(overPalm()) image(palm,x + w/4,y+2*navHeight + 2, w/2,h/2 + h/3 );
                configP5.get(MenuList.class, "obChanList").setVisible(false);
                configP5.get(MenuList.class, "obChanList").activeItem = 0;
                if(wasConnected){
                    fill(0,250,0);
                    ellipse(x + 5 * (w/6) ,y + 7 * (h/10),20,20);
                }
                else{
                    fill(250,0,0);
                    ellipse(x + 5 * (w/6),y + 7 * (h/10),20,20);
                }
                connect.draw();
                break;
            case 0:
                configP5.get(MenuList.class, "obChanList").activeItem = fingerChans[drawConfig] + 1;
                configP5.get(MenuList.class, "obChanList").setVisible(true);
                fill(180,180,180);
                rect(PApplet.parseInt(x) + w/4,PApplet.parseInt(y) + 3*navHeight, w/2, h/2 + 2*navHeight + navHeight/2);
                configClose.draw();
                configConfirm.draw();
                fill(10,10,10);
                textFont(f);
                textSize(12);
                text("Thumb Channel Selection", x + w/3, y + 4*navHeight);
                break;
            case 1:
                configP5.get(MenuList.class, "obChanList").activeItem = fingerChans[drawConfig] + 1;
                configP5.get(MenuList.class, "obChanList").setVisible(true);
                fill(180,180,180);
                rect(PApplet.parseInt(x) + w/4,PApplet.parseInt(y) + 3*navHeight, w/2, h/2 + 2*navHeight + navHeight/2);
                configClose.draw();
                configConfirm.draw();
                fill(10,10,10);
                textFont(f);
                textSize(12);
                text("Index Finger Channel Selection", x + w/3, y + 4*navHeight);
                break;
            case 2:
                configP5.get(MenuList.class, "obChanList").activeItem = fingerChans[drawConfig] + 1;
                configP5.get(MenuList.class, "obChanList").setVisible(true);
                fill(180,180,180);
                rect(PApplet.parseInt(x) + w/4,PApplet.parseInt(y) + 3*navHeight, w/2, h/2 + 2*navHeight + navHeight/2);
                configClose.draw();
                configConfirm.draw();
                fill(10,10,10);
                textFont(f);
                textSize(12);
                text("Middle Finger Channel Selection", x + w/3, y + 4*navHeight);
                break;
            case 3:
                configP5.get(MenuList.class, "obChanList").activeItem = fingerChans[drawConfig] + 1;
                configP5.get(MenuList.class, "obChanList").setVisible(true);
                fill(180,180,180);
                rect(PApplet.parseInt(x) + w/4,PApplet.parseInt(y) + 3*navHeight, w/2, h/2 + 2*navHeight + navHeight/2);
                configClose.draw();
                configConfirm.draw();
                fill(10,10,10);
                textFont(f);
                textSize(12);
                text("Ring Finger Channel Selection", x + w/3, y + 4*navHeight);
                break;
            case 4:
                configP5.get(MenuList.class, "obChanList").activeItem = fingerChans[drawConfig] + 1;
                configP5.get(MenuList.class, "obChanList").setVisible(true);
                fill(180,180,180);
                rect(PApplet.parseInt(x) + w/4,PApplet.parseInt(y) + 3*navHeight, w/2, h/2 + 2*navHeight + navHeight/2);
                configClose.draw();
                configConfirm.draw();
                fill(10,10,10);
                textFont(f);
                textSize(12);
                text("Little Finger Channel Selection", x + w/3, y + 4*navHeight);
                break;
            case 5:
                configP5.get(MenuList.class, "obChanList").activeItem = fingerChans[drawConfig] + 1;
                configP5.get(MenuList.class, "obChanList").setVisible(true);
                fill(180,180,180);
                rect(PApplet.parseInt(x) + w/4,PApplet.parseInt(y) + 3*navHeight, w/2, h/2 + 2*navHeight + navHeight/2);
                configClose.draw();
                configConfirm.draw();
                fill(10,10,10);
                textFont(f);
                textSize(12);
                text("Hand Channel Selection", x + w/3, y + 4*navHeight);
                break;
        }
        configP5.draw();

        popStyle();

    }

    public void screenResized(){
        super.screenResized(); //calls the parent screenResized() method of Widget (DON'T REMOVE)

        configClose = new Button(PApplet.parseInt(x) + w/4,PApplet.parseInt(y) + 3*navHeight,PApplet.parseInt(w/25.3f),PApplet.parseInt(w/25.3f),"X",fontInfo.buttonLabel_size);
        configConfirm = new Button(PApplet.parseInt(x) + w/2 + w/7,PApplet.parseInt(y) + 12*navHeight,PApplet.parseInt(w/10.12f),PApplet.parseInt(w/25.3f),"OKAY",fontInfo.buttonLabel_size);

        //update dropdown menu positions
        configP5.setGraphics(parent, 0, 0); //remaps the cp5 controller to the new PApplet window size
        int dropdownPos;
        int dropdownWidth = 60;
        dropdownPos = 1; //work down from 4 since we're starting on the right side now...
        configP5.getController("OpenBionicsSerialOut")
            .setPosition(x+w-(dropdownWidth*(dropdownPos+1))-(2*(dropdownPos+1)), navHeight+(y+2)) //float right
            ;
        dropdownPos = 0;
        try{
        configP5.getController("LogLin")
            .setPosition(x+w-(dropdownWidth*(dropdownPos+1))-(2*(dropdownPos+1)), navHeight+(y+2)) //float right
            ;
        }
        catch(Exception e){
            println("OpenBionics: error resizing...");
        }

    }

    public void mousePressed(){
        super.mousePressed(); //calls the parent mousePressed() method of Widget (DON'T REMOVE)

        if(drawConfig == -1){
            if(overThumb()) thumbPressed = true;
            else if(overIndex()) indexPressed = true;
            else if(overMiddle()) middlePressed = true;
            else if(overRing()) ringPressed = true;
            else if(overLittle()) littlePressed = true;
            else if(overPalm()) palmPressed = true;
            else if(connect.isMouseHere()) connect.wasPressed = true;
        }
        else{
            if(configClose.isMouseHere()) configClose.wasPressed= true;
            else if(configConfirm.isMouseHere()) configConfirm.wasPressed= true;
        }


    }

    public void mouseReleased(){
        super.mouseReleased(); //calls the parent mouseReleased() method of Widget (DON'T REMOVE)
        if(drawConfig == -1){
            if (overThumb() && thumbPressed){drawConfig = 0;}
            else if (overIndex() && indexPressed){drawConfig= 1;}
            else if (overMiddle() && middlePressed){drawConfig = 2;}
            else if (overRing() && ringPressed){drawConfig = 3;}
            else if (overLittle() && littlePressed){drawConfig = 4;}
            else if (overPalm() && palmPressed){drawConfig = 5;}
            else if(connect.isMouseHere() && connect.wasPressed){

                //Connect to OpenBionics Hand
                try{

                    OpenBionicsHand = new Serial(parent,obName,Integer.parseInt(obBaud));
                    verbosePrint("Connected to OpenBionics Hand");
                    wasConnected = true;
                }
                catch(Exception e){
                    wasConnected = false;
                    println(e);
                    verbosePrint("Could not connect to OpenBionics Hand");
                }
            }

            thumbPressed = false;
            indexPressed = false;
            middlePressed = false;
            ringPressed = false;
            littlePressed = false;
            palmPressed = false;
            cursor(ARROW);


        }
        else{
            if(configClose.isMouseHere() && configClose.wasPressed) {
                configClose.wasPressed= false;
                drawConfig = -1;
            }
            else if(configConfirm.isMouseHere() && configConfirm.wasPressed){
                configConfirm.wasPressed= false;
                drawConfig = -1;
            }
        }

    }

    public boolean overThumb(){
        if(mouseX >= x + w/3.9f && mouseX <=x + w/2.5f && mouseY >= y + h/1.8f && mouseY <= y + h/1.32f){
            cursor(HAND);
            return true;
        }
        else{
            cursor(ARROW);
            return false;
        }
    }
    public boolean overIndex(){
        if(mouseX >= x + w/2.65f && mouseX <=x + w/2.07f && mouseY >= y + h/4.89f && mouseY <= y + h/1.99f){
            cursor(HAND);
            return true;
        }
        else{
            cursor(ARROW);
            return false;
        }
    }
    public boolean overMiddle(){
        if(mouseX >= x + w/2.01f && mouseX <=x + w/1.79f && mouseY >= y + h/7.08f && mouseY <= y + h/2.14f){
            cursor(HAND);
            return true;
        }
        else{
            cursor(ARROW);
            return false;
        }
    }
    public boolean overRing(){
        if(mouseX >= x + w/1.73f && mouseX <=x + w/1.5f && mouseY >= y + h/5.59f && mouseY <= y + h/1.95f){
            cursor(HAND);
            return true;
        }
        else{
            cursor(ARROW);
            return false;
        }
    }
    public boolean overLittle(){
        if(mouseX >= x + w/1.54f && mouseX <=x + w/1.34f && mouseY >= y + h/3.13f && mouseY <= y + h/1.78f){
            cursor(HAND);
            return true;
        }
        else{
            cursor(ARROW);
            return false;
        }
    }
    public boolean overPalm(){
        if(mouseX >= x + w/2.47f && mouseX <=x + w/1.48f && mouseY >= y + h/1.89f && mouseY <= y + h/1.05f){
            cursor(HAND);
            return true;
        }
        else{
            cursor(ARROW);
            return false;
        }
    }

    //add custom classes functions here
    public void customFunction(){
        //this is a fake function... replace it with something relevant to this widget
    }

};

//These functions need to be global! These functions are activated when an item from the corresponding dropdown is selected
public void OpenBionicsSerialOut(int n){

    if(!w_openbionics.serialListOB.get(n).equals("NONE")) w_openbionics.obName = (String)w_openbionics.serialListOB.get(n);

    closeAllDropdowns(); // do this at the end of all widget-activated functions to ensure proper widget interactivity ... we want to make sure a click makes the menu close
}

public void BaudList(int n){
    if(!w_openbionics.baudListOB.get(n).equals("NONE")) w_openbionics.obBaud = (String)w_openbionics.baudListOB.get(n);
    closeAllDropdowns();
}

public void obChanList(int n){
    w_openbionics.fingerChans[w_openbionics.drawConfig] = n - 1;
    closeAllDropdowns();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
//    W_playback.pde (ie "Playback History")
//
//    Allow user to load playback files from within GUI without having to restart the system
//                       Created: Richard Waltman - August 2018
*/
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ControlP5 cp5_playback;

//Used mostly in W_playback.pde
JSONObject savePlaybackHistoryJSON;
JSONObject loadPlaybackHistoryJSON;
final String userPlaybackHistoryFile = settings.settingsPath+"UserPlaybackHistory.json";
boolean playbackHistoryFileExists = false;
String playbackData_ShortName;
boolean recentPlaybackFilesHaveUpdated = false;

class W_playback extends Widget {
    //allow access to dataProcessing
    DataProcessing dataProcessing;
    //Set up variables for Playback widget
    Button selectPlaybackFileButton;
    MenuList playbackMenuList;
    //Used for spacing
    int padding = 10;

    private boolean visible = true;
    private boolean updating = true;
    private boolean menuHasUpdated = false;
    private boolean menuListIsLocked = false;

    W_playback(PApplet _parent) {
        super(_parent); //calls the parent CONSTRUCTOR method of Widget (DON'T REMOVE)

        //make a button to load new files
        selectPlaybackFileButton = new Button (
            x + w/2 - (padding*2),
            y - navHeight + 2,
            200,
            navHeight - 6,
            "SELECT PLAYBACK FILE",
            fontInfo.buttonLabel_size);
        selectPlaybackFileButton.setHelpText("Click to open a dialog box to select an OpenBCI playback file (.txt or .csv).");
        //make a MenuList
        int initialWidth = w - padding*2;
        cp5_playback = new ControlP5(pApplet);
        playbackMenuList = new MenuList(cp5_playback, "playbackMenuList", initialWidth, h - padding*2, p4);
        playbackMenuList.setPosition(x + padding/2, y + 2);
        playbackMenuList.setSize(initialWidth, h - padding*2);
        playbackMenuList.scrollerLength = 40;
        cp5_playback.get(MenuList.class, "playbackMenuList").setVisible(true);
        cp5_playback.setAutoDraw(false);
    }

    public boolean isVisible() {
        return visible;
    }
    public boolean isUpdating() {
        return updating;
    }

    public void setVisible(boolean _visible) {
        visible = _visible;
    }
    public void setUpdating(boolean _updating) {
        updating = _updating;
    }

    public void update() {
        super.update(); //calls the parent update() method of Widget (DON'T REMOVE)
        if (!menuHasUpdated) {
            refreshPlaybackList();
            menuHasUpdated = true;
        }
        //Lock the MenuList if Widget selector is open, otherwise update
        if (cp5_widget.get(ScrollableList.class, "WidgetSelector").isOpen()) {
            if (!menuListIsLocked) {
                cp5_playback.get(MenuList.class, "playbackMenuList").lock();
                cp5_playback.get(MenuList.class, "playbackMenuList").setUpdate(false);
                menuListIsLocked = true;
            }
        } else {
            if (menuListIsLocked) {
                cp5_playback.get(MenuList.class, "playbackMenuList").unlock();
                cp5_playback.get(MenuList.class, "playbackMenuList").setUpdate(true);
                menuListIsLocked = false;
            }
            playbackMenuList.updateMenu();
        }

    }

    public void draw() {
        //Only draw if the widget is visible and User settings have been loaded
        //settingsLoadedCheck is set to true after default settings are saved between Init checkpoints 4 and 5
        if(visible && settings.settingsLoaded) {
            super.draw(); //calls the parent draw() method of Widget (DON'T REMOVE)

            //x,y,w,h are the positioning variables of the Widget class
            pushStyle();
            fill(boxColor);
            stroke(boxStrokeColor);
            strokeWeight(1);
            rect(x, y, w, h);
            //Add text if needed
            /*
            fill(bgColor);
            textFont(h3, 16);
            textAlign(LEFT, TOP);
            text("PLAYBACK FILE", x + padding, y + padding);
            */
            popStyle();

            pushStyle();
            selectPlaybackFileButton.draw();
            cp5_playback.draw();
            popStyle();
        }
    } //end draw loop

    public void screenResized() {
        super.screenResized(); //calls the parent screenResized() method of Widget (DON'T REMOVE)

        //**IMPORTANT FOR CP5**//
        //This makes the cp5 objects within the widget scale properly
        cp5_playback.setGraphics(pApplet, 0, 0);

        //resize and position the playback file box and button
        selectPlaybackFileButton.setPos(x + w - selectPlaybackFileButton.but_dx - padding, y - navHeight + 2);

        playbackMenuList.setPosition(x + padding/2, y + 2);
        playbackMenuList.setSize(w - padding*2, h - padding*2);
        refreshPlaybackList();
    } //end screen Resized

    public void mouseOver() {
        if (topNav.configSelector.isVisible) {
            selectPlaybackFileButton.setIsActive(false);
        }
    }

    public void mousePressed() {
        super.mousePressed(); //calls the parent mousePressed() method of Widget (DON'T REMOVE)
        if (!topNav.configSelector.isVisible) {
            //check if mouse is over the select playback file button
            if (selectPlaybackFileButton.isMouseHere()) {
                selectPlaybackFileButton.setIsActive(true);
            }
        }
    } // end mouse Pressed

    public void mouseReleased() {
        super.mouseReleased(); //calls the parent mouseReleased() method of Widget (DON'T REMOVE)
        //check if user has clicked on the select playback file button
        if (selectPlaybackFileButton.isMouseHere() && selectPlaybackFileButton.isActive) {
            output("select a file for playback");
            selectInput("Select a pre-recorded file for playback:", "playbackSelectedWidgetButton");
        }
        selectPlaybackFileButton.setIsActive(false);
    } // end mouse Released

    public void refreshPlaybackList() {
        try {
            playbackMenuList.items.clear();
            loadPlaybackHistoryJSON = loadJSONObject(userPlaybackHistoryFile);
            JSONArray loadPlaybackHistoryJSONArray = loadPlaybackHistoryJSON.getJSONArray("playbackFileHistory");
            //println("Array Size:" + loadPlaybackHistoryJSONArray.size());
            int currentFileNameToDraw = 0;
            for (int i = loadPlaybackHistoryJSONArray.size() - 1; i >= 0; i--) { //go through array in reverse since using append
                JSONObject loadRecentPlaybackFile = loadPlaybackHistoryJSONArray.getJSONObject(i);
                int fileNumber = loadRecentPlaybackFile.getInt("recentFileNumber");
                String shortFileName = loadRecentPlaybackFile.getString("id");
                String longFilePath = loadRecentPlaybackFile.getString("filePath");

                int totalPadding = padding + playbackMenuList.padding;
                shortFileName = shortenString(shortFileName, w-totalPadding*2.f, p4);
                //add as an item in the MenuList
                playbackMenuList.addItem(makeItem(shortFileName, Integer.toString(fileNumber), longFilePath));
                currentFileNameToDraw++;
            }
            playbackMenuList.updateMenu();
        } catch (NullPointerException e) {
            println("PlaybackWidget: Playback history file not found.");
        }
    }
}; //end Playback widget class

//////////////////////////////////////
// GLOBAL FUNCTIONS BELOW THIS LINE //
//////////////////////////////////////

//Activated when user selects a file using the "Select Playback File" button in PlaybackHistory
public void playbackSelectedWidgetButton(File selection) {
    if (selection == null) {
        println("W_Playback: playbackSelected: Window was closed or the user hit cancel.");
    } else {
        println("W_Playback: playbackSelected: User selected " + selection.getAbsolutePath());
        playbackFileSelected(selection.getAbsolutePath(), selection.getName());
        if (playbackFileIsEmpty) {
            haltLoadingFile(selection.getAbsolutePath());
        } else {
            reInitAfterPlaybackSelected();
        }
    }
}

//Activated when user selects a file using the recent file MenuList
public void userSelectedPlaybackMenuList (String filePath, int listItem) {
    if (new File(filePath).isFile()) {
        playbackFileSelected(filePath, listItem);
        if (playbackFileIsEmpty) {
            haltLoadingFile(filePath);
        } else {
            reInitAfterPlaybackSelected();
        }
    } else {
        outputError("W_Playback: Selected file does not exist. Try another file or clear settings to remove this entry.");
    }
}

public void reInitAfterPlaybackSelected() {
    //Tell TS widget that the number of channel bars needs to be updated
    w_timeSeries.updateNumberOfChannelBars = true;
    //Reinitialize core data, EMG, FFT, and Headplot number of channels
    reinitializeCoreDataAndFFTBuffer();
    //Update the MenuList in the PlaybackHistory Widget
    w_playback.refreshPlaybackList();
    //Process the file again to fix issue. This makes indexes for playback slider load properly
    try {
        hasRepeated = false;
        has_processed = false;
        process_input_file();
        println("+++GUI update process file has occurred");
    }
    catch(Exception e) {
        isOldData = true;
        output("+++Error processing timestamps, are you using old data?");
    }
}

//Called when user selects a playback file from dialog box
public void playbackFileSelected(File selection) {
    if (selection == null) {
        println("DataLogging: playbackSelected: Window was closed or the user hit cancel.");
    } else {
        println("DataLogging: playbackSelected: User selected " + selection.getAbsolutePath());
        //Set the name of the file
        playbackFileSelected(selection.getAbsolutePath(), selection.getName());
        if (playbackFileIsEmpty) {
            haltLoadingFile(selection.getAbsolutePath());
            return;
        }
    }
}

//Called when user selects a playback file from a list
public void playbackFileSelected (String longName, int listItem) {
    String shortName = "";
    //look at the JSON file to set the range menu using number of recent file entries
    try {
        savePlaybackHistoryJSON = loadJSONObject(userPlaybackHistoryFile);
        JSONArray recentFilesArray = savePlaybackHistoryJSON.getJSONArray("playbackFileHistory");
        JSONObject playbackFile = recentFilesArray.getJSONObject(-listItem + recentFilesArray.size() - 1);
        shortName = playbackFile.getString("id");
        playbackHistoryFileExists = true;
    } catch (NullPointerException e) {
        //println("Playback history JSON file does not exist. Load first file to make it.");
        playbackHistoryFileExists = false;
    }
    playbackFileSelected(longName, shortName);
    if (playbackFileIsEmpty) {
        haltLoadingFile(longName);
        return;
    }
}

//Handles the work for the above two cases
public void playbackFileSelected (String longName, String shortName) {
    playbackData_fname = longName;
    playbackData_ShortName = shortName;
    //Process the playback file
    processNewPlaybackFile();
    if (playbackFileIsEmpty) return;
    //Determine the number of channels
    if (playbackData_table != null) {
        determineNumChanFromFile(playbackData_table);
    } else {
        outputError("playbackFileSelected: Data table appears to be null! Please submit an issue on GitHub!");
        return;
    }
    //Output new playback settings to GUI as success
    outputSuccess("You have selected \""
    + shortName + "\" for playback. "
    + str(nchan) + " channels found.");
    try {
        savePlaybackHistoryJSON = loadJSONObject(userPlaybackHistoryFile);
        JSONArray recentFilesArray = savePlaybackHistoryJSON.getJSONArray("playbackFileHistory");
        playbackHistoryFileExists = true;
    } catch (NullPointerException e) {
        //println("Playback history JSON file does not exist. Load first file to make it.");
        playbackHistoryFileExists = false;
    } catch (RuntimeException e) {
        outputError("Found an error in UserPlaybackHistory.json. Deleting this file. Please, Restart the GUI.");
        File file = new File(userPlaybackHistoryFile);
        if (!file.isDirectory()) {
            file.delete();
        }
    }
    //add playback file that was processed to the JSON history
    savePlaybackFileToHistory(longName);
}

public void processNewPlaybackFile() { //Also used in DataLogging.pde
    //Fix issue for processing successive playback files
    indices = 0;
    hasRepeated = false;
    has_processed = false;
    if (systemMode == SYSTEMMODE_POSTINIT) {
        w_timeSeries.scrollbar.skipToStartButtonAction(); //sets scrollbar to 0
    }
    //initialize playback file
    initPlaybackFileToTable();
}

//NEEDS TO BE UPDATED TO MORE EFFICIENT METHOD
//Currently looks at the total number of Columns
//Maybe try counting the number of columns after first index and before X...
//...where X is the unique data type that occurs after last channel
public void determineNumChanFromFile(Table datatable) {
    int numColumnsPlaybackFile = datatable.getColumnCount();
    int numChannelsFoundInPlaybackFile;
    if (numColumnsPlaybackFile > totalColumns16ChanThresh) {
        numChannelsFoundInPlaybackFile = 16;
    } else if (numColumnsPlaybackFile <= totalColumns4ChanThresh) {
        numChannelsFoundInPlaybackFile = 4;
    } else {
        numChannelsFoundInPlaybackFile = 8;
    }
    updateToNChan(numChannelsFoundInPlaybackFile);
}

public void initPlaybackFileToTable() { //also used in OpenBCI_GUI.pde on system start
    //open and load the data file
    println("OpenBCI_GUI: initSystem: loading playback data from " + playbackData_fname);
    playbackFileIsEmpty = false; //reset this flag each time playback data is loaded
    boolean errorLoadingTable = false;

    errorLoadingTable = loadTableFromCSV();

    //Sometimes the SD card converted files have blank space at the end, remove it and try to connect again
    if (errorLoadingTable) {
        println("initPlaybackFileToTable: Deleting last line of file and trying again...");
        try {
            RandomAccessFile f = new RandomAccessFile(playbackData_fname, "rw");
            long length = f.length() - 1;
            byte b; 
            do {                     
                length -= 1;
                f.seek(length);
                b = f.readByte();
            } while (b != 10 && length > 0);
            f.setLength(length+1);
            f.close();
            errorLoadingTable = loadTableFromCSV();
        } catch (FileNotFoundException e) {
            println("initPlaybackFileToTable: Unable to locate file : " + playbackData_fname);
        } catch (IOException e) {
            println("initPlaybackFileToTable: Unable to locate file : " + playbackData_fname);
        }
    }

    //If we are still unable to load data into a table from file, exit method
    if (errorLoadingTable) {
        return;
    }

    try {
        int rowCount = playbackData_table.getRowCount();
        int fileDurationInSeconds = round(PApplet.parseFloat(playbackData_table.getRowCount())/getSampleRateSafe());
        println("OpenBCI_GUI: initSystem: loading complete.  " 
                + rowCount 
                + " rows of data, which is " 
                +  fileDurationInSeconds
                + " seconds of EEG data");
        
        //If a playback file has less than one second of data, throw an error using a flag
        if (playbackData_table.getRowCount() <= settings.minNumRowsPlaybackFile) {
            playbackFileIsEmpty = true;
        }
    } catch (NullPointerException e) {
        println("initPlaybackFileToTable: Encountered an error - " + e);
        e.printStackTrace();
    }
}

public boolean loadTableFromCSV () {
    try {
        playbackData_table = null;
        playbackData_table = new Table_CSV(playbackData_fname);
        //removing first column of data from data file...the first column is a time index and not eeg data
        playbackData_table.removeColumn(0);
        return false;
    } catch (Exception e) {
        println("initPlaybackFileToTable: Encountered an error while loading " + playbackData_fname);
        return true;
    }
}

public void haltLoadingFile(String _filePath) {
    if (systemMode == SYSTEMMODE_POSTINIT) {
        abandonInit = true;
        initSystemButton.setString("START SESSION");
        controlPanel.open();
        haltSystem();
    }
    //Go ahead and remove this file from the Playback History
    JSONObject playbackHistoryJSON = loadJSONObject(userPlaybackHistoryFile);
    JSONArray recentFilesArray = playbackHistoryJSON.getJSONArray("playbackFileHistory");
    removePlaybackFileFromHistory(recentFilesArray, _filePath);
    outputError("Playback file appears empty. Try loading a different file.");
}

//This gets called when a playback file is selected from the Playback History Widget
public void reinitializeCoreDataAndFFTBuffer() {
    //println("Data Processing Number of Channels is: " + dataProcessing.nchan);
    dataProcessing.nchan = nchan;
    dataProcessing.fs_Hz = getSampleRateSafe();
    dataProcessing.data_std_uV = new float[nchan];
    dataProcessing.polarity = new float[nchan];
    dataProcessing.newDataToSend = false;
    dataProcessing.avgPowerInBins = new float[nchan][dataProcessing.processing_band_low_Hz.length];
    dataProcessing.headWidePower = new float[dataProcessing.processing_band_low_Hz.length];
    dataProcessing.defineFilters();  //define the filters anyway just so that the code doesn't bomb

    //initialize core data objects
    initCoreDataObjects();
    //verbosePrint("W_Playback: initSystem: -- Init 1 -- " + millis());

    initFFTObjectsAndBuffer();

    //verbosePrint("W_Playback: initSystem: -- Init 2 -- " + millis());

    //Update the number of channels for FFT
    w_fft.fft_points = null;
    w_fft.fft_points = new GPointsArray[nchan];
    w_fft.initializeFFTPlot(ourApplet);
    w_fft.update();

    //Update the number of channels for EMG
    w_emg.motorWidgets = null;
    w_emg.updateEMGMotorWidgets(nchan);

    //Update the number of channels for HeadPlot
    w_headPlot.headPlot = null;
    w_headPlot.updateHeadPlot(nchan);
    
    //Update channelSelect in bandPower and SSVEP widgets
    w_bandPower.bpChanSelect.createCheckList(nchan);
    w_bandPower.activateAllChannels();
    w_ssvep.ssvepChanSelect.createCheckList(nchan);
    w_ssvep.activateDefaultChannels();
}

public void savePlaybackFileToHistory(String fileName) {
    int maxNumHistoryFiles = 36;
    if (playbackHistoryFileExists) {
        println("Found user playback history file!");
        savePlaybackHistoryJSON = loadJSONObject(userPlaybackHistoryFile);
        JSONArray recentFilesArray = savePlaybackHistoryJSON.getJSONArray("playbackFileHistory");
        //println("ARRAYSIZE-Check1: " + int(recentFilesArray.size()));
        //Recent file has recentFileNumber=0, and appears at the end of the JSON array
        //check if already in the list, if so, remove from the list
        removePlaybackFileFromHistory(recentFilesArray, playbackData_fname);
        //next, increment fileNumber of all current entries +1
        for (int i = 0; i < recentFilesArray.size(); i++) {
            JSONObject playbackFile = recentFilesArray.getJSONObject(i);
            playbackFile.setInt("recentFileNumber", recentFilesArray.size()-i);
            //println(recentFilesArray.size()-i);
            playbackFile.setString("id", playbackFile.getString("id"));
            playbackFile.setString("filePath", playbackFile.getString("filePath"));
            recentFilesArray.setJSONObject(i, playbackFile);
        }
        //println("ARRAYSIZE-Check2: " + int(recentFilesArray.size()));
        //append selected playback file to position 1 at the end of the JSONArray
        JSONObject mostRecentFile = new JSONObject();
        mostRecentFile.setInt("recentFileNumber", 0);
        mostRecentFile.setString("id", playbackData_ShortName);
        mostRecentFile.setString("filePath", playbackData_fname);
        recentFilesArray.append(mostRecentFile);
        //remove entries greater than max num files
        if (recentFilesArray.size() >= maxNumHistoryFiles) {
            for (int i = 0; i <= recentFilesArray.size()-maxNumHistoryFiles; i++) {
                recentFilesArray.remove(i);
                println("ARRAY INDEX " + i + " REMOVED----");
            }
        }
        //println("ARRAYSIZE-Check3: " + int(recentFilesArray.size()));
        //printArray(recentFilesArray);

        //save the JSON array and file
        savePlaybackHistoryJSON.setJSONArray("playbackFileHistory", recentFilesArray);
        saveJSONObject(savePlaybackHistoryJSON, userPlaybackHistoryFile);

    } else if (!playbackHistoryFileExists) {
        println("Playback history file not found. making a new one.");
        //do this if the file does not exist
        JSONObject newHistoryFile;
        newHistoryFile = new JSONObject();
        JSONArray newHistoryFileArray = new JSONArray();
        //save selected playback file to position 1 in recent file history
        JSONObject mostRecentFile = new JSONObject();
        mostRecentFile.setInt("recentFileNumber", 0);
        mostRecentFile.setString("id", playbackData_ShortName);
        mostRecentFile.setString("filePath", playbackData_fname);
        newHistoryFileArray.setJSONObject(0, mostRecentFile);
        //newHistoryFile.setJSONArray("")

        //save the JSON array and file
        newHistoryFile.setJSONArray("playbackFileHistory", newHistoryFileArray);
        saveJSONObject(newHistoryFile, userPlaybackHistoryFile);

        //now the file exists!
        println("Playback history JSON has been made!");
        playbackHistoryFileExists = true;
    }
}

public void removePlaybackFileFromHistory(JSONArray array, String _filePath) {
    //check if already in the list, if so, remove from the list
    for (int i = 0; i < array.size(); i++) {
        JSONObject playbackFile = array.getJSONObject(i);
        //println("CHECKING " + i + " : " + playbackFile.getString("id") + " == " + fileName + " ?");
        if (playbackFile.getString("filePath").equals(_filePath)) {
            array.remove(i);
            //println("REMOVED: " + fileName);
        }
    }
}

////////////////////////////////////////////////////
//
//    W_PulseSensor.pde
//
//    Created: Joel Murphy, Spring 2017
//
///////////////////////////////////////////////////,

class W_PulseSensor extends Widget {

    //to see all core variables/methods of the Widget class, refer to Widget.pde
    //put your custom variables here...


    int graphStroke = 0xffd2d2d2;
    int graphBG = 0xfff5f5f5;
    int textColor = 0xff000000;

// Pulse Sensor Visualizer Stuff
    int count = 0;
    int heart = 0;
    int PulseBuffSize = dataPacketBuff.length; // Originally 400
    int BPMbuffSize = 100;

    int PulseWindowWidth;
    int PulseWindowHeight;
    int PulseWindowX;
    int PulseWindowY;
    int BPMwindowWidth;
    int BPMwindowHeight;
    int BPMwindowX;
    int BPMwindowY;
    int BPMposX;
    int BPMposY;
    int IBIposX;
    int IBIposY;
    int padding = 15;
    int eggshell;
    int pulseWave;
    int[] PulseWaveY;      // HOLDS HEARTBEAT WAVEFORM DATA
    int[] BPMwaveY;        // HOLDS BPM WAVEFORM DATA
    boolean rising;

    // Synthetic Wave Generator Stuff
    float theta;  // Start angle at 0
    float amplitude;  // Height of wave
    int syntheticMultiplier;
    long thisTime;
    long thatTime;
    int refreshRate;

    // Pulse Sensor Beat Finder Stuff
    // ASSUMES 250Hz SAMPLE RATE
    int[] rate;                    // array to hold last ten IBI values
    int sampleCounter;          // used to determine pulse timing
    int lastBeatTime;           // used to find IBI
    int P =512;                      // used to find peak in pulse wave, seeded
    int T = 512;                     // used to find trough in pulse wave, seeded
    int thresh = 530;                // used to find instant moment of heart beat, seeded
    int amp = 0;                   // used to hold amplitude of pulse waveform, seeded
    boolean firstBeat = true;        // used to seed rate array so we startup with reasonable BPM
    boolean secondBeat = false;      // used to seed rate array so we startup with reasonable BPM
    int BPM;                   // int that holds raw Analog in 0. updated every 2mS
    int Signal;                // holds the incoming raw data
    int IBI = 600;             // int that holds the time interval between beats! Must be seeded!
    boolean Pulse = false;     // "True" when User's live heartbeat is detected. "False" when not a "live beat".
    boolean QS = false;        // becomes true when Arduoino finds a beat.
    int lastProcessedDataPacketInd = 0;
    boolean analogReadOn = false;

    // testing stuff

    Button analogModeButton;



    W_PulseSensor(PApplet _parent){
        super(_parent); //calls the parent CONSTRUCTOR method of Widget (DON'T REMOVE)



        // Pulse Sensor Stuff
        eggshell = color(255, 253, 248);
        pulseWave = color(224, 56, 45);

        PulseWaveY = new int[PulseBuffSize];
        BPMwaveY = new int[BPMbuffSize];
        rate = new int[10];
        setPulseWidgetVariables();
        initializePulseFinderVariables();

        analogModeButton = new Button((int)(x + 3), (int)(y + 3 - navHeight), 128, navHeight - 6, "Turn Analog Read On", 12);
        analogModeButton.setCornerRoundess((int)(navHeight-6));
        analogModeButton.setFont(p5,12);
        analogModeButton.setColorNotPressed(color(57,128,204));
        analogModeButton.textColorNotActive = color(255);
        analogModeButton.hasStroke(false);
        analogModeButton.setHelpText("Click this button to activate/deactivate analog read on Cyton.");

    }

    public void update(){
        super.update(); //calls the parent update() method of Widget (DON'T REMOVE)

        if (curDataPacketInd < 0) return;

        if (eegDataSource == DATASOURCE_CYTON) {  // LIVE FROM CYTON

        } else if (eegDataSource == DATASOURCE_GANGLION) {  // LIVE FROM GANGLION

        } else if (eegDataSource == DATASOURCE_SYNTHETIC) {  // SYNTHETIC

        }
        else {  // PLAYBACK

        }

        int numSamplesToProcess = curDataPacketInd - lastProcessedDataPacketInd;
        if (numSamplesToProcess < 0) {
            numSamplesToProcess += dataPacketBuff.length; //<>// //<>//
        }
        // Shift internal ring buffer numSamplesToProcess
        if (numSamplesToProcess > 0) {
            for(int i=0; i < PulseWaveY.length - numSamplesToProcess; i++){
                PulseWaveY[i] = PulseWaveY[i+numSamplesToProcess]; //<>// //<>//
            }
        }

        // for each new sample
        int samplesProcessed = 0;
        while (samplesProcessed < numSamplesToProcess) {
            lastProcessedDataPacketInd++;

            // Watch for wrap around
            if (lastProcessedDataPacketInd > dataPacketBuff.length - 1) {
                lastProcessedDataPacketInd = 0;
            }

            int signal = dataPacketBuff[lastProcessedDataPacketInd].auxValues[0];


            processSignal(signal);
            PulseWaveY[PulseWaveY.length - numSamplesToProcess + samplesProcessed] = signal; //<>// //<>//
            //println("BPM, Signal, IBI ~~~~ " + BPM + "," +  signal + "," + IBI);

            samplesProcessed++;
        }

        if(QS){
            QS = false;
            for(int i=0; i<BPMwaveY.length-1; i++){
                BPMwaveY[i] = BPMwaveY[i+1];
            }
            BPMwaveY[BPMwaveY.length-1] = BPM;
        }

    }

    public void draw(){
        super.draw(); //calls the parent draw() method of Widget (DON'T REMOVE)


        //remember to refer to x,y,w,h which are the positioning variables of the Widget class
        pushStyle();


        fill(graphBG);
        stroke(graphStroke);
        rect(PulseWindowX,PulseWindowY,PulseWindowWidth,PulseWindowHeight);
        rect(BPMwindowX,BPMwindowY,BPMwindowWidth,BPMwindowHeight);

        fill(50);
        textFont(p4, 16);
        textAlign(LEFT,CENTER);
        text("BPM "+BPM, BPMposX, BPMposY);
        text("IBI "+IBI+"mS", IBIposX, IBIposY);

        if (cyton.getBoardMode() != BoardMode.ANALOG) {
            analogModeButton.setString("Turn Analog Read On");
        } else {
            analogModeButton.setString("Turn Analog Read Off");
            drawWaves();
        }

        analogModeButton.draw();

        popStyle();
    }

    public void screenResized(){
        super.screenResized(); //calls the parent screenResized() method of Widget (DON'T REMOVE)

        println("Pulse Sensor Widget -- Screen Resized.");

        setPulseWidgetVariables();
        analogModeButton.setPos((int)(x + 3), (int)(y + 3 - navHeight));
    }

    public void mousePressed(){
        super.mousePressed(); //calls the parent mousePressed() method of Widget (DON'T REMOVE)

        if (analogModeButton.isMouseHere()) {
            analogModeButton.setIsActive(true);
        }
    }

    public void mouseReleased(){
        super.mouseReleased(); //calls the parent mouseReleased() method of Widget (DON'T REMOVE)

        if(analogModeButton.isActive && analogModeButton.isMouseHere()){
            if(cyton.isPortOpen()) {
                if (cyton.getBoardMode() != BoardMode.ANALOG) {
                    cyton.setBoardMode(BoardMode.ANALOG);
                    output("Starting to read analog inputs on pin marked D11.");
                    analogModeButton.setString("Turn Analog Read Off");
                    w_analogRead.analogReadOn = true; //w_PulseSensor is almost a sub-widget of w_AnalogRead, this is why AnalogRead will be activated also, this variable documents the change
                    w_digitalRead.digitalReadOn = false;
                    w_markermode.markerModeOn = false;
                } else {
                    cyton.setBoardMode(BoardMode.DEFAULT);
                    output("Starting to read accelerometer");
                    analogModeButton.setString("Turn Analog Read On");
                    w_analogRead.analogReadOn = false; //w_PulseSensor is almost a sub-widget of w_AnalogRead, this is why AnalogRead will be de-activated also, this variable documents the change
                    w_digitalRead.digitalReadOn = false;
                    w_markermode.markerModeOn = false;
                }
                analogReadOn = !analogReadOn;
            }
        }
        analogModeButton.setIsActive(false);
    }

    //add custom functions here
    public void setPulseWidgetVariables(){
        PulseWindowWidth = ((w/4)*3) - padding;
        PulseWindowHeight = h - padding *2;
        PulseWindowX = x + padding;
        PulseWindowY = y + h - PulseWindowHeight - padding;

        BPMwindowWidth = w/4 - (padding + padding/2);
        BPMwindowHeight = PulseWindowHeight; // - padding;
        BPMwindowX = PulseWindowX + PulseWindowWidth + padding/2;
        BPMwindowY = PulseWindowY; // + padding;

        BPMposX = BPMwindowX + padding/2;
        BPMposY = y - padding; // BPMwindowHeight + int(float(padding)*2.5);
        IBIposX = PulseWindowX + PulseWindowWidth/2; // + padding/2
        IBIposY = y - padding;

        // float py;
        // float by;
        // for(int i=0; i<PulseWaveY.length; i++){
        //   py = map(float(PulseWaveY[i]),
        //     0.0,1023.0,
        //     float(PulseWindowY + PulseWindowHeight),float(PulseWindowY)
        //   );
        //   PulseWaveY[i] = int(py);
        // }
        // for(int i=0; i<BPMwaveY.length; i++){
        //   BPMwaveY[i] = BPMwindowY + BPMwindowHeight-1;
        // }
    }

    public void initializePulseFinderVariables(){
        sampleCounter = 0;
        lastBeatTime = 0;
        P = 512;
        T = 512;
        thresh = 530;
        amp = 0;
        firstBeat = true;
        secondBeat = false;
        BPM = 0;
        Signal = 512;
        IBI = 600;
        Pulse = false;
        QS = false;

        theta = 0.0f;
        amplitude = 300;
        syntheticMultiplier = 1;

        thatTime = millis();

        // float py = map(float(Signal),
        //   0.0,1023.0,
        //   float(PulseWindowY + PulseWindowHeight),float(PulseWindowY)
        // );
        for(int i=0; i<PulseWaveY.length; i++){
            PulseWaveY[i] = Signal;

            // PulseWaveY[i] = PulseWindowY + PulseWindowHeight/2;
        }
        for(int i=0; i<BPMwaveY.length; i++){
            BPMwaveY[i] = BPM;
        }

    }

    public void drawWaves(){
        int xi, yi;
        noFill();
        strokeWeight(1);
        stroke(pulseWave);
        beginShape();                                  // using beginShape() renders fast
        for(int i=0; i<PulseWaveY.length; i++){
            xi = PApplet.parseInt(map(i,0, PulseWaveY.length-1,0, PulseWindowWidth-1));
            xi += PulseWindowX;
            yi = PApplet.parseInt(map(PulseWaveY[i],0.0f,1023.0f,
                PApplet.parseFloat(PulseWindowY + PulseWindowHeight),PApplet.parseFloat(PulseWindowY)));
            vertex(xi, yi);
        }
        endShape();

        strokeWeight(2);
        stroke(pulseWave);
        beginShape();                                  // using beginShape() renders fast
        for(int i=0; i<BPMwaveY.length; i++){
            xi = PApplet.parseInt(map(i,0, BPMwaveY.length-1,0, BPMwindowWidth-1));
            xi += BPMwindowX;
            yi = PApplet.parseInt(map(BPMwaveY[i], 0.0f,200.0f,
                PApplet.parseFloat(BPMwindowY + BPMwindowHeight), PApplet.parseFloat(BPMwindowY)));
            vertex(xi, yi);
        }
        endShape();

    }

    // THIS IS THE BEAT FINDING FUNCTION
    // BASED ON CODE FROM World Famous Electronics, MAKERS OF PULSE SENSOR
    // https://github.com/WorldFamousElectronics/PulseSensor_Amped_Arduino
    public void processSignal(int sample){                         // triggered when Timer2 counts to 124
        // cli();                                      // disable interrupts while we do this
        // Signal = analogRead(pulsePin);              // read the Pulse Sensor
        sampleCounter += (4 * syntheticMultiplier);                         // keep track of the time in mS with this variable
        int N = sampleCounter - lastBeatTime;       // monitor the time since the last beat to avoid noise

            //  find the peak and trough of the pulse wave
        if(sample < thresh && N > (IBI/5)*3){       // avoid dichrotic noise by waiting 3/5 of last IBI
            if (sample < T){                        // T is the trough
                T = sample;                         // keep track of lowest point in pulse wave
            }
        }

        if(sample > thresh && sample > P){          // thresh condition helps avoid noise
            P = sample;                             // P is the peak
        }                                        // keep track of highest point in pulse wave

        //  NOW IT'S TIME TO LOOK FOR THE HEART BEAT
        // signal surges up in value every time there is a pulse
        if (N > 250){                                   // avoid high frequency noise
            if ( (sample > thresh) && (Pulse == false) && (N > (IBI/5)*3) ){
                Pulse = true;                               // set the Pulse flag when we think there is a pulse
                IBI = sampleCounter - lastBeatTime;         // measure time between beats in mS
                lastBeatTime = sampleCounter;               // keep track of time for next pulse

                if(secondBeat){                        // if this is the second beat, if secondBeat == TRUE
                    secondBeat = false;                  // clear secondBeat flag
                    for(int i=0; i<=9; i++){             // seed the running total to get a realisitic BPM at startup
                        rate[i] = IBI;
                    }
                }

                if(firstBeat){                         // if it's the first time we found a beat, if firstBeat == TRUE
                    firstBeat = false;                   // clear firstBeat flag
                    secondBeat = true;                   // set the second beat flag
                    // sei();                               // enable interrupts again
                    return;                              // IBI value is unreliable so discard it
                }


                // keep a running total of the last 10 IBI values
                int runningTotal = 0;                  // clear the runningTotal variable

                for(int i=0; i<=8; i++){                // shift data in the rate array
                    rate[i] = rate[i+1];                  // and drop the oldest IBI value
                    runningTotal += rate[i];              // add up the 9 oldest IBI values
                }

                rate[9] = IBI;                          // add the latest IBI to the rate array
                runningTotal += rate[9];                // add the latest IBI to runningTotal
                runningTotal /= 10;                     // average the last 10 IBI values
                BPM = 60000/runningTotal;               // how many beats can fit into a minute? that's BPM!
                BPM = constrain(BPM,0,200);
                QS = true;                              // set Quantified Self flag
                // QS FLAG IS NOT CLEARED INSIDE THIS FUNCTION
            }
        }

        if (sample < thresh && Pulse == true){   // when the values are going down, the beat is over
            // digitalWrite(blinkPin,LOW);            // turn off pin 13 LED
            Pulse = false;                         // reset the Pulse flag so we can do it again
            amp = P - T;                           // get amplitude of the pulse wave
            thresh = amp/2 + T;                    // set thresh at 50% of the amplitude
            P = thresh;                            // reset these for next time
            T = thresh;
        }

        if (N > 2500){                           // if 2.5 seconds go by without a beat
            thresh = 530;                          // set thresh default
            P = 512;                               // set P default
            T = 512;                               // set T default
            lastBeatTime = sampleCounter;          // bring the lastBeatTime up to date
            firstBeat = true;                      // set these to avoid noise
            secondBeat = false;                    // when we get the heartbeat back
        }

        // sei();                                   // enable interrupts when youre done!
    }// end processSignal


};
////////////////////////////////////////////////////
//
//    W_SSVEP
//
//    This is an SSVEP Widget that will display frequencies for you to look at, and then observe
//    spikes in brain waves matching that frequency.
//
//    Created by: Leanne Pichay, July 2019
//
////////////////////////////////////////////////////

class W_SSVEP extends Widget {

    //frequency variables offered
    int[] freqs = new int[4];
    boolean[] ssvepOn = {true, true, true, true};

    //coords for each SSVEP — FORMAT {x0, y0, x1, y1}
    float[][] ssvepCoords = {
                             {0,0,0,0},
                             {0,0,0,0},
                             {0,0,0,0},
                             {0,0,0,0}
                                        };

    //Limiting dimension variable
    int s;

    //toggle showAbout
    boolean showAbout;

    //determine if height of widget > width
    boolean heightLarger;

    //Widget CP5s
    ControlP5 cp5_ssvep; //For all CP5 elements within the SSVEP widget
    int dropdownWidth_freq = 115;
    String[] dropdownNames = {"Frequency_1", "Frequency_2", "Frequency_3", "Frequency_4"};
    List<String> dropdownOptions = new ArrayList<String>();
    boolean freqDropdownsShouldBeClosed = false;

    public ChannelSelect ssvepChanSelect;

    //---------NETWORKING VARS
    float[] ssvepData = new float[4];
    public int  numActiveChannels;

    boolean configIsVisible = false;
    boolean layoutIsVisible = false;

    String ssvepHelpText = "For best results, set the GUI framerate to 60fps.\n\n"
                            + "The SSVEP Widget(BETA) provides visual stimulation at specific frequencies."
                            + "In response to looking at one of the SSVEPs, you will see an increase in brain activity at that frequency in the FFT plot. "
                            + "Make sure to select the electrodes that align with the back of your head, where the visual stimulus will be recognized.\n\n"
                            + "You can stop/start each SSVEP by clicking on it.\n\n"
                            + "This widget is currently in beta mode and requires more input and testing from the OpenBCI Community.";
    int ssvepHelpTextFontSize = 16;
    Button infoButton;
    int infoButtonSize = 18;

    W_SSVEP(PApplet _parent) {

        super(_parent); //calls the parent CONSTRUCTOR method of Widget (DON'T REMOVE)
        
        addDropdown("NumberSSVEP", "# SSVEPs", Arrays.asList("1", "2", "3", "4"), 0);
        // showAbout = true;
        cp5_ssvep = new ControlP5(pApplet);
        ssvepChanSelect = new ChannelSelect(pApplet, x, y, w, navH, "SSVEP_Channels");

        for (int i = 0; i < 9; i++) {
            dropdownOptions.add(String.valueOf(i+7) + " Hz");
        }
        
        //init cp5 dropdowns in reverse so ssvep dropdwns 1 & 2 draw over 3 & 4
        for (int i = dropdownNames.length - 1; i >= 0; i--) {
            createDropdown(dropdownNames[i], dropdownOptions);
        }

        if (h > w) {
            heightLarger = true;
            s = h;
        } else {
            heightLarger = false;
            s = w;
        }

        activateDefaultChannels();

        cp5_ssvep.setAutoDraw(false);
        showAbout = false;        //set Default start value for showing about section as fault

        infoButton = new Button(x + w - dropdownWidth - infoButtonSize - 10, y - navH + 2, infoButtonSize, infoButtonSize, "?", 14);
        infoButton.setCornerRoundess((int)(navHeight-6));
        infoButton.setFont(p5,12);
        infoButton.setColorNotPressed(color(57,128,204));
        infoButton.setFontColorNotActive(color(255));
        infoButton.setHelpText("Click this button to view details on the SSVEP Widget.");
        infoButton.hasStroke(false);
    }

    public void update() {
        super.update(); //calls the parent update() method of Widget (DON'T REMOVE)

        //Lock/unlock the controllers within networking widget when using TopNav Objects
        //Also locks dropdown 2 when #SSVEPs dropdown is open
        lockUnlockControllersAsNeeded();

        if (settings.numSSVEPs == 0) {  // 1 SSVEP
            freqs[0] = updateFreq(1);
        } else if (settings.numSSVEPs == 1) {
            freqs[0] = updateFreq(1);
            freqs[1] = updateFreq(2);
        } else if (settings.numSSVEPs == 2) {
            freqs[0] = updateFreq(1);
            freqs[1] = updateFreq(2);
            freqs[2] = updateFreq(3);
        } else if (settings.numSSVEPs == 3) {
            freqs[0] = updateFreq(1);
            freqs[1] = updateFreq(2);
            freqs[2] = updateFreq(3);
            freqs[3] = updateFreq(4);
        }

        //put the frequency dropdowns in the right place
        setDropdownPositions();
        if (freqDropdownsShouldBeClosed) {
            freqDropdownsShouldBeClosed = false;
        } else {
            //and open or close dropdowns based on user interaction on hover
            openCloseDropdowns();
        }

        //Update channel checkboxes and active channels
        ssvepChanSelect.update(x, y, w);

        //save the number of active channels to be analyzed (e.g. ch7+ch8 = 2 active channels)
        numActiveChannels = ssvepChanSelect.activeChan.size();
        
        //if the system is running, process SSVEP data
        if (isRunning) {
            ssvepData = processData();
            //println(ssvepData);
        }

        
    } //end of update loop

    public void draw() {
        super.draw(); //calls the parent draw() method of Widget (DON'T REMOVE)

        pushStyle();
        //put your code here... //remember to refer to x,y,w,h which are the positioning variables of the Widget class
        fill(0);
        rect(x, y, w, h);
        popStyle();

        pushStyle();
        ssvepChanSelect.draw();
        infoButton.draw();
        popStyle();

        //left side
        if (settings.numSSVEPs == 0) {  // 1 SSVEP
            //(String colour, int freq, float wFactor, float hFactor, float hOffset, float size)
            drawSSVEP("blue", freqs[0], 0.5f, 0.5f, 0, s/4);
        } else if (settings.numSSVEPs == 1) { // 2 SSVEPs
            if (heightLarger) {
                drawSSVEP("blue", freqs[0], 0.5f, 0.20f, 0, s/5);
                drawSSVEP("red", freqs[1], 0.5f, 0.70f, 0, s/5);
            } else {
                drawSSVEP("blue", freqs[0], 0.20f, 0.5f, 0, s/5);
                drawSSVEP("red", freqs[1], 0.70f, 0.5f, 0, s/5);
            }
        } else if (settings.numSSVEPs == 2) { // 3 SSVEPs
            if (heightLarger) {
                //If ssveps are arranged vertically, Add 0.1 to heightFactor with height offset of 30
                drawSSVEP("blue", freqs[0], 0.5f, 0.1f, 30.0f, s/5);
                drawSSVEP("red", freqs[1], 0.5f, 1.0f/3 + 0.1f, 30.0f, s/5);
                drawSSVEP("green", freqs[2], 0.5f, 2.0f/3 + 0.1f, 30.0f, s/5);
            } else {
                drawSSVEP("blue", freqs[0], 0.125f, 0.5f, 0, s/5);
                drawSSVEP("red", freqs[1], 0.5f, 0.5f, 0, s/5);
                drawSSVEP("green", freqs[2], 0.875f, 0.5f, 0, s/5);
            }
        } else if (settings.numSSVEPs == 3) { // 4 SSVEPs
            float sz = s/6;
            drawSSVEP("blue", freqs[0], 0.25f, 0.25f, 0, s/6);
            drawSSVEP("red", freqs[1], 0.75f, 0.25f, 0, s/6);
            drawSSVEP("green", freqs[2], 0.25f, 0.75f, 0, s/6);
            drawSSVEP("yellow", freqs[3], 0.75f, 0.75f, 0, s/6);
        }

        //draw backgrounds to dropdown scrollableLists ... unfortunately ControlP5 doesn't have this by default, so we have to hack it to make it look nice...
        pushStyle();
        fill(100);
        for (int i = 1; i <= settings.numSSVEPs + 1; i++) {
            String c = "Frequency_" + i;
            rect(cp5_ssvep.getController(c).getPosition()[0] - 1, cp5_ssvep.getController(c).getPosition()[1] - 1, dropdownWidth_freq + 2, cp5_ssvep.getController(c).getHeight()+2);
        }

        //Draw all cp5 elements within the SSVEP widget
        //Only draws elements that are visible
        //Drawing here draws on top of scrollableList background rectangles that were just drawn
        cp5_ssvep.draw();

        //If widget help button was clicked, show about details
        if (showAbout) {
            stroke(220);
            fill(20);
            rect(x + 20, y + 20, w - 40, h- 40);
            textAlign(LEFT, TOP);
            textFont(p3, ssvepHelpTextFontSize);
            fill(250);
            text(ssvepHelpText, x + 30, y + 30, w - 60, h -60);
        }

        popStyle();

    } //end of draw loop

    public void screenResized() {
        super.screenResized(); //calls the parent screenResized() method of Widget (DON'T REMOVE)

        //Resets the CP5 origin when the app is resized
        cp5_ssvep.setGraphics(pApplet, 0, 0);

        if (h > w) {
            heightLarger = true;
            s = w;
        } else {
            heightLarger = false;
            s = h;
        }

        infoButton.setPos(x + w - dropdownWidth - infoButtonSize - 10, y - navH + 2);
        
        setFreqDropdownSizes();

        ssvepChanSelect.screenResized(pApplet);
    }
    public void mousePressed() {
        super.mousePressed(); //calls the parent mousePressed() method of Widget (DON'T REMOVE)

        if (!this.dropdownIsActive) {

            if (infoButton.isMouseHere()) {
                infoButton.setIsActive(true);
            }


            for(int i = 0; i <= settings.numSSVEPs; i++){
                if (mouseX > ssvepCoords[i][0] && mouseY > ssvepCoords[i][1] && mouseX < ssvepCoords[i][2] && mouseY < ssvepCoords[i][3]){
                    ssvepOn[i] = !ssvepOn[i];
                }
            }
        }
        ssvepChanSelect.mousePressed(this.dropdownIsActive);
    }

    public void mouseReleased() {
        super.mouseReleased(); //calls the parent mouseReleased() method of Widget (DON'T REMOVE)

        if (infoButton.isActive && infoButton.isMouseHere()) {
            showAbout = !showAbout;
        }
        infoButton.setIsActive(false);
    }

    public void createDropdown(String name, List<String> _items) {
        int _dropdownHeight = (dropdownOptions.size() + 1) * (navH - 2);
        cp5_ssvep.addScrollableList(name)
            .setOpen(false)
            .setColorBackground(color(0)) // text field bg color
            .setColorValueLabel(color(130))       // text color
            .setColorCaptionLabel(color(130))
            .setColorForeground(color(60))    // border color when not selected
            .setColorActive(color(150, 170, 200))       // border color when selected
            .setSize(dropdownWidth_freq, _dropdownHeight)
            .addItems(_items)
            .setVisible(false)
            .setBarHeight(20)
            .setItemHeight(20)
            ;

        cp5_ssvep.getController(name)
            .getCaptionLabel()
            .toUpperCase(false)
            .setFont(h4)
            .setSize(14)
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(3) //4-pixel vertical offset to center text
            ;

        cp5_ssvep.getController(name)
            .getValueLabel()
            .toUpperCase(false)
            .setFont(h4)
            .setSize(12)
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(3) //4-pixel vertical offset to center text
            ;
    }

    public void createStartButton(int wFactor, int hFactor, int ssvepNo) {
        int d;
        if (settings.numSSVEPs != 3) {
            d = h/4;
        } else {
            d = h/6;
        }
    }

    public void activateDefaultChannels() {
        //Activate default channels
        numActiveChannels = 2;
        int firstChan;
        int secondChan;
        if (nchan == 4) {
            firstChan = 2;
            secondChan = 3;
        } else {
            firstChan = 6;
            secondChan = 7;
        }
        ssvepChanSelect.checkList.activate(firstChan);
        ssvepChanSelect.checkList.activate(secondChan);
        ssvepChanSelect.activeChan.add(firstChan);
        ssvepChanSelect.activeChan.add(secondChan);
    }

    public void setFreqDropdownSizes() {
        //int dropdownsItemsToShow = int((h0 * widgetDropdownScaling) / (navH - 4));
        int _dropdownHeight = (dropdownOptions.size() + 1) * (navH - 2);
        for(int i = 0; i <= settings.numSSVEPs; i++){
            cp5_ssvep.getController(dropdownNames[i])
                    .setSize(dropdownWidth_freq, _dropdownHeight);
                    ;
        }
    }

    public void drawSSVEP(String colour, int freq, float wFactor, float hFactor, float hOffset, float size) {
        boolean whiteBG = false;
        if (colour.equals("blue")){
            whiteBG = true;
        }

        int r = 0;
        int g = 0;
        int b = 0;

        int ind = 0;

        if (colour.equals("blue")){
            b = 255;
        } else if (colour.equals("red")) {
            r = 255;
            ind = 1;
        } else if (colour.equals("green")) {
            g = 255;
            ind = 2;
        } else if (colour.equals("yellow")) {
            r = 255;
            g = 255;
            ind = 3;
        }

       if (freq == 0 || !ssvepOn[ind] || millis()%(2*(500/freq)) >= (500/freq)) {
            fill(r,g,b);
            rect(x + (w * wFactor) - (size/2), y + (h*hFactor) + hOffset - (size/2), size, size);
            pushStyle();
            noFill();
            if (whiteBG) {
               stroke(255);
            } else {
               stroke(0);
            }
            rect(x + (w * wFactor) - (size/4), y + (h*hFactor) + hOffset - (size/4), size/2, size/2);
            popStyle();
        } else {
            fill(0);
            rect(x + (w * wFactor) - (size/2), y + (h*hFactor) + hOffset - (size/2), size, size);
            pushStyle();
            noFill();
            stroke(r,g,b);
            rect(x + (w * wFactor) - (size/10), y + (h*hFactor) + hOffset - (size/10), size/5, size/5);
            popStyle();
        }

        //---------- Store Coords
        ssvepCoords[ind][0] = x + w * wFactor - size/2;
        ssvepCoords[ind][1] = y + h * hFactor - size/2;
        ssvepCoords[ind][2] = x + w * wFactor + size/2;
        ssvepCoords[ind][3] = y + h * hFactor + size/2;

    }

   //------set position of all dropdowns
   public void setDropdownPositions() {
        resetDropdowns();

        int _wOffset = -dropdownWidth_freq/2;

        if (settings.numSSVEPs == 0) {
            //(int dropdownNo, float wFactor, float wOffset, float hFactor, float hOffset)
            setDropdown(1, 0.5f, - s/8, 0, 30.0f);
        } else if (settings.numSSVEPs == 1) {
            if (heightLarger) {
                setDropdown(1, 0, 10.0f, 0.25f, -s/8);
                setDropdown(2, 0, 10.0f, 0.75f, -s/8);
            } else {
                setDropdown(1, 0.2f, _wOffset, 0, 30.0f);
                setDropdown(2, 0.7f, _wOffset, 0, 30.0f);
            }
        } else if (settings.numSSVEPs == 2) {
            if (heightLarger) {
                setDropdown(1, 0, 10.0f, 0, 30.0f);
                setDropdown(2, 0, 10.0f, 1.0f/3, 30.0f);
                setDropdown(3, 0, 10.0f, 2.0f/3, 30.0f);
            } else {
                //Freq1 Dropdown
                setDropdown(1, 0.125f, _wOffset, 0, 30.0f);
                setDropdown(2, 0.5f, _wOffset, 0, 30.0f);
                setDropdown(3, 0.875f, _wOffset, 0, 30.0f);
            }
        } else if (settings.numSSVEPs == 3) {
            setDropdown(1, 0, 10.0f, 0, navH + 4);
            setDropdown(2, 1.0f, (-1.0f/6) - 130f, 0, navH + 4);
            setDropdown(3, 0, 10.0f, 0.55f, 0);
            setDropdown(4, 1.0f, (-1.0f/6) - 130f, 0.55f, 0);
        }
   }

    //------- set the Position of an individual dropdown
    public void setDropdown(int dropdownNo, float wFactor, float wOffset, float hFactor, float hOffset){
        cp5_ssvep.getController("Frequency_"+dropdownNo).setPosition(x + (w * wFactor) + wOffset, y + (h * hFactor) + hOffset);
        cp5_ssvep.get(ScrollableList.class, "Frequency_"+dropdownNo).setVisible(true);
    }

    public void resetDropdowns() {
        cp5_ssvep.get(ScrollableList.class, "Frequency_1").setVisible(false);
        cp5_ssvep.get(ScrollableList.class, "Frequency_2").setVisible(false);
        cp5_ssvep.get(ScrollableList.class, "Frequency_3").setVisible(false);
        cp5_ssvep.get(ScrollableList.class, "Frequency_4").setVisible(false);
    }

    public void openCloseDropdowns() {
        for(int i = 1; i <= settings.numSSVEPs + 1; i++){
            if (cp5_ssvep.get(ScrollableList.class, "Frequency_"+i).isOpen()) {
                if (!cp5_ssvep.get(ScrollableList.class, "Frequency_"+i).isMouseOver()) {
                    cp5_ssvep.get(ScrollableList.class, "Frequency_"+i).close();
                }
            } else {
                if (cp5_ssvep.get(ScrollableList.class, "Frequency_"+i).isMouseOver()) {
                    cp5_ssvep.get(ScrollableList.class, "Frequency_"+i).open();
                }
            }
        }
    }

    public void closeAllDropdowns() {
        freqDropdownsShouldBeClosed = true;
        this.cp5_ssvep.get(ScrollableList.class, "Frequency_1").close();
        this.cp5_ssvep.get(ScrollableList.class, "Frequency_2").close();
        this.cp5_ssvep.get(ScrollableList.class, "Frequency_3").close();
        this.cp5_ssvep.get(ScrollableList.class, "Frequency_4").close();
    }

    public void lockUnlockControllersAsNeeded() {
        //If neither widget selection or #SSVEPs dropdown is active...
        if (!dropdownIsActive) {
            //Unlock all Frequency dropdowns and proceed to check for other cases
            cp5_ssvep.get(ScrollableList.class, "Frequency_1").unlock();
            cp5_ssvep.get(ScrollableList.class, "Frequency_2").unlock();
            cp5_ssvep.get(ScrollableList.class, "Frequency_3").unlock();
            cp5_ssvep.get(ScrollableList.class, "Frequency_4").unlock();
            //Check for state change in topNav objects
            if ((topNav.configSelector.isVisible != configIsVisible) || (topNav.layoutSelector.isVisible != layoutIsVisible)) {
                //Lock/unlock the controllers within networking widget when using TopNav Objects
                if (topNav.configSelector.isVisible || topNav.layoutSelector.isVisible) {
                    cp5_ssvep.get(ScrollableList.class, "Frequency_1").lock();
                    cp5_ssvep.get(ScrollableList.class, "Frequency_2").lock();
                    cp5_ssvep.get(ScrollableList.class, "Frequency_3").lock();
                    cp5_ssvep.get(ScrollableList.class, "Frequency_4").lock();

                } else {
                    cp5_ssvep.get(ScrollableList.class, "Frequency_1").unlock();
                    cp5_ssvep.get(ScrollableList.class, "Frequency_2").unlock();
                    cp5_ssvep.get(ScrollableList.class, "Frequency_3").unlock();
                    cp5_ssvep.get(ScrollableList.class, "Frequency_4").unlock();
                }

                //lock/unlock dropdowns when Widget Selector is in use
                if (cp5_widget.get(ScrollableList.class, "WidgetSelector").isOpen()) {
                    cp5_ssvep.get(ScrollableList.class, "Frequency_1").lock();
                } else {
                    cp5_ssvep.get(ScrollableList.class, "Frequency_1").unlock();
                }

                //lock/unlock lower Freq4 dropdown when Freq2 dropdown is in use in 4 SSVEP use case
                if (cp5_ssvep.get(ScrollableList.class, "Frequency_2").isOpen()) {
                    cp5_ssvep.getController("Frequency_2").bringToFront();
                    cp5_ssvep.get(ScrollableList.class, "Frequency_4").lock();
                } else {
                    cp5_ssvep.get(ScrollableList.class, "Frequency_4").setVisible(true).unlock();
                }

                //lock/unlock lower Freq3 dropdown when Freq1 dropdown is in use in 4 SSVEP use case
                if (cp5_ssvep.get(ScrollableList.class, "Frequency_1").isOpen() && settings.numSSVEPs == 3) {
                    cp5_ssvep.getController("Frequency_1").bringToFront();
                    cp5_ssvep.get(ScrollableList.class, "Frequency_3").lock();

                } else {
                    cp5_ssvep.get(ScrollableList.class, "Frequency_3").unlock();
                }

                //manage dropdowns in 3 SSVEP use case
                if (heightLarger && settings.numSSVEPs == 2) {
                    // lock freq2 if freq1 is in use
                    if (cp5_ssvep.get(ScrollableList.class, "Frequency_1").isOpen()){
                        cp5_ssvep.get(ScrollableList.class, "Frequency_2").bringToFront();
                        cp5_ssvep.get(ScrollableList.class, "Frequency_2").lock();
                    } else {
                        cp5_ssvep.get(ScrollableList.class, "Frequency_2").unlock();
                    }

                    // lock freq3 if freq2 is in use
                    if (cp5_ssvep.get(ScrollableList.class, "Frequency_2").isOpen()){
                        cp5_ssvep.get(ScrollableList.class, "Frequency_3").lock();
                        cp5_ssvep.getController("Frequency_2").bringToFront();
                    } else {
                        cp5_ssvep.get(ScrollableList.class, "Frequency_3").unlock();
                    }
                }

                configIsVisible = topNav.configSelector.isVisible;
                layoutIsVisible = topNav.layoutSelector.isVisible;
            } //end topNav state change check
        } else {
            //If using the widget selector or #SSVEPs dropdowns, lock frequency dropdowns
            cp5_ssvep.get(ScrollableList.class, "Frequency_1").lock();
            cp5_ssvep.get(ScrollableList.class, "Frequency_2").lock();
            cp5_ssvep.get(ScrollableList.class, "Frequency_3").lock();
            cp5_ssvep.get(ScrollableList.class, "Frequency_4").lock();
        }
    }

    public int updateFreq(int controllerNum) {
        String label = cp5_ssvep.get(ScrollableList.class, "Frequency_"+controllerNum).getLabel();
        if (!label.equals("Frequency_"+controllerNum)) {
            String[] s = split(label, " ");
            return Integer.valueOf(s[0]);
        }
        return -1;
    }

    public float[] processData() {
        int activeSSVEPs = settings.numSSVEPs + 1;
        //println("NUM SSVEPs = " + activeSSVEPs);

        float[] peakData = new float[4];     //uV at the selected SSVEP freqencies
        float[] backgroundData = new float[4];   //uV at all other frequencies
        float[] finalData = new float[4];    //ratio between peak and background

        for (int i = 0; i < activeSSVEPs; i++) {
            if (freqs[i] > 0) {
                //calculate peak uV
                float sum = 0;
                for (int j = 0; j < ssvepChanSelect.activeChan.size(); j++) {
                    int chan = ssvepChanSelect.activeChan.get(j);
                    sum += fftBuff[chan].getFreq(freqs[i]);
                }
                float avg = sum/numActiveChannels;
                peakData[i] = avg;
                //println("PEAK DATA: " + peakData[i]);

                //calculate background uV in all channels but the given channel
                sum = 0;
                for (int f = 7; f <= 15; f++) {         //where f represents any of the frequencies selectable
                    if (f <  freqs[i] || f > freqs[i]) {
                        int freqSum = 0;
                        for (int j = 0; j < ssvepChanSelect.activeChan.size(); j++) {
                            int chan = ssvepChanSelect.activeChan.get(j);
                            freqSum += fftBuff[chan].getFreq(f);
                        }
                        sum += freqSum/8;
                    }
                }
                backgroundData[i] = sum;
                //println("BACKGROUND DATA: " + backgroundData[i]);
                if (backgroundData[i] != 0) {
                    finalData[i] = peakData[i]/backgroundData[i];
                } else {
                    finalData[i] = peakData[i];
                }
            } else {
                finalData[i] = 0;
            }
        }
        //println(finalData);
        return finalData;
    } //end of processData

    /*
    
    ///Here is another algorithm from older code that finds peak frequencies...

    void findPeakFrequency(FFT[] fftData, int Ichan) {

        //loop over each EEG channel and find the frequency with the peak amplitude
        float FFT_freq_Hz, FFT_value_uV;
        //for (int Ichan=0;Ichan < nchan; Ichan++) {

        //clear the data structure that will hold the peak for this channel
        detectedPeak[Ichan].clear();

        //loop over each frequency bin to find the one with the strongest peak
        int nBins =  fftData[Ichan].specSize();
        for (int Ibin=0; Ibin < nBins; Ibin++) {
        FFT_freq_Hz = fftData[Ichan].indexToFreq(Ibin); //here is the frequency of htis bin

            //is this bin within the frequency band of interest?
        if ((FFT_freq_Hz >= min_allowed_peak_freq_Hz) && (FFT_freq_Hz <= max_allowed_peak_freq_Hz)) {
            //we are within the frequency band of interest

            //get the RMS voltage (per bin)
            FFT_value_uV = fftData[Ichan].getBand(Ibin) / ((float)nBins); 
            //FFT_value_uV = fftData[Ichan].getBand(Ibin);

            //decide if this is the maximum, compared to previous bins for this channel
            if (FFT_value_uV > detectedPeak[Ichan].rms_uV_perBin) {
            //this is bigger, so hold onto this value as the new "maximum"
            detectedPeak[Ichan].bin  = Ibin;
            detectedPeak[Ichan].freq_Hz = FFT_freq_Hz;
            detectedPeak[Ichan].rms_uV_perBin = FFT_value_uV;
            }
        } //close if within frequency band
        } //close loop over bins

        //loop over the bins again (within the sense band) to get the average background power, excluding the bins on either side of the peak
        float sum_pow=0;
        int count=0;
        for (int Ibin=0; Ibin < nBins; Ibin++) {
        FFT_freq_Hz = fftData[Ichan].indexToFreq(Ibin);
        if ((FFT_freq_Hz >= min_allowed_peak_freq_Hz) && (FFT_freq_Hz <= max_allowed_peak_freq_Hz)) {
            if ((Ibin < detectedPeak[Ichan].bin - 1) || (Ibin > detectedPeak[Ichan].bin + 1)) {
            FFT_value_uV = fftData[Ichan].getBand(Ibin) / ((float)nBins);  //get the RMS per bin
            sum_pow+=pow(FFT_value_uV, 2.0);
            count++;
            }
        }
        }
        //compute mean
        detectedPeak[Ichan].background_rms_uV_perBin = sqrt(sum_pow / count);

        //decide if peak is big enough to be detected
        detectedPeak[Ichan].SNR_dB = 20.0*(float)java.lang.Math.log10(detectedPeak[Ichan].rms_uV_perBin / detectedPeak[Ichan].background_rms_uV_perBin);

        //kludge
        //if ((detectedPeak[Ichan].freq_Hz >= processing_band_low_Hz[0]) && (detectedPeak[Ichan].freq_Hz <= processing_band_high_Hz[0])) {
        //  if (detectedPeak[Ichan].SNR_dB >= detection_thresh_dB-2.0) {
        //    detectedPeak[Ichan].threshold_dB = detection_thresh_dB;
        //    detectedPeak[Ichan].isDetected = true;
        //  }
        //} else {
        //  if (detectedPeak[Ichan].SNR_dB >= detection_thresh_dB) {
        //    detectedPeak[Ichan].threshold_dB = detection_thresh_dB;
        //    detectedPeak[Ichan].isDetected = true;
        //  }
        //}

        //} // end loop over channels
    } //end method findPeakFrequency
    */

} //end of ssvep class

//Corresponds to the number of SSVEPs dropdown menu at the top right of the SSVEP widget
public void NumberSSVEP(int n) {
    settings.numSSVEPs = n;
    closeAllDropdowns(); // do this at the end of all widget-activated functions to ensure proper widget interactivity ... we want to make sure a click makes the menu close
}

///The following functions correspond to the ScrollableLists of the same name in the SSVEP widget
public void Frequency_1(int n) {
    w_ssvep.closeAllDropdowns();
}

public void Frequency_2(int n) {
    w_ssvep.closeAllDropdowns();
}

public void Frequency_3(int n) {
    w_ssvep.closeAllDropdowns();
}

public void Frequency_4(int n) {
    w_ssvep.closeAllDropdowns();
}


////////////////////////////////////////////////////
//
//    W_template.pde (ie "Widget Template")
//
//    This is a Template Widget, intended to be used as a starting point for OpenBCI Community members that want to develop their own custom widgets!
//    Good luck! If you embark on this journey, please let us know. Your contributions are valuable to everyone!
//
//    Created by: Conor Russomanno, November 2016
//
///////////////////////////////////////////////////,

class W_template extends Widget {

    //to see all core variables/methods of the Widget class, refer to Widget.pde
    //put your custom variables here...
    Button widgetTemplateButton;

    W_template(PApplet _parent){
        super(_parent); //calls the parent CONSTRUCTOR method of Widget (DON'T REMOVE)

        //This is the protocol for setting up dropdowns.
        //Note that these 3 dropdowns correspond to the 3 global functions below
        //You just need to make sure the "id" (the 1st String) has the same name as the corresponding function
        addDropdown("Dropdown1", "Drop 1", Arrays.asList("A", "B"), 0);
        addDropdown("Dropdown2", "Drop 2", Arrays.asList("C", "D", "E"), 1);
        addDropdown("Dropdown3", "Drop 3", Arrays.asList("F", "G", "H", "I"), 3);

        widgetTemplateButton = new Button (x + w/2, y + h/2, 200, navHeight, "Design Your Own Widget!", 12);
        widgetTemplateButton.setFont(p4, 14);
        widgetTemplateButton.setURL("https://openbci.github.io/Documentation/docs/06Software/01-OpenBCISoftware/GUIWidgets#custom-widget");
    }

    public void update(){
        super.update(); //calls the parent update() method of Widget (DON'T REMOVE)

        //put your code here...
        //If using a TopNav object, ignore interaction with widget object (ex. widgetTemplateButton)
        if (topNav.configSelector.isVisible || topNav.layoutSelector.isVisible) {
            widgetTemplateButton.setIsActive(false);
            widgetTemplateButton.setIgnoreHover(true);
        } else {
            widgetTemplateButton.setIgnoreHover(false);
        }

    }

    public void draw(){
        super.draw(); //calls the parent draw() method of Widget (DON'T REMOVE)

        //put your code here... //remember to refer to x,y,w,h which are the positioning variables of the Widget class
        pushStyle();

        widgetTemplateButton.draw();

        popStyle();

    }

    public void screenResized(){
        super.screenResized(); //calls the parent screenResized() method of Widget (DON'T REMOVE)

        //put your code here...
        widgetTemplateButton.setPos(x + w/2 - widgetTemplateButton.but_dx/2, y + h/2 - widgetTemplateButton.but_dy/2);


    }

    public void mousePressed(){
        super.mousePressed(); //calls the parent mousePressed() method of Widget (DON'T REMOVE)

        //put your code here...
        //If using a TopNav object, ignore interaction with widget object (ex. widgetTemplateButton)
        if (!topNav.configSelector.isVisible && !topNav.layoutSelector.isVisible) {
            if(widgetTemplateButton.isMouseHere()){
                widgetTemplateButton.setIsActive(true);
            }
        }
    }

    public void mouseReleased(){
        super.mouseReleased(); //calls the parent mouseReleased() method of Widget (DON'T REMOVE)

        //put your code here...
        if(widgetTemplateButton.isActive && widgetTemplateButton.isMouseHere()){
            widgetTemplateButton.goToURL();
        }
        widgetTemplateButton.setIsActive(false);

    }

    //add custom functions here
    public void customFunction(){
        //this is a fake function... replace it with something relevant to this widget

    }

};

//These functions need to be global! These functions are activated when an item from the corresponding dropdown is selected
public void Dropdown1(int n){
    println("Item " + (n+1) + " selected from Dropdown 1");
    if(n==0){
        //do this
    } else if(n==1){
        //do this instead
    }

    closeAllDropdowns(); // do this at the end of all widget-activated functions to ensure proper widget interactivity ... we want to make sure a click makes the menu close
}

public void Dropdown2(int n){
    println("Item " + (n+1) + " selected from Dropdown 2");
    closeAllDropdowns();
}

public void Dropdown3(int n){
    println("Item " + (n+1) + " selected from Dropdown 3");
    closeAllDropdowns();
}
////////////////////////////////////////////////////
//
// This class creates a Time Series Plot separate from the old Gui_Manager
// It extends the Widget class
//
// Conor Russomanno, November 2016
//
// Requires the plotting library from grafica ... replacing the old gwoptics (which is now no longer supported)
//
///////////////////////////////////////////////////


class W_timeSeries extends Widget {

    //to see all core variables/methods of the Widget class, refer to Widget.pde
    //put your custom variables here...

    int numChannelBars;
    float xF, yF, wF, hF;
    float ts_padding;
    float ts_x, ts_y, ts_h, ts_w; //values for actual time series chart (rectangle encompassing all channelBars)
    float pb_x, pb_y, pb_h, pb_w; //values for playback sub-widget
    float plotBottomWell;
    float playbackWidgetHeight;
    int channelBarHeight;
    boolean showHardwareSettings = false;

    Button hardwareSettingsButton;

    ChannelBar[] channelBars;
    PlaybackScrollbar scrollbar;
    TimeDisplay timeDisplay;

    int[] xLimOptions = {1, 3, 5, 10, 20}; // number of seconds (x axis of graph)
    int[] yLimOptions = {0, 50, 100, 200, 400, 1000, 10000}; // 0 = Autoscale ... everything else is uV

    int xLim = xLimOptions[1];  //start at 5s
    int xMax = xLimOptions[0];  //start w/ autoscale

    boolean allowSpillover = false;

    HardwareSettingsController hsc;

    TextBox[] impValuesMontage;

    private boolean visible = true;
    private boolean updating = true;

    private boolean hasScrollbar = true; //used to turn playback scrollbar widget on/off
    boolean updateNumberOfChannelBars = false; //used if user selects new playback file using playback widget

    W_timeSeries(PApplet _parent) {
        super(_parent); //calls the parent CONSTRUCTOR method of Widget (DON'T REMOVE)

        xF = PApplet.parseFloat(x); //float(int( ... is a shortcut for rounding the float down... so that it doesn't creep into the 1px margin
        yF = PApplet.parseFloat(y);
        wF = PApplet.parseFloat(w);
        hF = PApplet.parseFloat(h);

        plotBottomWell = 45.0f; //this appears to be an arbitrary vertical space adds GPlot leaves at bottom, I derived it through trial and error
        ts_padding = 10.0f;
        ts_x = xF + ts_padding;
        ts_y = yF + (ts_padding);
        ts_w = wF - ts_padding*2;
        ts_h = hF - playbackWidgetHeight - plotBottomWell - (ts_padding*2);
        numChannelBars = nchan; //set number of channel bars = to current nchan of system (4, 8, or 16)

        //Time Series settings
        settings.tsVertScaleSave = 3;
        settings.tsHorizScaleSave = 2;

        //This is the protocol for setting up dropdowns.
        //Note that these 3 dropdowns correspond to the 3 global functions below
        //You just need to make sure the "id" (the 1st String) has the same name as the corresponding function

        addDropdown("VertScale_TS", "Vert Scale", Arrays.asList(settings.tsVertScaleArray), settings.tsVertScaleSave);
        addDropdown("Duration", "Window", Arrays.asList(settings.tsHorizScaleArray), settings.tsHorizScaleSave);
        // addDropdown("Spillover", "Spillover", Arrays.asList("False", "True"), 0);

        //Instantiate scrollbar if using playback mode and scrollbar feature in use
        if(eegDataSource == DATASOURCE_PLAYBACKFILE && hasScrollbar) {
            playbackWidgetHeight = 50.0f;
            pb_x = ts_x - ts_padding/2;
            pb_y = ts_y + ts_h + playbackWidgetHeight + (ts_padding * 3);
            pb_w = ts_w - ts_padding*4;
            pb_h = playbackWidgetHeight/2;
            //Make a new scrollbar
            scrollbar = new PlaybackScrollbar(PApplet.parseInt(pb_x), PApplet.parseInt(pb_y), PApplet.parseInt(pb_w), PApplet.parseInt(pb_h), indices);
        } else {
            int td_h = 18;
            timeDisplay = new TimeDisplay(PApplet.parseInt(ts_x), PApplet.parseInt(ts_y + hF - td_h), PApplet.parseInt(ts_w), td_h);
            playbackWidgetHeight = 0.0f;
        }

        channelBarHeight = PApplet.parseInt(ts_h/numChannelBars);

        channelBars = new ChannelBar[numChannelBars];

        //create our channel bars and populate our channelBars array!
        for(int i = 0; i < numChannelBars; i++) {
            int channelBarY = PApplet.parseInt(ts_y) + i*(channelBarHeight); //iterate through bar locations
            ChannelBar tempBar = new ChannelBar(_parent, i+1, PApplet.parseInt(ts_x), channelBarY, PApplet.parseInt(ts_w), channelBarHeight); //int _channelNumber, int _x, int _y, int _w, int _h
            channelBars[i] = tempBar;
        }

        if(eegDataSource == DATASOURCE_CYTON) {
            hardwareSettingsButton = new Button((int)(x + 3), (int)(y + navHeight + 3), 120, navHeight - 6, "Hardware Settings", 12);
            hardwareSettingsButton.setCornerRoundess((int)(navHeight-6));
            hardwareSettingsButton.setFont(p5,12);
            // hardwareSettingsButton.setStrokeColor((int)(color(150)));
            // hardwareSettingsButton.setColorNotPressed(openbciBlue);
            hardwareSettingsButton.setColorNotPressed(color(57,128,204));
            hardwareSettingsButton.textColorNotActive = color(255);
            // hardwareSettingsButton.setStrokeColor((int)(color(138, 182, 229, 100)));
            hardwareSettingsButton.hasStroke(false);
            // hardwareSettingsButton.setColorNotPressed((int)(color(138, 182, 229)));
            hardwareSettingsButton.setHelpText("The buttons in this panel allow you to adjust the hardware settings of the OpenBCI Board.");
        }

        int x_hsc = PApplet.parseInt(ts_x);
        int y_hsc = PApplet.parseInt(ts_y);
        int w_hsc = PApplet.parseInt(ts_w); //width of montage controls (on left of montage)
        int h_hsc = PApplet.parseInt(ts_h); //height of montage controls (on left of montage)
        hsc = new HardwareSettingsController((int)channelBars[0].plot.getPos()[0] + 2, (int)channelBars[0].plot.getPos()[1], (int)channelBars[0].plot.getOuterDim()[0], h_hsc - 4, channelBarHeight);
    }

    public boolean isVisible() {
        return visible;
    }
    public boolean isUpdating() {
        return updating;
    }

    public void setVisible(boolean _visible) {
        visible = _visible;
    }
    public void setUpdating(boolean _updating) {
        updating = _updating;
    }

    public void update() {
        if(visible && updating) {
            super.update(); //calls the parent update() method of Widget (DON'T REMOVE)

            hsc.update(); //update channel controller

            if(eegDataSource == DATASOURCE_PLAYBACKFILE && hasScrollbar) {
                //scrub playback file
                scrollbar.update();
            } else {
                timeDisplay.update();
            }
            
            if (eegDataSource == DATASOURCE_CYTON) {
                //ignore top left button interaction when widgetSelector dropdown is active
                ignoreButtonCheck(hardwareSettingsButton);
            }

            //update the number of channel bars if user has selected a new file using playback widget
            if (updateNumberOfChannelBars) {
                updateNumChannelBars(ourApplet);
            }
            //update channel bars ... this means feeding new EEG data into plots
            for(int i = 0; i < numChannelBars; i++) {
                channelBars[i].update();
            }
        }
    }

    public void draw() {
        if(visible) {
            super.draw(); //calls the parent draw() method of Widget (DON'T REMOVE)

            //remember to refer to x,y,w,h which are the positioning variables of the Widget class
            pushStyle();
            //draw channel bars
            for(int i = 0; i < numChannelBars; i++) {
                channelBars[i].draw();
            }

            if(eegDataSource == DATASOURCE_CYTON) {
                hardwareSettingsButton.draw();
            }

            //Display playback scrollbar or timeDisplay, depending on data source
            if (eegDataSource == DATASOURCE_PLAYBACKFILE && hasScrollbar) { //you will only ever see the playback widget in Playback Mode ... otherwise not visible
                fill(0,0,0,20);
                stroke(31,69,110);
                rect(xF, ts_y + ts_h + playbackWidgetHeight + 5, wF, playbackWidgetHeight);
                scrollbar.draw();
            } else {
                timeDisplay.draw();
            }

            //draw channel controller
            hsc.draw();

            popStyle();
        }
    }

    public void screenResized() {
        super.screenResized(); //calls the parent screenResized() method of Widget (DON'T REMOVE)

        xF = PApplet.parseFloat(x); //float(int( ... is a shortcut for rounding the float down... so that it doesn't creep into the 1px margin
        yF = PApplet.parseFloat(y);
        wF = PApplet.parseFloat(w);
        hF = PApplet.parseFloat(h);

        ts_x = xF + ts_padding;
        ts_y = yF + (ts_padding);
        ts_w = wF - ts_padding*2;
        ts_h = hF - playbackWidgetHeight - plotBottomWell - (ts_padding*2);
        channelBarHeight = PApplet.parseInt(ts_h/numChannelBars);

        for(int i = 0; i < numChannelBars; i++) {
            int channelBarY = PApplet.parseInt(ts_y) + i*(channelBarHeight); //iterate through bar locations
            channelBars[i].screenResized(PApplet.parseInt(ts_x), channelBarY, PApplet.parseInt(ts_w), channelBarHeight); //bar x, bar y, bar w, bar h
        }

        hsc.screenResized((int)channelBars[0].plot.getPos()[0] + 2, (int)channelBars[0].plot.getPos()[1], (int)channelBars[0].plot.getOuterDim()[0], (int)ts_h - 4, channelBarHeight);

        if (eegDataSource == DATASOURCE_CYTON) {
            hardwareSettingsButton.setPos((int)(x0 + 3), (int)(y0 + navHeight + 3));
        }
        
        ////Resize the playback slider if using playback mode, or resize timeDisplay div at the bottom of timeSeries
        if (eegDataSource == DATASOURCE_PLAYBACKFILE && hasScrollbar) {
            pb_x = ts_x - ts_padding/2;
            pb_y = ts_y + ts_h + playbackWidgetHeight + (ts_padding*3);
            pb_w = ts_w - ts_padding*4;
            pb_h = playbackWidgetHeight/2;
            scrollbar.screenResized(pb_x, pb_y, pb_w, pb_h);
        } else {
            int td_h = 18;
            timeDisplay.screenResized(PApplet.parseInt(ts_x), PApplet.parseInt(ts_y + hF - td_h), PApplet.parseInt(ts_w), td_h);
        }
    }

    public void mousePressed() {
        super.mousePressed(); //calls the parent mousePressed() method of Widget (DON'T REMOVE)

        if (!this.dropdownIsActive) {
            if(eegDataSource == DATASOURCE_CYTON) {
                if (hardwareSettingsButton.isMouseHere()) {
                    hardwareSettingsButton.setIsActive(true);
                }
            }
        }

        if(hsc.isVisible) {
            if (!this.dropdownIsActive) {
                hsc.mousePressed();
            }
        } else {
            for(int i = 0; i < channelBars.length; i++) {
                channelBars[i].mousePressed();
            }
        }

    }

    public void mouseReleased() {
        super.mouseReleased(); //calls the parent mouseReleased() method of Widget (DON'T REMOVE)

        if(eegDataSource == DATASOURCE_CYTON) {
            if(hardwareSettingsButton.isActive && hardwareSettingsButton.isMouseHere()) {
                println("HardwareSetingsButton: Toggle...");
                if(showHardwareSettings) {
                    showHardwareSettings = false;
                    hsc.isVisible = false;
                    hardwareSettingsButton.setString("Hardware Settings");
                } else{
                    showHardwareSettings = true;
                    hsc.isVisible = true;
                    hardwareSettingsButton.setString("Time Series");
                }
            }
            hardwareSettingsButton.setIsActive(false);
        }

        if(hsc.isVisible) {
            hsc.mouseReleased();
        } else {
            for(int i = 0; i < channelBars.length; i++) {
                channelBars[i].mouseReleased();
            }
        }
    }

    //Called when a user selects a new playback file from playback widget
    public void updateNumChannelBars(PApplet _parent) {
        //println("NEW NCHAN = " + nchan);
        numChannelBars = nchan;

        //Clear the array that holds the channel bars
        channelBars = null;

        //Create new channel bars
        channelBarHeight = PApplet.parseInt(ts_h/numChannelBars);

        channelBars = new ChannelBar[numChannelBars];

        //Create our channel bars and populate our channelBars array!
        for(int i = 0; i < numChannelBars; i++) {
            int channelBarY = PApplet.parseInt(ts_y) + i*(channelBarHeight); //iterate through bar locations
            ChannelBar tempBar = new ChannelBar(_parent, i+1, PApplet.parseInt(ts_x), channelBarY, PApplet.parseInt(ts_w), channelBarHeight); //int _channelNumber, int _x, int _y, int _w, int _h
            channelBars[i] = tempBar;
        }

        /*
        //this resizes all of the chanel bars
        channelBarHeight = int(ts_h/numChannelBars);

        for(int i = 0; i < numChannelBars; i++) {
            int channelBarY = int(ts_y) + i*(channelBarHeight); //iterate through bar locations
            channelBars[i].screenResized(int(ts_x), channelBarY, int(ts_w), channelBarHeight); //bar x, bar y, bar w, bar h
        }
        */

        updateNumberOfChannelBars = false;
    }
};

//These functions are activated when an item from the corresponding dropdown is selected
public void VertScale_TS(int n) {
    settings.tsVertScaleSave = n;
    for(int i = 0; i < w_timeSeries.numChannelBars; i++) {
        w_timeSeries.channelBars[i].adjustVertScale(w_timeSeries.yLimOptions[n]);
    }
    closeAllDropdowns();
}

//triggered when there is an event in the Duration Dropdown
public void Duration(int n) {
    settings.tsHorizScaleSave = n;
    // println("adjust duration to: " + xLimOptions[n]);
    //set time series x axis to the duration selected from dropdown
    int newDuration = w_timeSeries.xLimOptions[n];
    for(int i = 0; i < w_timeSeries.numChannelBars; i++) {
        w_timeSeries.channelBars[i].adjustTimeAxis(newDuration);
    }
    //If selected by user, sync the duration of Time Series, Accelerometer, and Analog Read(Cyton Only)
    if (settings.accHorizScaleSave == 0) {
        //set accelerometer x axis to the duration selected from dropdown
        w_accelerometer.accelerometerBar.adjustTimeAxis(newDuration);
    }
    if (cyton.getBoardMode() == BoardMode.ANALOG) {
        if (settings.arHorizScaleSave == 0) {
            //set analog read x axis to the duration selected from dropdown
            for(int i = 0; i < w_analogRead.numAnalogReadBars; i++) {
                w_analogRead.analogReadBars[i].adjustTimeAxis(newDuration);
            }
        }
    }
    closeAllDropdowns();
}

//triggered when there is an event in the LogLin Dropdown
public void Spillover(int n) {
    if (n==0) {
        w_timeSeries.allowSpillover = false;
    } else {
        w_timeSeries.allowSpillover = true;
    }
    closeAllDropdowns();
}


//========================================================================================================================
//                      CHANNEL BAR CLASS -- Implemented by Time Series Widget Class
//========================================================================================================================
//this class contains the plot and buttons for a single channel of the Time Series widget
//one of these will be created for each channel (4, 8, or 16)
class ChannelBar{

    int channelNumber; //duh
    String channelString;
    int x, y, w, h;
    boolean isOn; //true means data is streaming and channel is active on hardware ... this will send message to OpenBCI Hardware
    Button onOffButton;
    int onOff_diameter, impButton_diameter;
    Button impCheckButton;

    GPlot plot; //the actual grafica-based GPlot that will be rendering the Time Series trace
    GPointsArray channelPoints;
    int nPoints;
    int numSeconds;
    float timeBetweenPoints;

    int channelColor; //color of plot trace

    boolean isAutoscale; //when isAutoscale equals true, the y-axis of each channelBar will automatically update to scale to the largest visible amplitude
    int autoScaleYLim = 0;

    TextBox voltageValue;
    TextBox impValue;

    boolean drawVoltageValue;
    boolean drawImpValue;

    ChannelBar(PApplet _parent, int _channelNumber, int _x, int _y, int _w, int _h) { // channel number, x/y location, height, width

        channelNumber = _channelNumber;
        channelString = str(channelNumber);
        isOn = true;

        x = _x;
        y = _y;
        w = _w;
        h = _h;

        if(h > 26) {
            onOff_diameter = 26;
        } else{
            onOff_diameter = h - 2;
        }

        onOffButton = new Button (x + 6, y + PApplet.parseInt(h/2) - PApplet.parseInt(onOff_diameter/2), onOff_diameter, onOff_diameter, channelString, fontInfo.buttonLabel_size);
        onOffButton.setHelpText("Click to toggle channel " + channelNumber + ".");
        onOffButton.setFont(h2, 16);
        onOffButton.setCircleButton(true);
        onOffButton.setColorNotPressed(channelColors[(channelNumber-1)%8]); //Set channel button background colors
        onOffButton.textColorNotActive = color(255); //Set channel button text to white
        onOffButton.hasStroke(false);

        if(eegDataSource == DATASOURCE_CYTON) {
            impButton_diameter = 22;
            impCheckButton = new Button (x + 36, y + PApplet.parseInt(h/2) - PApplet.parseInt(impButton_diameter/2), impButton_diameter, impButton_diameter, "\u2126", fontInfo.buttonLabel_size);
            impCheckButton.setHelpText("Click to toggle impedance check for channel " + channelNumber + ".");
            impCheckButton.setFont(h3, 16); //override the default font and fontsize
            impCheckButton.setCircleButton(true);
            impCheckButton.setColorNotPressed(color(255)); //White background
            impCheckButton.textColorNotActive = color(0); //Black text
            impCheckButton.textColorActive = color(255); //White text when clicked
            impCheckButton.hasStroke(false);
        } else {
            impButton_diameter = 0;
        }
        numSeconds = 5;
        plot = new GPlot(_parent);
        plot.setPos(x + 36 + 4 + impButton_diameter, y);
        plot.setDim(w - 36 - 4 - impButton_diameter, h);
        plot.setMar(0f, 0f, 0f, 0f);
        plot.setLineColor((int)channelColors[(channelNumber-1)%8]);
        plot.setXLim(-5,0);
        plot.setYLim(-200,200);
        plot.setPointSize(2);
        plot.setPointColor(0);
        plot.setAllFontProperties("Arial", 0, 14);
        if(channelNumber == nchan) {
            plot.getXAxis().setAxisLabelText("Time (s)");
        }
        // plot.setBgColor(color(31,69,110));

        nPoints = nPointsBasedOnDataSource();

        channelPoints = new GPointsArray(nPoints);
        timeBetweenPoints = (float)numSeconds / (float)nPoints;

        for (int i = 0; i < nPoints; i++) {
            float time = -(float)numSeconds + (float)i*timeBetweenPoints;
            // float time = (-float(numSeconds))*(float(i)/float(nPoints));
            // float filt_uV_value = dataBuffY_filtY_uV[channelNumber-1][dataBuffY_filtY_uV.length-nPoints];
            float filt_uV_value = 0.0f; //0.0 for all points to start
            GPoint tempPoint = new GPoint(time, filt_uV_value);
            channelPoints.set(i, tempPoint);
        }

        plot.setPoints(channelPoints); //set the plot with 0.0 for all channelPoints to start

        voltageValue = new TextBox("", x + 36 + 4 + impButton_diameter + (w - 36 - 4 - impButton_diameter) - 2, y + h);
        voltageValue.textColor = color(bgColor);
        voltageValue.alignH = RIGHT;
        // voltageValue.alignV = TOP;
        voltageValue.drawBackground = true;
        voltageValue.backgroundColor = color(255,255,255,125);

        impValue = new TextBox("", x + 36 + 4 + impButton_diameter + 2, y + h);
        impValue.textColor = color(bgColor);
        impValue.alignH = LEFT;
        // impValue.alignV = TOP;
        impValue.drawBackground = true;
        impValue.backgroundColor = color(255,255,255,125);

        drawVoltageValue = true;
        drawImpValue = false;

    }

    public void update() {

        //update the voltage value text string
        String fmt; float val;

        //update the voltage values
        val = dataProcessing.data_std_uV[channelNumber-1];
        voltageValue.string = String.format(getFmt(val),val) + " uVrms";
        if (is_railed != null) {
            if (is_railed[channelNumber-1].is_railed == true) {
                voltageValue.string = "RAILED";
            } else if (is_railed[channelNumber-1].is_railed_warn == true) {
                voltageValue.string = "NEAR RAILED - " + String.format(getFmt(val),val) + " uVrms";
            }
        }

        //update the impedance values
        val = data_elec_imp_ohm[channelNumber-1]/1000;
        impValue.string = String.format(getFmt(val),val) + " kOhm";
        if (is_railed != null) {
            if (is_railed[channelNumber-1].is_railed == true) {
                impValue.string = "RAILED";
            }
        }

        // update data in plot
        updatePlotPoints();
        if(isAutoscale) {
            autoScale();
        }
    }

    private String getFmt(float val) {
        String fmt;
            if (val > 100.0f) {
                fmt = "%.0f";
            } else if (val > 10.0f) {
                fmt = "%.1f";
            } else {
                fmt = "%.2f";
            }
            return fmt;
    }

    public void updatePlotPoints() {
        // update data in plot
        if(dataBuffY_filtY_uV[channelNumber-1].length > nPoints) {
            for (int i = dataBuffY_filtY_uV[channelNumber-1].length - nPoints; i < dataBuffY_filtY_uV[channelNumber-1].length; i++) {
                float time = -(float)numSeconds + (float)(i-(dataBuffY_filtY_uV[channelNumber-1].length-nPoints))*timeBetweenPoints;
                float filt_uV_value = dataBuffY_filtY_uV[channelNumber-1][i];
                // float filt_uV_value = 0.0;
                GPoint tempPoint = new GPoint(time, filt_uV_value);
                channelPoints.set(i-(dataBuffY_filtY_uV[channelNumber-1].length-nPoints), tempPoint);
            }
            plot.setPoints(channelPoints); //reset the plot with updated channelPoints
        }
    }

    public void draw() {
        pushStyle();

        //draw channel holder background
        stroke(31,69,110, 50);
        fill(255);
        rect(x,y,w,h);

        //draw onOff Button
        onOffButton.draw();
        //draw impedance check Button
        if(eegDataSource == DATASOURCE_CYTON) {
            impCheckButton.draw();
        }

        //draw plot
        stroke(31,69,110, 50);
        fill(color(125,30,12,30));

        rect(x + 36 + 4 + impButton_diameter, y, w - 36 - 4 - impButton_diameter, h);

        plot.beginDraw();
        plot.drawBox(); // we won't draw this eventually ...
        plot.drawGridLines(0);
        plot.drawLines();
        // plot.drawPoints();
        // plot.drawYAxis();
        if(channelNumber == nchan) { //only draw the x axis label on the bottom channel bar
            plot.drawXAxis();
            plot.getXAxis().draw();
        }
        plot.endDraw();

        if(drawImpValue) {
            impValue.draw();
        }
        if(drawVoltageValue) {
            voltageValue.draw();
        }

        popStyle();
    }

    public void setDrawImp(boolean _trueFalse) {
        drawImpValue = _trueFalse;
    }

    public int nPointsBasedOnDataSource() {
        return numSeconds * (int)getSampleRateSafe();
    }

    public void adjustTimeAxis(int _newTimeSize) {
        numSeconds = _newTimeSize;
        plot.setXLim(-_newTimeSize,0);

        nPoints = nPointsBasedOnDataSource();
        channelPoints = new GPointsArray(nPoints);
        if(_newTimeSize > 1) {
            plot.getXAxis().setNTicks(_newTimeSize);  //sets the number of axis divisions...
        }else{
            plot.getXAxis().setNTicks(10);
        }
        if(w_timeSeries.isUpdating()) {
            updatePlotPoints();
        }
        // println("New X axis = " + _newTimeSize);
    }

    public void adjustVertScale(int _vertScaleValue) {
        if(_vertScaleValue == 0) {
            isAutoscale = true;
        } else {
            isAutoscale = false;
            plot.setYLim(-_vertScaleValue, _vertScaleValue);
        }
    }

    public void autoScale() {
        autoScaleYLim = 0;
        for(int i = 0; i < nPoints; i++) {
            if(PApplet.parseInt(abs(channelPoints.getY(i))) > autoScaleYLim) {
                autoScaleYLim = PApplet.parseInt(abs(channelPoints.getY(i)));
            }
        }
        plot.setYLim(-autoScaleYLim, autoScaleYLim);
    }

    public void screenResized(int _x, int _y, int _w, int _h) {
        x = _x;
        y = _y;
        w = _w;
        h = _h;

        if(h > 26) {
            onOff_diameter = 26;
            onOffButton.but_dx = onOff_diameter;
            onOffButton.but_dy = onOff_diameter;
        } else{
            // println("h = " + h);
            onOff_diameter = h - 2;
            onOffButton.but_dx = onOff_diameter;
            onOffButton.but_dy = onOff_diameter;
        }

        onOffButton.but_x = x + 6;
        onOffButton.but_y = y + PApplet.parseInt(h/2) - PApplet.parseInt(onOff_diameter/2);

        if(eegDataSource == DATASOURCE_CYTON) {
            impCheckButton.but_x = x + 36;
            impCheckButton.but_y = y + PApplet.parseInt(h/2) - PApplet.parseInt(impButton_diameter/2);
        }

        //reposition & resize the plot
        plot.setPos(x + 36 + 4 + impButton_diameter, y);
        plot.setDim(w - 36 - 4 - impButton_diameter, h);

        voltageValue.x = x + 36 + 4 + impButton_diameter + (w - 36 - 4 - impButton_diameter) - 2;
        voltageValue.y = y + h;
        impValue.x = x + 36 + 4 + impButton_diameter + 2;
        impValue.y = y + h;

    }

    public void mousePressed() {
        if(onOffButton.isMouseHere()) {
            println("[" + channelNumber + "] onOff pressed");
            onOffButton.setIsActive(true);
        }

        if(eegDataSource == DATASOURCE_CYTON) {
            if(impCheckButton.isMouseHere()) {
                println("[" + channelNumber + "] imp pressed");
                impCheckButton.setIsActive(true);
            }
        }

    }

    public void mouseReleased() {
        if(onOffButton.isMouseHere()) {
            println("[" + channelNumber + "] onOff released");
            if(isOn) {  // if channel is active
                isOn = false; // deactivate it
                deactivateChannel(channelNumber - 1); //got to - 1 to make 0 indexed
                onOffButton.setColorNotPressed(color(50));
            }
            else { // if channel is not active
                isOn = true;
                activateChannel(channelNumber - 1);       // activate it
                onOffButton.setColorNotPressed(channelColors[(channelNumber-1)%8]);
            }
        }

        onOffButton.setIsActive(false);

        if(eegDataSource == DATASOURCE_CYTON) {
            if(impCheckButton.isMouseHere() && impCheckButton.isActive()) {
                println("[" + channelNumber + "] imp released");
                w_timeSeries.hsc.toggleImpedanceCheck(channelNumber);  // 'n' indicates the N inputs and '1' indicates test impedance
                if(drawImpValue) {
                    drawImpValue = false;
                    impCheckButton.setColorNotPressed(color(255)); //White background
                    impCheckButton.textColorNotActive = color(0); //Black text
                } else {
                    drawImpValue = true;
                    impCheckButton.setColorNotPressed(color(50)); //Dark background
                    impCheckButton.textColorNotActive = color (255); //White text
                }
            }
            impCheckButton.setIsActive(false);
        }
    }
};

//========================================================================================================================
//                                          END OF -- CHANNEL BAR CLASS
//========================================================================================================================




//========================== PLAYBACKSLIDER ==========================
class PlaybackScrollbar {
    int swidth, sheight;    // width and height of bar
    float xpos, ypos;       // x and y position of bar
    float spos, newspos;    // x position of slider
    float sposMin, sposMax; // max and min values of slider
    boolean over;           // is the mouse over the slider?
    boolean locked;
    float ratio;
    int num_indices;
    int indexStartPosition = 0;
    int indexPosition = indexStartPosition;
    Button skipToStartButton;
    int skipToStart_diameter;
    Boolean indicatorAtStart; //true means the indicator is at index 0
    int clearBufferThreshold = 5;
    float ps_Padding = 50.0f; //used to make room for skip to start button
    String currentAbsoluteTimeToDisplay = "";
    String currentTimeInSecondsToDisplay = "";
    Boolean updatePosition = false;

    PlaybackScrollbar (float xp, float yp, int sw, int sh, int is) {
        swidth = sw;
        sheight = sh;
        //float widthtoheight = sw - sh;
        //ratio = (float)sw / widthtoheight;
        xpos = xp + ps_Padding; //lots of padding to make room for button
        ypos = yp-sheight/2;
        spos = xpos;
        newspos = spos;
        sposMin = xpos;
        sposMax = xpos + swidth - sheight/2;
        num_indices = is;
        indicatorAtStart = true;

        //Let's make a button to return to the start of playback!!
        skipToStart_diameter = 30;
        skipToStartButton = new Button (PApplet.parseInt(xp) + PApplet.parseInt(skipToStart_diameter*.5f), PApplet.parseInt(yp) + PApplet.parseInt(sh/2) - skipToStart_diameter, skipToStart_diameter, skipToStart_diameter, "");
        skipToStartButton.setColorNotPressed(color(235)); //Set channel button background colors
        skipToStartButton.hasStroke(false);
        PImage bgImage = loadImage("skipToStart-30x26.png");
        skipToStartButton.setBackgroundImage(bgImage);
    }

    /////////////// Update loop for PlaybackScrollbar
    public void update() {
        num_indices = indices;

        checkMouseOver(); // check if mouse is over

        if (mousePressed && over) {
            locked = true;
        }
        if (!mousePressed) {
            locked = false;
        }
        //if the slider is being used, update new position based on user mouseX
        if (locked) {
            newspos = constrain(mouseX-sheight/2, sposMin, sposMax);
            if (updatePosition) { //if the slider has been moved
                try {
                    clearAllTimeSeriesGPlots();
                    clearAllAccelGPlots();
                    playbackScrubbing(); //perform scrubbing
                } catch (Exception e) {
                    println("PlaybackScrollbar: Error: " + e);
                }
                updatePosition = false;
            }
        } else {
            //if the slider is not being used, let playback control it when (isRunning)
            if (isRunning) {
                //process the file
                if (systemMode == SYSTEMMODE_POSTINIT && !has_processed && !isOldData) {
                    lastReadDataPacketInd = 0;
                    pointCounter = 0;
                    try {
                        process_input_file();
                        ///println("TimeSeriesFileProcessed");
                    } catch(Exception e) {
                        isOldData = true;
                        output("###Error processing timestamps, are you using old data?");
                    }
                }
                //Set the new position of playback indicator using mapped value
                newspos = updatePos();
                updatePosition = false;
            }
        }
        if (abs(newspos - spos) > 1) { //if the slider has been moved
            spos = spos + (newspos-spos); //update position
            updatePosition = true;
        }
        if (getIndex() == 0) { //if the current index is 0, the indicator is at start
            indicatorAtStart = true;
        } else {
            indicatorAtStart = false;
        }

        if (mousePressed && skipToStartButton.isMouseHere() && !indicatorAtStart) {
            //println("Playback Scrollbar: Skip to start button pressed"); //This does not print!!
            skipToStartButton.setIsActive(true);
            skipToStartButtonAction(); //skip to start
            indicatorAtStart = true;
        } else if (!mousePressed && !skipToStartButton.isMouseHere()) {
            skipToStartButton.setIsActive(false); //set button to not active
        }

        //Catch error when trying to fetch current timestamp
        if (!isOldData) {
            try {
                if (curTimestamp.equals("-1") || (getCurrentTimeStamp() == null && getCurrentTimeStamp().isEmpty())) {
                    currentAbsoluteTimeToDisplay = "";
                } else {
                    if (!getCurrentTimeStamp().equals("notFound")) {
                        long t = new Long(getCurrentTimeStamp());
                        Date d =  new Date(t);
                        currentAbsoluteTimeToDisplay = new SimpleDateFormat("HH:mm:ss").format(d);
                    }
                }
            } catch (NullPointerException e) {
                println("TimeSeries: Timestamp error...");
                e.printStackTrace();
            }
        }

        //update elapsed time to display
        int numSecondsInFile = PApplet.parseInt(PApplet.parseFloat(playbackData_table.getRowCount())/getSampleRateSafe());
        currentTimeInSecondsToDisplay = getElapsedTimeInSeconds(currentTableRowIndex) + " of " + numSecondsInFile + " s";

    } //end update loop for PlaybackScrollbar

    public float constrain(float val, float minv, float maxv) {
        return min(max(val, minv), maxv);
    }

    //checks if mouse is over the playback scrollbar
    private void checkMouseOver() {
        if (mouseX > xpos && mouseX < xpos+swidth &&
            mouseY > ypos && mouseY < ypos+sheight) {
            if(!over) {
                onMouseEnter();
            }
        }
        else {
            if (over) {
                onMouseExit();
            }
        }
    }

    // called when the mouse enters the playback scrollbar
    private void onMouseEnter() {
        over = true;
        cursor(HAND); //changes cursor icon to a hand
    }

    private void onMouseExit() {
        over = false;
        cursor(ARROW);
    }

    public void draw() {
        pushStyle();

        //draw button to skip to the beginning of recording
        skipToStartButton.draw();

        //draw the playback slider inside the playback sub-widget
        noStroke();
        fill(204);
        rect(xpos, ypos, swidth, sheight);

        //select color for playback indicator
        if (over || locked) {
            fill(0, 0, 0);
        } else {
            fill(102, 102, 102);
        }
        //draws playback position indicator
        rect(spos, ypos, sheight/2, sheight);

        //draw current timestamp and X of Y Seconds above scrollbar
        if (!currentAbsoluteTimeToDisplay.equals(null)) {
            int fontSize = 17;
            textFont(p2, fontSize);
            fill(0);
            float tw = textWidth(currentAbsoluteTimeToDisplay);
            text(currentAbsoluteTimeToDisplay, xpos + swidth - tw, ypos - fontSize - 4);
            text(currentTimeInSecondsToDisplay, xpos, ypos - fontSize - 4);
        }

        popStyle();
    }

    public void screenResized(float _x, float _y, float _w, float _h) {
        swidth = PApplet.parseInt(_w);
        sheight = PApplet.parseInt(_h);
        xpos = _x + ps_Padding; //add lots of padding for use
        ypos = _y - sheight/2;
        sposMin = xpos;
        sposMax = xpos + swidth - sheight/2;
        //update the position of the playback indicator us
        newspos = updatePos();

        skipToStartButton.setPos(
            PApplet.parseInt(_x) + PApplet.parseInt(skipToStart_diameter*.5f),
            PApplet.parseInt(_y) - PApplet.parseInt(skipToStart_diameter*.5f)
            );

    }

    //Fetch index using playback indicator position
    public int getIndex() {
        //Divide the width (Max - Min) by the number of indices
        //Store this value for scrollbar step size as a float
        float scrollbarStepSize = (sposMax-sposMin) / num_indices;
        //println("sep val : " + scrollbarStepSize);
        int index_Position = PApplet.parseInt(getPos());
        int indexCounter;

        //Set index position by finding the playback indicator
        for (indexCounter = 0; indexCounter < num_indices + 1; indexCounter++) {
            if (spos == sposMin) { //Indicator is at the beginning
                indexPosition = 0;
                indicatorAtStart = true;
            }
            //If not at the beginning or the end, use step size from above
            if (index_Position > scrollbarStepSize * indexCounter && index_Position <= scrollbarStepSize * (indexCounter + 1)) {
                indexPosition = indexCounter;
                indicatorAtStart = false;
                //println(">= val: " + (scrollbarStepSize * indexCounter) + " || <= val: " + (scrollbarStepSize * (indexCounter +1)) );
            }
            if (spos == sposMax) { //Indicator is at the end
                indexPosition = num_indices;
                indicatorAtStart = false;
            }
        }

        return indexPosition;
    }

    //Get current position of the playback indicator
    public float getPos() {
        //Return the slider position and account for button space
        return spos - ps_Padding;
    }

    //Update the position of the playback indicator during playback
    public float updatePos() {
        //Fetch the counter and the max time in Seconds
        int secondCounter = PApplet.parseInt(PApplet.parseFloat(currentTableRowIndex)/getSampleRateSafe());
        int secondCounterMax = PApplet.parseInt(PApplet.parseFloat(playbackData_table.getRowCount())/getSampleRateSafe());
        //Map the values to playbackslider min and max
        float m = map(secondCounter, 0, secondCounterMax, sposMin, sposMax);
        //println("mapval_"+m);
        //Returns mapped value to set the new position of playback indicator
        return m;
    }

    ////////////////////////////////////////////////////////////////////////
    //                        PlaybackScrubbing                           //
    // Gets called when the playback slider position is moved by the user //
    // This function should scrub the file using the slider position      //
    public void playbackScrubbing() {
        num_indices = indices;
        //println("INDEXES: "+num_indices);
        if(has_processed) {
            //This updates Time Series playback position and the value at the top of the GUI in title bar
            currentTableRowIndex = getIndex();
            String newTimeStamp = index_of_times.get(currentTableRowIndex);
            if (currentTableRowIndex >= playbackData_table.getRowCount()) newTimeStamp = index_of_times.get(playbackData_table.getRowCount());
            //If system is stopped, success print detailed position to bottom of GUI
            if (!isRunning) {
                outputSuccess("New Position{ " + getPos() + "/" + sposMax
                + " Index: " + currentTableRowIndex
                + " } --- Time: " + newTimeStamp
                + " --- " + getElapsedTimeInSeconds(currentTableRowIndex)
                + " seconds" );
            }
        }
    }

    //Find times to display for playback position
    public String getCurrentTimeStamp() {
        //update the value for the number of indices
        num_indices = indices;
        //return current playback time
        if (index_of_times != null) { //Check if the hashmap is null to prevent exception
            if (index_of_times.get(0) != null) {
                if (currentTableRowIndex > playbackData_table.getRowCount()) {
                    return index_of_times.get(playbackData_table.getRowCount());
                } else {
                    return index_of_times.get(currentTableRowIndex);
                }
            } else {
                //This is a sanity check for null exception, and this would print on screen
                return "TimeNotFound";
            }
        } else {
            //Same here
            return "TimeNotFound";
        }
    }

    //This function scrubs to the beginning of the playback file
    //Useful to 'reset' the scrollbar before loading a new playback file
    public void skipToStartButtonAction() {
        if (!indicatorAtStart) { //if indicator is not at start
            newspos = sposMin; //move slider to min position
            indexPosition = 0; //set index position to 0
            currentTableRowIndex = 0; //set playback position to 0
            indicatorAtStart = true;

            clearAllTimeSeriesGPlots();
            clearAllAccelGPlots();

            if (!isRunning) { //if the system is not running
                //Success print detailed position to bottom of GUI
                outputSuccess("New Position{ " + getPos() + "/" + sposMax
                + " Index: " + getIndex()
                + " } --- Time: " +  getCurrentTimeStamp()
                + " --- " + getElapsedTimeInSeconds(currentTableRowIndex)
                + " seconds" );
            }
        }
    }// end skipToStartButtonAction
};//end PlaybackScrollbar class

//========================== TimeDisplay ==========================
class TimeDisplay {
    int swidth, sheight;    // width and height of bar
    float xpos, ypos;       // x and y position of bar
    String currentAbsoluteTimeToDisplay = "";
    String currentTimeInSecondsToDisplay = "";
    Boolean updatePosition = false;
    LocalTime time;
    long startTime;
    boolean prevIsRunning = false;

    TimeDisplay (float xp, float yp, int sw, int sh) {
        swidth = sw;
        sheight = sh;
        xpos = xp; //lots of padding to make room for button
        ypos = yp;
        currentAbsoluteTimeToDisplay = fetchCurrentTimeString();
    }

    /////////////// Update loop for TimeDisplay when data stream is running
    public void update() {
        if (isRunning) {
            //Fetch Local time
            try {
                currentAbsoluteTimeToDisplay = fetchCurrentTimeString();
            } catch (NullPointerException e) {
                println("TimeDisplay: Timestamp error...");
                e.printStackTrace();
            }
            //Reset second counter when data stream starts and stops
            if (prevIsRunning == false) {
                startTime = System.currentTimeMillis();
                prevIsRunning = true;
            }
            //Calculate elapsed time using current millis
            int secondsElapsed = PApplet.parseInt((System.currentTimeMillis() - startTime) / 1000F);
            currentTimeInSecondsToDisplay = secondsElapsed + " s";
        } else {
            prevIsRunning = false;
        }
    } //end update loop for TimeDisplay

    public void draw() {
        pushStyle();
        //draw current timestamp at the bottom of the Widget container
        if (!currentAbsoluteTimeToDisplay.equals(null)) {
            int fontSize = 17;
            textFont(p2, fontSize);
            fill(0);
            float tw = textWidth(currentAbsoluteTimeToDisplay);
            text(currentAbsoluteTimeToDisplay, xpos + swidth - tw, ypos);
            text(currentTimeInSecondsToDisplay, xpos + 10, ypos);
        }
        popStyle();
    }

    public void screenResized(float _x, float _y, float _w, float _h) {
        swidth = PApplet.parseInt(_w);
        sheight = PApplet.parseInt(_h);
        xpos = _x;
        ypos = _y;
    }

    public String fetchCurrentTimeString() {
        time = LocalTime.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("HH:mm:ss");
        return time.format(formatter);
    }
};//end TimeDisplay class

//Used in the above PlaybackScrollbar class
//Also used in OpenBCI_GUI in the app's title bar
public int getElapsedTimeInSeconds(int tableRowIndex) {
    int elapsedTime = PApplet.parseInt(PApplet.parseFloat(tableRowIndex)/getSampleRateSafe());
    return elapsedTime;
}

public void clearAllTimeSeriesGPlots() {
    dataBuffY_uV = new float[nchan][dataBuffX.length];
    dataBuffY_filtY_uV = new float[nchan][dataBuffX.length];
    for(int i = 0; i < w_timeSeries.numChannelBars; i++) {
        for(int j = 0; j < dataBuffY_filtY_uV[i].length; j++) {
            dataBuffY_uV[i][j] = 0.0f;
            dataBuffY_filtY_uV[i][j] = 0.0f;
        }
        w_timeSeries.channelBars[i].update();
    }
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//    Widget
//      the idea here is that the widget class takes care of all of the responsiveness/structural stuff in the bg so that it is very easy to create a new custom widget to add to the GUI
//      the "Widgets" will be able to be mapped to the various containers of the GUI
//      created by Conor Russomanno ... 11/17/2016
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


class Widget{

    PApplet pApplet;

    int x0, y0, w0, h0; //true x,y,w,h of container
    int x, y, w, h; //adjusted x,y,w,h of white space `blank rectangle` under the nav...

    int currentContainer; //this determines where the widget is located ... based on the x/y/w/h of the parent container

    boolean isActive = false;
    boolean dropdownsShouldBeClosed = false;
    boolean dropdownIsActive = false;
    boolean widgetSelectorIsActive = false;

    ArrayList<NavBarDropdown> dropdowns;
    ControlP5 cp5_widget;
    String widgetTitle = "No Title Set";
    //used to limit the size of the widget selector, forces a scroll bar to show and allows us to add even more widgets in the future
    private final float widgetDropdownScaling = .35f;

    //some variables for the dropdowns
    int navH = 22;
    int widgetSelectorWidth = 160;
    int dropdownWidth = 64;

    Widget(PApplet _parent){
        pApplet = _parent;
        cp5_widget = new ControlP5(pApplet);
        dropdowns = new ArrayList<NavBarDropdown>();
        //setup dropdown menus

        currentContainer = 5; //central container by default
        mapToCurrentContainer();

    }

    public void update(){
        updateDropdowns();
    }

    public void draw(){
        pushStyle();

        fill(255);
        rect(x,y-1,w,h+1); //draw white widget background

        //draw nav bars and button bars
        fill(150, 150, 150);
        rect(x0, y0, w0, navH); //top bar
        fill(200, 200, 200);
        rect(x0, y0+navH, w0, navH); //button bar

        // fill(255);
        // rect(x+2, y+2, navH-4, navH-4);
        // fill(bgColor, 100);
        // rect(x+4, y+4, (navH-10)/2, (navH-10)/2);
        // rect(x+4, y+((navH-10)/2)+5, (navH-10)/2, (navH-10)/2);
        // rect(x+((navH-10)/2)+5, y+4, (navH-10)/2, (navH-10)/2);
        // rect(x+((navH-10)/2)+5, y+((navH-10)/2)+5, (navH-10)/2, (navH-10 )/2);
        //
        // fill(bgColor);
        // textAlign(LEFT, CENTER);
        // textFont(h2);
        // textSize(16);
        // text(widgetTitle, x+navH+2, y+navH/2 - 2); //title of widget -- left

        // drawDropdowns(); //moved to WidgetManager, so that dropdowns draw on top of widget content

        popStyle();
    }

    public void addDropdown(String _id, String _title, List _items, int _defaultItem){
        NavBarDropdown dropdownToAdd = new NavBarDropdown(_id, _title, _items, _defaultItem);
        dropdowns.add(dropdownToAdd);
    }

    public void setupWidgetSelectorDropdown(ArrayList<String> _widgetOptions){
        cp5_widget.setAutoDraw(false); //this prevents the cp5 object from drawing automatically (if it is set to true it will be drawn last, on top of all other GUI stuff... not good)
        // cp5_widget.setFont(h2, 16);
        // cp5_widget.getCaptionLabel().toUpperCase(false);
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //      SETUP the widgetSelector dropdown
        //////////////////////////////////////////////////////////////////////////////////////////////////////

        cp5_widget.setColor(settings.dropdownColors);
        cp5_widget.addScrollableList("WidgetSelector")
            .setPosition(x0+2, y0+2) //upper left corner
            // .setFont(h2)
            .setOpen(false)
            .setColor(settings.dropdownColors)
            .setSize(widgetSelectorWidth, PApplet.parseInt(h0 * widgetDropdownScaling) )// + maxFreqList.size())
            //.setSize(widgetSelectorWidth, (NUM_WIDGETS_TO_SHOW+1)*(navH-4) )// + maxFreqList.size())
            // .setScrollSensitivity(0.0)
            .setBarHeight(navH-4) //height of top/primary bar
            .setItemHeight(navH-4) //height of all item/dropdown bars
            .addItems(_widgetOptions) // used to be .addItems(maxFreqList)
            ;
        cp5_widget.getController("WidgetSelector")
            .getCaptionLabel() //the caption label is the text object in the primary bar
            .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
            .setText(widgetTitle)
            .setFont(h4)
            .setSize(14)
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(4)
            ;
        cp5_widget.getController("WidgetSelector")
            .getValueLabel() //the value label is connected to the text objects in the dropdown item bars
            .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
            .setText(widgetTitle)
            .setFont(h5)
            .setSize(12) //set the font size of the item bars to 14pt
            .getStyle() //need to grab style before affecting the paddingTop
            .setPaddingTop(3) //4-pixel vertical offset to center text
            ;
    }

    public void setupNavDropdowns(){

        cp5_widget.setAutoDraw(false); //this prevents the cp5 object from drawing automatically (if it is set to true it will be drawn last, on top of all other GUI stuff... not good)
        // cp5_widget.setFont(h3, 12);

        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //      SETUP all NavBarDropdowns
        //////////////////////////////////////////////////////////////////////////////////////////////////////

        /*
        dropdownColors.setActive((int)color(150, 170, 200)); //bg color of box when pressed
        dropdownColors.setForeground((int)color(177, 184, 193)); //when hovering over any box (primary or dropdown)
        // dropdownColors.setForeground((int)color(125)); //when hovering over any box (primary or dropdown)
        dropdownColors.setBackground((int)color(255)); //bg color of boxes (including primary)
        dropdownColors.setCaptionLabel((int)color(1, 18, 41)); //color of text in primary box
        // dropdownColors.setValueLabel((int)color(1, 18, 41)); //color of text in all dropdown boxes
        dropdownColors.setValueLabel((int)color(100)); //color of text in all dropdown boxes
        */

        cp5_widget.setColor(settings.dropdownColors);
        // println("Setting up dropdowns...");
        for(int i = 0; i < dropdowns.size(); i++){
            int dropdownPos = dropdowns.size() - i;
            // println("dropdowns.get(i).id = " + dropdowns.get(i).id);
            cp5_widget.addScrollableList(dropdowns.get(i).id)
                .setPosition(x0+w0-(dropdownWidth*(dropdownPos))-(2*(dropdownPos)), y0 + navH + 2) //float right
                .setFont(h5)
                .setOpen(false)
                .setColor(settings.dropdownColors)
                .setSize(dropdownWidth, (dropdowns.get(i).items.size()+1)*(navH-4) )// + maxFreqList.size())
                .setBarHeight(navH-4)
                .setItemHeight(navH-4)
                .addItems(dropdowns.get(i).items) // used to be .addItems(maxFreqList)
                ;
            cp5_widget.getController(dropdowns.get(i).id)
                .getCaptionLabel()
                .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
                .setText(dropdowns.get(i).returnDefaultAsString())
                .setSize(12)
                .getStyle()
                .setPaddingTop(4)
                ;
            cp5_widget.getController(dropdowns.get(i).id)
                .getValueLabel() //the value label is connected to the text objects in the dropdown item bars
                .toUpperCase(false) //DO NOT AUTOSET TO UPPERCASE!!!
                .setText(widgetTitle)
                .setSize(12) //set the font size of the item bars to 14pt
                .getStyle() //need to grab style before affecting the paddingTop
                .setPaddingTop(3) //4-pixel vertical offset to center text
                ;
        }
    }
    public void updateDropdowns(){
        //if a dropdown is open and mouseX/mouseY is outside of dropdown, then close it
        // println("dropdowns.size() = " + dropdowns.size());
        dropdownIsActive = false;

        if(cp5_widget.get(ScrollableList.class, "WidgetSelector").isOpen()){
            dropdownIsActive = true;
            if(!cp5_widget.getController("WidgetSelector").isMouseOver()){
                cp5_widget.get(ScrollableList.class, "WidgetSelector").close();
            }
        }

        for(int i = 0; i < dropdowns.size(); i++){
            if(cp5_widget.get(ScrollableList.class, dropdowns.get(i).id).isOpen()){
                //println("++++++++Mouse is over " + dropdowns.get(i).id);
                dropdownIsActive = true;
                if(!cp5_widget.getController(dropdowns.get(i).id).isMouseOver()){
                    cp5_widget.get(ScrollableList.class, dropdowns.get(i).id).close();
                }
            }
        }

        //onHover ... open ... no need to click
        if(dropdownsShouldBeClosed){ //this if takes care of the scenario where you select the same widget that is active...
            dropdownsShouldBeClosed = false;
        } else{
            if(!cp5_widget.get(ScrollableList.class, "WidgetSelector").isOpen()){
                if(cp5_widget.getController("WidgetSelector").isMouseOver()){
                    cp5_widget.get(ScrollableList.class, "WidgetSelector").open();
                }
            }

            for(int i = 0; i < dropdowns.size(); i++){
                if(!cp5_widget.get(ScrollableList.class, dropdowns.get(i).id).isOpen()){
                    if(cp5_widget.getController(dropdowns.get(i).id).isMouseOver()){
                        cp5_widget.get(ScrollableList.class, dropdowns.get(i).id).open();
                    }
                }
            }
        }

        //make sure that the widgetSelector CaptionLabel always corresponds to its widget
        cp5_widget.getController("WidgetSelector")
            .getCaptionLabel()
            .setText(widgetTitle)
            ;

    }

    public void drawDropdowns(){

        //draw dropdown titles
        pushStyle();

        noStroke();
        textFont(h5);
        textSize(12);
        textAlign(CENTER, BOTTOM);
        fill(bgColor);
        for(int i = 0; i < dropdowns.size(); i++){
            int dropdownPos = dropdowns.size() - i;
            // text(dropdowns.get(i).title, x+w-(dropdownWidth*(dropdownPos+1))-(2*(dropdownPos+1))+dropdownWidth/2, y+(navH-2));
            text(dropdowns.get(i).title, x0+w0-(dropdownWidth*(dropdownPos))-(2*(dropdownPos+1))+dropdownWidth/2, y0+(navH-2));
        }

        //draw background/stroke of widgetSelector dropdown
        fill(150);
        rect(cp5_widget.getController("WidgetSelector").getPosition()[0]-1, cp5_widget.getController("WidgetSelector").getPosition()[1]-1, widgetSelectorWidth+2, cp5_widget.get(ScrollableList.class, "WidgetSelector").getHeight()+2);

        //draw backgrounds to dropdown scrollableLists ... unfortunately ControlP5 doesn't have this by default, so we have to hack it to make it look nice...
        fill(200);
        for(int i = 0; i < dropdowns.size(); i++){
            rect(cp5_widget.getController(dropdowns.get(i).id).getPosition()[0] - 1, cp5_widget.getController(dropdowns.get(i).id).getPosition()[1] - 1, dropdownWidth + 2, cp5_widget.get(ScrollableList.class, dropdowns.get(i).id).getHeight()+2);
        }

        textAlign(RIGHT, TOP);
        cp5_widget.draw(); //this draws all cp5 elements... in this case, the scrollable lists that populate our dropdowns<>

        popStyle();
    }



    public void mouseDragged(){

    }

    public void mousePressed(){

    }

    public void mouseReleased(){

    }

    public void screenResized(){
        mapToCurrentContainer();
    }

    public void setTitle(String _widgetTitle){
        widgetTitle = _widgetTitle;
    }

    public void setContainer(int _currentContainer){
        currentContainer = _currentContainer;
        mapToCurrentContainer();
        screenResized();

    }

    public void mapToCurrentContainer(){
        x0 = (int)container[currentContainer].x;
        y0 = (int)container[currentContainer].y;
        w0 = (int)container[currentContainer].w;
        h0 = (int)container[currentContainer].h;

        x = x0;
        y = y0 + navH*2;
        w = w0;
        h = h0 - navH*2;

        //This line resets the origin for all cp5 elements under "cp5_widget" when the screen is resized, otherwise there will be drawing errors
        cp5_widget.setGraphics(pApplet, 0, 0);

        int dropdownsItemsToShow = PApplet.parseInt((h0 * widgetDropdownScaling) / (navH - 4));
        //println("Widget " + widgetTitle +  " || show num dropdowns = " + dropdownsItemsToShow);
        int dropdownHeight = (dropdownsItemsToShow + 1) * (navH - 4);
        if (wm != null) {
            int maxDropdownHeight = (wm.widgetOptions.size() + 1) * (navH - 4);
            if (dropdownHeight > maxDropdownHeight) dropdownHeight = maxDropdownHeight;
        }


        try {
            cp5_widget.getController("WidgetSelector")
                .setPosition(x0+2, y0+2) //upper left corner
                ;
            cp5_widget.getController("WidgetSelector")
                .setSize(widgetSelectorWidth, dropdownHeight);
                ;
        }
        catch (Exception e) {
            // println(e.getMessage());
            // println("widgetOptions List not built yet..."); AJK 8/22/17 because this is annoyance
        }

        for(int i = 0; i < dropdowns.size(); i++){
            int dropdownPos = dropdowns.size() - i;
            cp5_widget.getController(dropdowns.get(i).id)
                //.setPosition(w-(dropdownWidth*dropdownPos)-(2*(dropdownPos+1)), navHeight+(y+2)) // float left
                .setPosition(x0+w0-(dropdownWidth*(dropdownPos))-(2*(dropdownPos)), navH +(y0+2)) //float right
                //.setSize(dropdownWidth, (maxFreqList.size()+1)*(navBarHeight-4))
                ;
        }
    }

    public boolean isMouseHere(){
        if(isActive){
            if(mouseX >= x0 && mouseX <= x0 + w0 && mouseY >= y0 && mouseY <= y0 + h0){
                println("Your cursor is in " + widgetTitle);
                return true;
            } else{
                return false;
            }
        } else {
            return false;
        }
    }

    public void ignoreButtonCheck(Button b) {
        //ignore top left button interaction when widgetSelector dropdown is active
        if (dropdownIsActive) {
            b.setIgnoreHover(true);
        } else {
            if (b.getIgnoreHover()) {
                b.setIgnoreHover(false);
            }
        }
    }
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//    NavBarDropdown is a single dropdown item in any instance of a Widget
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class NavBarDropdown{

    String id;
    String title;
    // String[] items;
    List<String> items;
    int defaultItem;

    NavBarDropdown(String _id, String _title, List _items, int _defaultItem){
        id = _id;
        title = _title;
        // int dropdownSize = _items.length;
        // items = new String[_items.length];
        items = _items;

        defaultItem = _defaultItem;
    }

    public void update(){

    }

    public void draw(){

    }

    public void screenResized(){

    }

    public void mousePressed(){

    }

    public void mouseReleased(){

    }

    public String returnDefaultAsString(){
        String _defaultItem = items.get(defaultItem);
        return _defaultItem;
    }

}

public void closeAllDropdowns(){
    //close all dropdowns
    for(int i = 0; i < wm.widgets.size(); i++){
        wm.widgets.get(i).dropdownsShouldBeClosed = true;
    }
}

public void WidgetSelector(int n){
    println("New widget [" + n + "] selected for container...");
    //find out if the widget you selected is already active
    boolean isSelectedWidgetActive = wm.widgets.get(n).isActive;

    //find out which widget & container you are currently in...
    int theContainer = -1;
    for(int i = 0; i < wm.widgets.size(); i++){
        if(wm.widgets.get(i).isMouseHere()){
            theContainer = wm.widgets.get(i).currentContainer; //keep track of current container (where mouse is...)
            if(isSelectedWidgetActive){ //if the selected widget was already active
                wm.widgets.get(i).setContainer(wm.widgets.get(n).currentContainer); //just switch the widget locations (ie swap containers)
            } else{
                wm.widgets.get(i).isActive = false;   //deactivate the current widget (if it is different than the one selected)
            }
        }
    }

    wm.widgets.get(n).isActive = true;//activate the new widget
    wm.widgets.get(n).setContainer(theContainer);//map it to the current container
    //set the text of the widgetSelector to the newly selected widget

    closeAllDropdowns();
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//    ChannelSelect is currently used by BandPower and SSVEP Widgets         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

class ChannelSelect {

    //----------CHANNEL SELECT INFRASTRUCTURE
    private int x, y, w, navH;
    private float tri_xpos = 0;
    private float chanSelectXPos = 0;
    public ControlP5 cp5_channelCheckboxes;   //ControlP5 to contain our checkboxes
    public CheckBox checkList;
    private int offset;  //offset on nav bar of checkboxes
    private boolean channelSelectHover;
    private boolean channelSelectPressed;
    public List<Integer> activeChan;
    public String chanDropdownName;

    ChannelSelect(PApplet _parent, int _x, int _y, int _w, int _navH, String checkBoxName) {
        x = _x;
        y = _y;
        w = _w;
        navH = _navH;
        activeChan = new ArrayList<Integer>();
        chanDropdownName = checkBoxName;

        //setup for checkboxes
        cp5_channelCheckboxes = new ControlP5(_parent);

        createCheckList(nchan);
    }

    public void update(int _x, int _y, int _w) {
        //update the x,y,w for this class using the parent class
        x = _x;
        y = _y;
        w = _w;
        //Toggle open/closed the channel menu
        if (mouseX > (chanSelectXPos) && mouseX < (tri_xpos + 10) && mouseY < (y - navH*0.25f) && mouseY > (y - navH*0.65f)) {
            channelSelectHover = true;
        } else {
            channelSelectHover = false;
        }
        //Update the active channels to include in data processing
        activeChan.clear();
        for (int i = 0; i < nchan; i++) {
            if(checkList.getState(i)){
                activeChan.add(i);
            }
        }
        cp5_channelCheckboxes.get(CheckBox.class, chanDropdownName).setPosition(x + 2, y + offset);
    }

    public void draw() {

        //change "Channels" text color and triangle color on hover
        if (channelSelectHover) {
            fill(openbciBlue);
        } else {
            fill(0);
        }
        textFont(p5, 12);
        chanSelectXPos = x + 2;
        text("Channels", chanSelectXPos, y - 6);
        tri_xpos = x + textWidth("Channels") + 7;

        //draw triangle as pointing up or down, depending on if channel Select is active or closed
        if (!channelSelectPressed) {
            triangle(tri_xpos, y - navH*0.65f, tri_xpos + 5, y - navH*0.25f, tri_xpos + 10, y - navH*0.65f);
        } else {
            triangle(tri_xpos, y - navH*0.25f, tri_xpos + 5, y - navH*0.65f, tri_xpos + 10, y - navH*0.25f);
            //if active, draw a grey background for the channel select checkboxes
            fill(180);
            rect(x,y,w,navH);
        }

        cp5_channelCheckboxes.draw();
    }

    public void screenResized(PApplet _parent) {
        cp5_channelCheckboxes.setGraphics(_parent, 0, 0);
        cp5_channelCheckboxes.get(CheckBox.class, chanDropdownName).setPosition(x + 2, y + offset);
    }

    public void mousePressed(boolean dropdownIsActive) {
        if (!dropdownIsActive) {
            if (mouseX > (chanSelectXPos) && mouseX < (tri_xpos + 10) && mouseY < (y - navH*0.25f) && mouseY > (y - navH*0.65f)) {
                channelSelectPressed = !channelSelectPressed;
                if (channelSelectPressed) {
                    for (int i = 0; i < nchan; i++) {
                        checkList.getItem(i).setVisible(true);
                    }
                } else {
                    for (int i = 0; i < nchan; i++) {
                        checkList.getItem(i).setVisible(false);
                    }
                }
            }
        }
    }

    public boolean isVisible() {
        return channelSelectPressed;
    }

    public void createCheckList(int _nchan) {
        int checkSize = navH - 4;
        offset = (navH - checkSize)/2;

        channelSelectHover = false;
        channelSelectPressed = false;

        //Name the checkbox the same as the text display on screen
        checkList = cp5_channelCheckboxes.addCheckBox(chanDropdownName)
                        .setPosition(x + 5, y + offset)
                        .setSize(checkSize, checkSize)
                        .setItemsPerRow(nchan)
                        .setSpacingColumn(13)
                        .setSpacingRow(2)
                        .setColorLabel(color(0)) //Set the color of the text label
                        .setColorForeground(color(120)) //checkbox color when mouse is hovering over it
                        .setColorBackground(color(150)) //checkbox background color
                        .setColorActive(color(57, 128, 204)) //checkbox color when active
                        ;

        //nchan is a global variable, so we can use it here with no problems
        for (int i = 0; i < _nchan; i++) {
            int chNum = i+1;
            cp5_channelCheckboxes.get(CheckBox.class, chanDropdownName)
                            .addItem(String.valueOf(chNum), chNum)
                            ;
            //start all items as invisible until user clicks dropdown to show checkboxes
            checkList.getItem(i).setVisible(false);
        }

        cp5_channelCheckboxes.setAutoDraw(false); //draw only when specified
        //cp5_channelCheckboxes.setGraphics(_parent, 0, 0);
        cp5_channelCheckboxes.get(CheckBox.class, chanDropdownName).setPosition(x + 2, y + offset);
    }
} //end of ChannelSelect class

int navHeight = 22;

//========================================================================================
//=================              ADD NEW WIDGETS HERE            =========================
//========================================================================================
/*
    Notes:
    - In this file all you have to do is MAKE YOUR WIDGET GLOBALLY, and then ADD YOUR WIDGET TO WIDGETS OF WIDGETMANAGER in the setupWidgets() function below
    - the order in which they are added will effect the order in which they appear in the GUI and in the WidgetSelector dropdown menu of each widget
    - use the WidgetTemplate.pde file as a starting point for creating new widgets (also check out W_timeSeries.pde, W_fft.pde, and W_HeadPlot.pde)
*/

// MAKE YOUR WIDGET GLOBALLY
W_timeSeries w_timeSeries;
W_fft w_fft;
W_Networking w_networking;
W_BandPower w_bandPower;
W_Accelerometer w_accelerometer;
W_GanglionImpedance w_ganglionImpedance;
W_HeadPlot w_headPlot;
W_template w_template1;
W_emg w_emg;
W_openBionics w_openbionics;
W_Focus w_focus;
W_PulseSensor w_pulsesensor;
W_AnalogRead w_analogRead;
W_DigitalRead w_digitalRead;
W_MarkerMode w_markermode;
W_playback w_playback;
W_SSVEP w_ssvep;

//ADD YOUR WIDGET TO WIDGETS OF WIDGETMANAGER
public void setupWidgets(PApplet _this, ArrayList<Widget> w){
    // println("  setupWidgets start -- " + millis());

    //Widget_0
    w_timeSeries = new W_timeSeries(_this);
    w_timeSeries.setTitle("Time Series");
    addWidget(w_timeSeries, w);
    // println("  setupWidgets time series -- " + millis());

    //Widget_1
    w_fft = new W_fft(_this);
    w_fft.setTitle("FFT Plot");
    addWidget(w_fft, w);
    // println("  setupWidgets fft -- " + millis());

    //Widget_2
    w_accelerometer = new W_Accelerometer(_this);
    w_accelerometer.setTitle("Accelerometer");
    addWidget(w_accelerometer, w);

    //only instantiate this widget if you are using a Ganglion board for live streaming
    if(nchan == 4 && eegDataSource == DATASOURCE_GANGLION){
        //If using Ganglion, this is Widget_3
        w_ganglionImpedance = new W_GanglionImpedance(_this);
        w_ganglionImpedance.setTitle("Ganglion Signal");
        addWidget(w_ganglionImpedance, w);
    }

    if(eegDataSource == DATASOURCE_PLAYBACKFILE){
        //Playback Widget_3
        w_playback = new W_playback(_this);
        w_playback.setTitle("Playback History");
        addWidget(w_playback, w);
    }

    //Cyton/Synthetic Widget_3, Ganglion/Playback Widget_4
    w_networking = new W_Networking(_this);
    w_networking.setTitle("Networking");
    addWidget(w_networking, w);

    //Cyton/Synthetic Widget_4, Ganglion/Playback Widget_5
    w_bandPower = new W_BandPower(_this);
    w_bandPower.setTitle("Band Power");
    addWidget(w_bandPower, w);
    // println("  setupWidgets band power -- " + millis());

    //Cyton/Synthetic Widget_5, Ganglion/Playback Widget_6
    w_headPlot = new W_HeadPlot(_this);
    w_headPlot.setTitle("Head Plot");
    addWidget(w_headPlot, w);
    // println("  setupWidgets head plot -- " + millis());

    //Cyton/Synthetic Widget_6, Ganglion/Playback Widget_7
    w_emg = new W_emg(_this);
    w_emg.setTitle("EMG");
    addWidget(w_emg, w);
    // println("  setupWidgets emg -- " + millis());

    //Cyton/Synthetic Widget_7, Ganglion/Playback Widget_8
    w_focus = new W_Focus(_this);
    w_focus.setTitle("Focus Widget");
    addWidget(w_focus, w);
    // println("  setupWidgets focus widget -- " + millis());

    w_ssvep = new W_SSVEP(_this);
    w_ssvep.setTitle("SSVEP_beta");
    addWidget(w_ssvep, w);

    //only instantiate these widgets if you are using a Cyton board for live streaming
    if(eegDataSource == DATASOURCE_CYTON){
        //Cyton Widget_8
        w_pulsesensor = new W_PulseSensor(_this);
        w_pulsesensor.setTitle("Pulse Sensor");
        addWidget(w_pulsesensor, w);
        // println("  setupWidgets pulse sensor -- " + millis());

        //Cyton Widget_9
        w_digitalRead = new W_DigitalRead(_this);
        w_digitalRead.setTitle("Digital Read");
        addWidget(w_digitalRead, w);

        //Cyton Widget_10
        w_analogRead = new W_AnalogRead(_this);
        w_analogRead.setTitle("Analog Read");
        addWidget(w_analogRead, w);

        //Cyton Widget_11
        w_markermode = new W_MarkerMode(_this);
        w_markermode.setTitle("Marker Mode");
        addWidget(w_markermode, w);
    }

    
    //Cyton Widget_12, Synthetic Widget_8, Ganglion/Playback Widget_9
    //DEVELOPERS: Here is an example widget with the essentials/structure in place
    w_template1 = new W_template(_this);
    w_template1.setTitle("Widget Template 1");
    addWidget(w_template1, w);

    // w_template2 = new W_template(_this);
    // w_template2.setTitle("Widget Template 2");
    // addWidget(w_template2, w);

    // w_openbionics = new W_OpenBionics(_this);
    // w_openbionics.setTitle("OpenBionics");
    // addWidget(w_openbionics,w);

    // w_template3 = new W_template(_this);
    // w_template3.setTitle("LSL Stream");
    // addWidget(w_template3, w);

}

//========================================================================================
//========================================================================================
//========================================================================================

WidgetManager wm;
boolean wmVisible = true;
CColor cp5_colors;

//Channel Colors -- Defaulted to matching the OpenBCI electrode ribbon cable
int[] channelColors = {
    color(129, 129, 129),
    color(124, 75, 141),
    color(54, 87, 158),
    color(49, 113, 89),
    color(221, 178, 13),
    color(253, 94, 52),
    color(224, 56, 45),
    color(162, 82, 49)
};


class WidgetManager{

    //this holds all of the widgets ... when creating/adding new widgets, we will add them to this ArrayList (below)
    ArrayList<Widget> widgets;
    ArrayList<String> widgetOptions; //List of Widget Titles, used to populate cp5 widgetSelector dropdown of all widgets

    //Variables for
    int currentContainerLayout; //this is the Layout structure for the main body of the GUI ... refer to [PUT_LINK_HERE] for layouts/numbers image
    ArrayList<Layout> layouts = new ArrayList<Layout>();  //this holds all of the different layouts ...

    public boolean isWMInitialized = false;
    private boolean visible = true;
    private boolean updating = true;

    WidgetManager(PApplet _this){
        widgets = new ArrayList<Widget>();
        widgetOptions = new ArrayList<String>();
        isWMInitialized = false;

        //DO NOT re-order the functions below
        setupLayouts();
        setupWidgets(_this, widgets);
        setupWidgetSelectorDropdowns();

        if(nchan == 4 && eegDataSource == DATASOURCE_GANGLION) {
            currentContainerLayout = 1;
            settings.currentLayout = 1; // used for save/load settings
            setNewContainerLayout(currentContainerLayout); //sets and fills layout with widgets in order of widget index, to reorganize widget index, reorder the creation in setupWidgets()
        } else if (eegDataSource == DATASOURCE_PLAYBACKFILE) {
            currentContainerLayout = 1;
            settings.currentLayout = 1; // used for save/load settings
            setNewContainerLayout(currentContainerLayout); //sets and fills layout with widgets in order of widget index, to reorganize widget index, reorder the creation in setupWidgets()
        } else {
            currentContainerLayout = 4; //default layout ... tall container left and 2 shorter containers stacked on the right
            settings.currentLayout = 4; // used for save/load settings
            setNewContainerLayout(currentContainerLayout); //sets and fills layout with widgets in order of widget index, to reorganize widget index, reorder the creation in setupWidgets()
        }

        delay(1000);

        isWMInitialized = true;
    }
    public boolean isVisible() {
        return visible;
    }
    public boolean isUpdating() {
        return updating;
    }

    public void setVisible(boolean _visible) {
        visible = _visible;
    }
    public void setUpdating(boolean _updating) {
        updating = _updating;
    }
    public void setupWidgetSelectorDropdowns(){
        //create the widgetSelector dropdown of each widget
        //println("widgets.size() = " + widgets.size());
        //create list of WidgetTitles.. we will use this to populate the dropdown (widget selector) of each widget
        for(int i = 0; i < widgets.size(); i++){
            widgetOptions.add(widgets.get(i).widgetTitle);
        }
        //println("widgetOptions.size() = " + widgetOptions.size());
        for(int i = 0; i <widgetOptions.size(); i++){
            widgets.get(i).setupWidgetSelectorDropdown(widgetOptions);
            widgets.get(i).setupNavDropdowns();
        }
    }

    public void update(){
        // if(visible && updating){
        if(visible){
            for(int i = 0; i < widgets.size(); i++){
                if(widgets.get(i).isActive){
                    widgets.get(i).update();
                    //if the widgets are not mapped to containers correctly, remap them..
                    // if(widgets.get(i).x != container[widgets.get(i).currentContainer].x || widgets.get(i).y != container[widgets.get(i).currentContainer].y || widgets.get(i).w != container[widgets.get(i).currentContainer].w || widgets.get(i).h != container[widgets.get(i).currentContainer].h){
                    if(widgets.get(i).x0 != (int)container[widgets.get(i).currentContainer].x || widgets.get(i).y0 != (int)container[widgets.get(i).currentContainer].y || widgets.get(i).w0 != (int)container[widgets.get(i).currentContainer].w || widgets.get(i).h0 != (int)container[widgets.get(i).currentContainer].h){
                        screenResized();
                        println("WidgetManager.pde: Remapping widgets to container layout...");
                    }
                }
            }
        }
    }

    public void draw(){
        if(visible){
            for(int i = 0; i < widgets.size(); i++){
                if(widgets.get(i).isActive){
                    pushStyle();
                    widgets.get(i).draw();
                    widgets.get(i).drawDropdowns();
                    popStyle();
                }else{
                    if(widgets.get(i).widgetTitle.equals("Networking")){
                        try{
                            w_networking.shutDown();
                        }catch (NullPointerException e){
                            println("WM:Networking_shutDown_Error: " + e);
                        }
                    }
                }
            }
        }
    }

    public void screenResized(){
        for(int i = 0; i < widgets.size(); i++){
            widgets.get(i).screenResized();
        }
    }

    public void mousePressed(){
        for(int i = 0; i < widgets.size(); i++){
            if(widgets.get(i).isActive){
                widgets.get(i).mousePressed();
            }

        }
    }

    public void mouseReleased(){
        for(int i = 0; i < widgets.size(); i++){
            if(widgets.get(i).isActive){
                widgets.get(i).mouseReleased();
            }
        }
    }

    public void mouseDragged(){
        for(int i = 0; i < widgets.size(); i++){
            if(widgets.get(i).isActive){
                widgets.get(i).mouseDragged();
            }
        }
    }

    public void setupLayouts(){
        //refer to [PUT_LINK_HERE] for layouts/numbers image
        //note that the order you create/add these layouts matters... if you reorganize these, the LayoutSelector will be out of order
        layouts.add(new Layout(new int[]{5})); //layout 1
        layouts.add(new Layout(new int[]{1,3,7,9})); //layout 2
        layouts.add(new Layout(new int[]{4,6})); //layout 3
        layouts.add(new Layout(new int[]{2,8})); //etc.
        layouts.add(new Layout(new int[]{4,3,9}));
        layouts.add(new Layout(new int[]{1,7,6}));
        layouts.add(new Layout(new int[]{1,3,8}));
        layouts.add(new Layout(new int[]{2,7,9}));
        layouts.add(new Layout(new int[]{4,11,12,13,14}));
        layouts.add(new Layout(new int[]{4,15,16,17,18}));
        layouts.add(new Layout(new int[]{1,7,11,12,13,14}));
        layouts.add(new Layout(new int[]{1,7,15,16,17,18}));
    }

    public void printLayouts(){
        for(int i = 0; i < layouts.size(); i++){
            println("WM:printLayouts: " + layouts.get(i));
            String layoutString = "";
            for(int j = 0; j < layouts.get(i).myContainers.length; j++){
                // println("WM:layoutContainers: " + layouts.get(i).myContainers[j]);
                layoutString += layouts.get(i).myContainers[j].x + ", ";
                layoutString += layouts.get(i).myContainers[j].y + ", ";
                layoutString += layouts.get(i).myContainers[j].w + ", ";
                layoutString += layouts.get(i).myContainers[j].h;
            }
            println("WM:printLayouts: " + layoutString);
        }
    }

    public void setNewContainerLayout(int _newLayout){

        //find out how many active widgets we need...
        int numActiveWidgetsNeeded = layouts.get(_newLayout).myContainers.length;
        //calculate the number of current active widgets & keep track of which widgets are active
        int numActiveWidgets = 0;
        // ArrayList<int> activeWidgets = new ArrayList<int>();
        for(int i = 0; i < widgets.size(); i++){
            if(widgets.get(i).isActive){
                numActiveWidgets++; //increment numActiveWidgets
                // activeWidgets.add(i); //keep track of the active widget
            }
        }

        if(numActiveWidgets > numActiveWidgetsNeeded){ //if there are more active widgets than needed
            //shut some down
            int numToShutDown = numActiveWidgets - numActiveWidgetsNeeded;
            int counter = 0;
            println("WM: Powering " + numToShutDown + " widgets down, and remapping.");
            for(int i = widgets.size()-1; i >= 0; i--){
                if(widgets.get(i).isActive && counter < numToShutDown){
                    verbosePrint("WM: Deactivating widget [" + i + "]");
                    widgets.get(i).isActive = false;
                    counter++;
                }
            }

            //and map active widgets
            counter = 0;
            for(int i = 0; i < widgets.size(); i++){
                if(widgets.get(i).isActive){
                    widgets.get(i).setContainer(layouts.get(_newLayout).containerInts[counter]);
                    counter++;
                }
            }

        } else if(numActiveWidgetsNeeded > numActiveWidgets){ //if there are less active widgets than needed
            //power some up
            int numToPowerUp = numActiveWidgetsNeeded - numActiveWidgets;
            int counter = 0;
            verbosePrint("WM: Powering " + numToPowerUp + " widgets up, and remapping.");
            for(int i = 0; i < widgets.size(); i++){
                if(!widgets.get(i).isActive && counter < numToPowerUp){
                    verbosePrint("WM: Activating widget [" + i + "]");
                    widgets.get(i).isActive = true;
                    counter++;
                }
            }

            //and map active widgets
            counter = 0;
            for(int i = 0; i < widgets.size(); i++){
                if(widgets.get(i).isActive){
                    widgets.get(i).setContainer(layouts.get(_newLayout).containerInts[counter]);
                    // widgets.get(i).screenResized(); // do this to make sure the container is updated
                    counter++;
                }
            }

        } else{ //if there are the same amount
            //simply remap active widgets
            verbosePrint("WM: Remapping widgets.");
            int counter = 0;
            for(int i = 0; i < widgets.size(); i++){
                if(widgets.get(i).isActive){
                    widgets.get(i).setContainer(layouts.get(_newLayout).containerInts[counter]);
                    counter++;
                }
            }
        }
    }
};

//this is a global function for adding new widgets--and their children (timeSeries, FFT, headPlot, etc.)--to the WidgetManager's widget ArrayList
public void addWidget(Widget myNewWidget, ArrayList<Widget> w){
    w.add(myNewWidget);
}

//the Layout class is an orgnanizational tool ... a layout consists of a combination of containers ... refer to Container.pde
class Layout{

    Container[] myContainers;
    int[] containerInts;

    Layout(int[] _myContainers){ //when creating a new layout, you pass in the integer #s of the containers you want as part of the layout ... so if I pass in the array {5}, my layout is 1 container that takes up the whole GUI body
        //constructor stuff
        myContainers = new Container[_myContainers.length]; //make the myContainers array equal to the size of the incoming array of ints
        containerInts = new int[_myContainers.length];
        for(int i = 0; i < _myContainers.length; i++){
            myContainers[i] = container[_myContainers[i]];
            containerInts[i] = _myContainers[i];
        }
    }

    public Container getContainer(int _numContainer){
        if(_numContainer < myContainers.length){
            return myContainers[_numContainer];
        } else{
            println("WM: Tried to return a non-existant container...");
            return myContainers[myContainers.length-1];
        }
    }
};
  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "OpenBCI_GUI" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
